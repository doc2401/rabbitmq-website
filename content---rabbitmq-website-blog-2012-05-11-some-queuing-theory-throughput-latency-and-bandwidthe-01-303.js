"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkrabbitmq_website"] = globalThis["webpackChunkrabbitmq_website"] || []).push([["content---rabbitmq-website-blog-2012-05-11-some-queuing-theory-throughput-latency-and-bandwidthe-01-303"],{

/***/ "./.docusaurus/docusaurus-plugin-content-blog/default/site-blog-2012-05-11-some-queuing-theory-throughput-latency-and-bandwidth-index-md-e01.json":
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"permalink":"/rabbitmq-website/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth","editUrl":"https://github.com/rabbitmq/rabbitmq-website/tree/main/blog/2012-05-11-some-queuing-theory-throughput-latency-and-bandwidth/index.md","source":"@site/blog/2012-05-11-some-queuing-theory-throughput-latency-and-bandwidth/index.md","title":"Some queuing theory: throughput, latency and bandwidth","description":"You have a queue in Rabbit. You have some clients consuming from that","date":"2012-05-11T00:00:00.000Z","tags":[{"inline":true,"label":"HowTo","permalink":"/rabbitmq-website/blog/tags/how-to"},{"inline":true,"label":"New Features","permalink":"/rabbitmq-website/blog/tags/new-features"}],"readingTime":11.775,"hasTruncateMarker":true,"authors":[{"name":"Matthew Sackman","key":"matthew","page":null}],"frontMatter":{"title":"Some queuing theory: throughput, latency and bandwidth","tags":["HowTo","New Features"],"authors":["matthew"]},"unlisted":false,"prevItem":{"title":"Introducing RabbitMQ-Web-Stomp","permalink":"/rabbitmq-website/blog/2012/05/14/introducing-rabbitmq-web-stomp"},"nextItem":{"title":"RabbitMQ Performance Measurements, part 2","permalink":"/rabbitmq-website/blog/2012/04/25/rabbitmq-performance-measurements-part-2"}}');

/***/ }),

/***/ "./blog/2012-05-11-some-queuing-theory-throughput-latency-and-bandwidth/index.md":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assets: () => (/* binding */ assets),\n/* harmony export */   contentTitle: () => (/* binding */ contentTitle),\n/* harmony export */   \"default\": () => (/* binding */ MDXContent),\n/* harmony export */   frontMatter: () => (/* binding */ frontMatter),\n/* harmony export */   metadata: () => (/* reexport default export from named module */ _site_docusaurus_docusaurus_plugin_content_blog_default_site_blog_2012_05_11_some_queuing_theory_throughput_latency_and_bandwidth_index_md_e01_json__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   toc: () => (/* binding */ toc)\n/* harmony export */ });\n/* harmony import */ var _site_docusaurus_docusaurus_plugin_content_blog_default_site_blog_2012_05_11_some_queuing_theory_throughput_latency_and_bandwidth_index_md_e01_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./.docusaurus/docusaurus-plugin-content-blog/default/site-blog-2012-05-11-some-queuing-theory-throughput-latency-and-bandwidth-index-md-e01.json\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var _mdx_js_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/@mdx-js/react/lib/index.js\");\n\n\nconst frontMatter = {\n\ttitle: 'Some queuing theory: throughput, latency and bandwidth',\n\ttags: [\n\t\t'HowTo',\n\t\t'New Features'\n\t],\n\tauthors: [\n\t\t'matthew'\n\t]\n};\nconst contentTitle = undefined;\n\nconst assets = {\n\"authorsImageUrls\": [undefined],\n};\n\n\n\nconst toc = [];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    em: \"em\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    ...(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"You have a queue in Rabbit. You have some clients consuming from that\\r\\nqueue. If you don't set a QoS setting at all (\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"basic.qos\"\n      }), \"), then\\r\\nRabbit will push all the queue's messages to the clients as fast as\\r\\nthe network and the clients will allow. The consumers will balloon in\\r\\nmemory as they buffer all the messages in their own RAM. The queue may\\r\\nappear empty if you ask Rabbit, but there may be millions of messages\\r\\nunacknowledged as they sit in the clients, ready for processing by the\\r\\nclient application. If you add a new consumer, there are no messages\\r\\nleft in the queue to be sent to the new consumer. Messages are just\\r\\nbeing buffered in the existing clients, and may be there for a long\\r\\ntime, even if there are other consumers that become available to\\r\\nprocess such messages sooner. This is rather sub optimal.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"So, the default QoS \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \" setting gives clients an \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"unlimited\"\n      }), \"\\r\\nbuffer, and that can result in poor behaviour and performance. But\\r\\nwhat should you set the QoS \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \" buffer size to? The goal is to\\r\\nkeep the consumers saturated with work, but to minimise the client's\\r\\nbuffer size so that more messages stay in Rabbit's queue and are thus\\r\\navailable for new consumers or to just be sent out to consumers as\\r\\nthey become free.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Let's say it takes 50ms for Rabbit to take a message from this queue,\\r\\nput it on the network and for it to arrive at the consumer. It takes\\r\\n4ms for the client to process the message. Once the consumer has\\r\\nprocessed the message, it sends an \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"ack\"\n      }), \" back to Rabbit, which takes a\\r\\nfurther 50ms to be sent to and processed by Rabbit. So we have a total\\r\\nround trip time of 104ms. If we have a QoS \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \" setting of 1\\r\\nmessage then Rabbit won't sent out the next message until after this\\r\\nround trip completes. Thus the client will be busy for only 4ms of\\r\\nevery 104ms, or 3.8% of the time. We want it to be busy 100% of the\\r\\ntime.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.img, {\n        src: (__webpack_require__(\"./node_modules/url-loader/dist/cjs.js?limit=10000&name=assets/images/[name]-[contenthash].[ext]&fallback=/mnt/d/xy2401/codeDoc/rabbitmq-website/node_modules/file-loader/dist/cjs.js!./blog/2012-05-11-some-queuing-theory-throughput-latency-and-bandwidth/qos.svg\")[\"default\"]) + \"\",\n        width: \"693\",\n        height: \"178\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"If we do \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"total round trip time\"\n      }), \" / \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"processing time on the client for\\r\\neach message\"\n      }), \", we get \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"104 / 4 = 26\"\n      }), \". If we have a QoS \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \" of\\r\\n26 messages this solves our problem: assume that the client has 26\\r\\nmessages buffered, ready and waiting for processing. (This is a\\r\\nsensible assumption: once you set \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"basic.qos\"\n      }), \" and then \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"consume\"\n      }), \" from\\r\\na queue, Rabbit will send as many messages as it can from the queue\\r\\nyou've subscribed to to the client, up to the QoS limit. If you assume\\r\\nmessages aren't very big and bandwidth is high, it's likely Rabbit\\r\\nwill be able to send messages to your consuming client faster than\\r\\nyour client can process them. Thus it's reasonable (and simpler) to do\\r\\nall the maths from the assumption of a full client-side buffer.) If\\r\\neach message takes 4ms of processing to deal with then it'll take a\\r\\ntotal of \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"26 * 4 = 104ms\"\n      }), \" to deal with the entire buffer. The first\\r\\n4ms is the client processing of the first message. The client then\\r\\nissues an \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"ack\"\n      }), \" and goes on to process the next message from the\\r\\nbuffer. That ack takes 50ms to get to the broker. The broker than\\r\\nissues a new message to the client, which takes 50ms to get there, so\\r\\nby the time 104ms has passed and the client has finished processing\\r\\nits buffer, the next message from the broker has already arrived and\\r\\nis ready and waiting for the client to process it. Thus the client\\r\\nremains busy all the time: having a bigger QoS \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \" will not\\r\\nmake it go faster; but we minimise the buffer size and thus latency of\\r\\nmessages in the client: messages are buffered by the client for no\\r\\nlonger than they need to be in order to keep the client saturated with\\r\\nwork. In fact, the client is able to fully drain the buffer before the\\r\\nnext message arrives, thus the buffer actually stays empty.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"This solution is absolutely fine, provided processing time and network\\r\\nbehaviour remains the same. But consider what happens if suddenly the\\r\\nnetwork halves in speed: your \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \" buffer is no longer big\\r\\nenough and now the client will sit idle, waiting for new messages to\\r\\narrive as the client is able to process messages faster than Rabbit\\r\\ncan supply fresh messages.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"To address this problem, we might just decide to double (or nearly\\r\\ndouble) the QoS \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \" size. If we push it to 51 from 26, then if\\r\\nthe client processing remains at 4ms per message, we now have \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"51 * 4 = 204ms\"\n      }), \" of messages in the buffer, of which 4ms will be spent\\r\\nprocessing a message, leaving 200ms for the sending an ack back to\\r\\nRabbit and receiving the next message. Thus we can now cope with the\\r\\nnetwork halving in speed.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"But if the network's performing normally, doubling our QoS \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \"\\r\\nnow means each message will sit in the client side buffer for a while,\\r\\ninstead of being processed immediately upon arrival at the\\r\\nclient. Again, starting from a full buffer of now 51 messages we know\\r\\nthat new messages will start appearing at the client 100ms after the\\r\\nclient finishes processing the first message. But in those 100ms, the\\r\\nclient will have processed \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"100 / 4 = 25\"\n      }), \" messages out of the 50\\r\\navailable. Which means as a new message arrives at the client, it'll\\r\\nbe added to the end of the buffer as the client removes from the head\\r\\nof the buffer. The buffer will thus always stay \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"50 - 25 = 25\"\n      }), \"\\r\\nmessages long and every message will thus sit in the buffer for \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"25 * 4 = 100ms\"\n      }), \", increasing the latency between Rabbit sending it to the\\r\\nclient and the client starting to process it from 50ms to 150ms.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Thus we see that increasing the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \" buffer so that the client\\r\\ncan cope with deteriorated network performance whilst keeping the\\r\\nclient busy, substantially increases the latency when the network is\\r\\nperforming normally.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Equally, rather than the network's performance deteriorating, what\\r\\nhappens if the client starts taking 40ms to process each message\\r\\nrather than 4ms? If the queue in Rabbit was previously at a steady\\r\\nlength (i.e. ingress and egress rates were the same), it'll now start\\r\\ngrowing rapidly, as the egress rate has dropped to a tenth of what it\\r\\nwas. You might decide to try and work through this growing backlog by\\r\\nadding more consumers, but there are messages now being buffered by\\r\\nthe existing clients. Assuming the original buffer size of 26\\r\\nmessages, the client will spend 40ms processing the first message,\\r\\nwill then send the ack back to Rabbit and move onto the next\\r\\nmessage. The ack still takes 50ms to get to Rabbit and a further 50ms\\r\\nfor Rabbit to send out a new message, but in that 100ms, the client\\r\\nhas only worked through \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"100 / 40 = 2.5\"\n      }), \" further messages rather than\\r\\nthe remaining 25 messages. Thus the buffer is at this point \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"25 - 3 = 22\"\n      }), \" messages long. The new message arriving from Rabbit, rather than\\r\\nbeing processed immediately, now sits in 23rd place, behind 22 other\\r\\nmessages still waiting to be processed, and will not be touched by the\\r\\nclient for a further \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"22 * 40 = 880ms\"\n      }), \". Given the network delay from\\r\\nRabbit to the client is only 50ms, this additional 880ms delay is now\\r\\n95% of the latency (\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"880 / (880 + 50) = 0.946\"\n      }), \").\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Even worse, what happens if we doubled the buffer size to 51 messages\\r\\nin order to cope with network performance degradation? After the first\\r\\nmessage has been processed, there will be 50 further messages buffered\\r\\nin the client. 100ms later (assuming the network is running normally),\\r\\na new message will arrive from Rabbit, and the client will be half way\\r\\nthrough processing the 3rd of those 50 messages (the buffer will now\\r\\nbe 47 messages long), thus the new message will be 48th in the buffer,\\r\\nand will not be touched for a further \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"47 * 40 = 1880ms\"\n      }), \". Again, given\\r\\nthe network delay of getting the message to the client is only 50ms,\\r\\nthis further 1880ms delay now means client side buffering is\\r\\nresponsible for over 97% of the latency (\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"1880 / (1880 + 50) = 0.974\"\n      }), \"). This may very well be unacceptable: the data may only be\\r\\nvalid and useful if it's processed promptly, not some 2 seconds after\\r\\nthe client received it! If other consuming clients are idle, there's\\r\\nnothing they can do: once Rabbit has sent a message to a client, the\\r\\nmessage is the client's responsibility until it acks or rejects the\\r\\nmessage. Clients can't steal messages from each other once the message\\r\\nhas been sent to a client. What you want is for clients to be kept\\r\\nbusy, but for clients to buffer as few messages as possible so that\\r\\nmessages are not delayed by client-side buffers and thus new consuming\\r\\nclients can be quickly fed with messages from Rabbit's queue.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"So, too small a buffer results in clients going idle if the network\\r\\ngets slower, but too big a buffer results in lots of extra latency if\\r\\nthe network performs normally, and huge amounts of extra latency if\\r\\nthe client suddenly starts taking longer to process each message than\\r\\nnormal. It's clear that what you really want is a varying buffer\\r\\nsize. These problems are common across network devices and have been\\r\\nthe subject of much study. \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"Active Queue Management\"\n      }), \" algorithms seek\\r\\nto try and drop or reject messages so that you avoid messages sitting\\r\\nin buffers for long periods of time. The lowest latency is achieved\\r\\nwhen the buffer is kept empty (each message suffers network latency\\r\\nonly and does not sit around in a buffer at all) and buffers are there\\r\\nto absorb spikes. \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n        href: \"http://gettys.wordpress.com/\",\n        children: \"Jim Gettys\"\n      }), \" has been\\r\\nworking on this problem from the point of view of network routers:\\r\\ndifferences between performance of the LAN and the WAN suffer exactly\\r\\nthe same sorts of problems. Indeed whenever you have a buffer between\\r\\na producer (in our case Rabbit) and a consumer (the client-side\\r\\napplication logic) where the performance of both sides can vary\\r\\ndynamically, you will suffer these sorts of problems. Recently a new\\r\\nalgorithm called\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n        href: \"https://queue.acm.org/detail.cfm?id=2209336\",\n        children: \"Controlled Delay\"\n      }), \" has\\r\\nbeen published which\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n        href: \"http://arstechnica.com/information-technology/2012/05/codel-buffer-management-could-solve-the-internets-bufferbloat-jams/\",\n        children: \"appears to work well\"\n      }), \"\\r\\nin solving these problems.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"The authors claim that their \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"CoDel\"\n      }), \" (\\\"coddle\\\") algorithm is a \\\"knob\\r\\nfree\\\" algorithm. This is a bit of a lie really: there are two knobs\\r\\nand they do need setting appropriately. But they don't need changing\\r\\nevery time performance changes, which is a massive benefit. I have\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n        href: \"https://gist.github.com/2658712\",\n        children: \"implemented this algorithm\"\n      }), \" for our\\r\\nAMQP Java Client as a variant of the QueueingConsumer. Whilst the\\r\\noriginal algorithm is aimed at the TCP layer, where it's valid to just\\r\\ndrop packets (TCP itself will take care\\r\\nof re-transmission of lost packets), in AMQP that's not so polite! As a result,\\r\\nmy implementation uses Rabbit's \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"basic.nack\"\n      }), \" extension to explicitly\\r\\nreturn messages to the queue so they can be processed by others.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n        href: \"https://gist.github.com/2658727\",\n        children: \"Using it is pretty much the same\"\n      }), \" as\\r\\nthe normal QueueingConsumer except that you should provide three extra\\r\\nparameters to the constructor to get the best performance.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.ol, {\n      children: [\"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li, {\n        children: [\"The first is \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n          children: \"requeue\"\n        }), \" which says whether, when messages are\\r\\nnacked, should they be requeued or discarded. If false, they will\\r\\nbe discarded which may trigger the dead letter exchange mechanisms\\r\\nif they're set up.\"]\n      }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li, {\n        children: [\"The second is the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n          children: \"targetDelay\"\n        }), \" which is the acceptable time in\\r\\nmilliseconds for messages to wait in the client-side QoS \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n          children: \"prefetch\"\n        }), \"\\r\\nbuffer.\"]\n      }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li, {\n        children: [\"The third is the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n          children: \"interval\"\n        }), \" and is the expected worst case\\r\\nprocessing time of one message in milliseconds. This doesn't have\\r\\nto be spot on, but within an order of magnitude certainly helps.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"You should still set a QoS \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"prefetch\"\n      }), \" size appropriately. If you do\\r\\nnot, what is likely is that the client will be sent a lot of messages,\\r\\nand the algorithm will then have to return them to Rabbit if they sit\\r\\nin the buffer for too long. It's easy to end up with a lot of extra\\r\\nnetwork traffic as messages are returned to Rabbit. The CoDel\\r\\nalgorithm is meant to only start dropping (or rejecting) messages once\\r\\nperformance diverges from the norm, thus a worked example might help.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Again, assume network traversal time in each direction of 50ms, and we\\r\\nexpect the client to spend 4ms on average processing each message, but\\r\\nthis can spike to 20ms. We thus set the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"interval\"\n      }), \" parameter of CoDel\\r\\nto 20. Sometimes the network halves in speed, so the traversal time\\r\\ncan be 100ms in each direction. To cater for that, we set the\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"basic.qos prefetch\"\n      }), \" to \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"204 / 4 = 51\"\n      }), \". Yes, this means that the\\r\\nbuffer will remain 25 messages long most of the time when the network\\r\\nis running normally (see workings earlier), but we decide that's\\r\\nOK. Each message will thus sit in the buffer for an expected \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"25 * 4 = 100ms\"\n      }), \", so we set the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"targetDelay\"\n      }), \" of CoDel to 100.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"When things are running normally, CoDel should not get in the way, and\\r\\nfew if any messages should be being nacked. But should the client\\r\\nstart processing messages more slowly than normal, CoDel will spot\\r\\nthat messages have been buffered by the client for too long, and will\\r\\nreturn those messages to the queue. If those messages are requeued\\r\\nthen they will become available for delivery to other clients.\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"This is very much experimental at the moment, and it's possible to see\\r\\nreasons why CoDel isn't as appropriate for dealing with AMQP messages\\r\\nas it is for plain IP. It's also worth remembering that requeuing\\r\\nmessages via nacks is a fairly expensive operation, so it's a good\\r\\nidea to set the parameters of CoDel to ensure in normal operation very\\r\\nfew if any messages are being nacked. The management plugin is an easy\\r\\nway to inspect how many messages are being nacked. As ever, comments,\\r\\nfeedback and improvements are most welcome!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MDXLayout, {\n    ...props,\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ibG9nLzIwMTItMDUtMTEtc29tZS1xdWV1aW5nLXRoZW9yeS10aHJvdWdocHV0LWxhdGVuY3ktYW5kLWJhbmR3aWR0aC9pbmRleC5tZCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmFiYml0bXEtd2Vic2l0ZS8uL2Jsb2cvMjAxMi0wNS0xMS1zb21lLXF1ZXVpbmctdGhlb3J5LXRocm91Z2hwdXQtbGF0ZW5jeS1hbmQtYmFuZHdpZHRoL2luZGV4Lm1kPzRlZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbmV4cG9ydCBjb25zdCBmcm9udE1hdHRlciA9IHtcblx0dGl0bGU6ICdTb21lIHF1ZXVpbmcgdGhlb3J5OiB0aHJvdWdocHV0LCBsYXRlbmN5IGFuZCBiYW5kd2lkdGgnLFxuXHR0YWdzOiBbXG5cdFx0J0hvd1RvJyxcblx0XHQnTmV3IEZlYXR1cmVzJ1xuXHRdLFxuXHRhdXRob3JzOiBbXG5cdFx0J21hdHRoZXcnXG5cdF1cbn07XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gdW5kZWZpbmVkO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1ldGFkYXRhfSBmcm9tICdAc2l0ZS8uZG9jdXNhdXJ1cy9kb2N1c2F1cnVzLXBsdWdpbi1jb250ZW50LWJsb2cvZGVmYXVsdC9zaXRlLWJsb2ctMjAxMi0wNS0xMS1zb21lLXF1ZXVpbmctdGhlb3J5LXRocm91Z2hwdXQtbGF0ZW5jeS1hbmQtYmFuZHdpZHRoLWluZGV4LW1kLWUwMS5qc29uJ1xuZXhwb3J0IGNvbnN0IGFzc2V0cyA9IHtcblwiYXV0aG9yc0ltYWdlVXJsc1wiOiBbdW5kZWZpbmVkXSxcbn07XG5cbmltcG9ydCB7RnJhZ21lbnQgYXMgX0ZyYWdtZW50LCBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4c30gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQge3VzZU1EWENvbXBvbmVudHMgYXMgX3Byb3ZpZGVDb21wb25lbnRzfSBmcm9tIFwiQG1keC1qcy9yZWFjdFwiO1xuZXhwb3J0IGNvbnN0IHRvYyA9IFtdO1xuZnVuY3Rpb24gX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpIHtcbiAgY29uc3QgX2NvbXBvbmVudHMgPSB7XG4gICAgYTogXCJhXCIsXG4gICAgY29kZTogXCJjb2RlXCIsXG4gICAgZW06IFwiZW1cIixcbiAgICBpbWc6IFwiaW1nXCIsXG4gICAgbGk6IFwibGlcIixcbiAgICBvbDogXCJvbFwiLFxuICAgIHA6IFwicFwiLFxuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIF9qc3hzKF9GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIllvdSBoYXZlIGEgcXVldWUgaW4gUmFiYml0LiBZb3UgaGF2ZSBzb21lIGNsaWVudHMgY29uc3VtaW5nIGZyb20gdGhhdFxcclxcbnF1ZXVlLiBJZiB5b3UgZG9uJ3Qgc2V0IGEgUW9TIHNldHRpbmcgYXQgYWxsIChcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImJhc2ljLnFvc1wiXG4gICAgICB9KSwgXCIpLCB0aGVuXFxyXFxuUmFiYml0IHdpbGwgcHVzaCBhbGwgdGhlIHF1ZXVlJ3MgbWVzc2FnZXMgdG8gdGhlIGNsaWVudHMgYXMgZmFzdCBhc1xcclxcbnRoZSBuZXR3b3JrIGFuZCB0aGUgY2xpZW50cyB3aWxsIGFsbG93LiBUaGUgY29uc3VtZXJzIHdpbGwgYmFsbG9vbiBpblxcclxcbm1lbW9yeSBhcyB0aGV5IGJ1ZmZlciBhbGwgdGhlIG1lc3NhZ2VzIGluIHRoZWlyIG93biBSQU0uIFRoZSBxdWV1ZSBtYXlcXHJcXG5hcHBlYXIgZW1wdHkgaWYgeW91IGFzayBSYWJiaXQsIGJ1dCB0aGVyZSBtYXkgYmUgbWlsbGlvbnMgb2YgbWVzc2FnZXNcXHJcXG51bmFja25vd2xlZGdlZCBhcyB0aGV5IHNpdCBpbiB0aGUgY2xpZW50cywgcmVhZHkgZm9yIHByb2Nlc3NpbmcgYnkgdGhlXFxyXFxuY2xpZW50IGFwcGxpY2F0aW9uLiBJZiB5b3UgYWRkIGEgbmV3IGNvbnN1bWVyLCB0aGVyZSBhcmUgbm8gbWVzc2FnZXNcXHJcXG5sZWZ0IGluIHRoZSBxdWV1ZSB0byBiZSBzZW50IHRvIHRoZSBuZXcgY29uc3VtZXIuIE1lc3NhZ2VzIGFyZSBqdXN0XFxyXFxuYmVpbmcgYnVmZmVyZWQgaW4gdGhlIGV4aXN0aW5nIGNsaWVudHMsIGFuZCBtYXkgYmUgdGhlcmUgZm9yIGEgbG9uZ1xcclxcbnRpbWUsIGV2ZW4gaWYgdGhlcmUgYXJlIG90aGVyIGNvbnN1bWVycyB0aGF0IGJlY29tZSBhdmFpbGFibGUgdG9cXHJcXG5wcm9jZXNzIHN1Y2ggbWVzc2FnZXMgc29vbmVyLiBUaGlzIGlzIHJhdGhlciBzdWIgb3B0aW1hbC5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIlNvLCB0aGUgZGVmYXVsdCBRb1MgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJwcmVmZXRjaFwiXG4gICAgICB9KSwgXCIgc2V0dGluZyBnaXZlcyBjbGllbnRzIGFuIFwiLCBfanN4KF9jb21wb25lbnRzLmVtLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcInVubGltaXRlZFwiXG4gICAgICB9KSwgXCJcXHJcXG5idWZmZXIsIGFuZCB0aGF0IGNhbiByZXN1bHQgaW4gcG9vciBiZWhhdmlvdXIgYW5kIHBlcmZvcm1hbmNlLiBCdXRcXHJcXG53aGF0IHNob3VsZCB5b3Ugc2V0IHRoZSBRb1MgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJwcmVmZXRjaFwiXG4gICAgICB9KSwgXCIgYnVmZmVyIHNpemUgdG8/IFRoZSBnb2FsIGlzIHRvXFxyXFxua2VlcCB0aGUgY29uc3VtZXJzIHNhdHVyYXRlZCB3aXRoIHdvcmssIGJ1dCB0byBtaW5pbWlzZSB0aGUgY2xpZW50J3NcXHJcXG5idWZmZXIgc2l6ZSBzbyB0aGF0IG1vcmUgbWVzc2FnZXMgc3RheSBpbiBSYWJiaXQncyBxdWV1ZSBhbmQgYXJlIHRodXNcXHJcXG5hdmFpbGFibGUgZm9yIG5ldyBjb25zdW1lcnMgb3IgdG8ganVzdCBiZSBzZW50IG91dCB0byBjb25zdW1lcnMgYXNcXHJcXG50aGV5IGJlY29tZSBmcmVlLlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiTGV0J3Mgc2F5IGl0IHRha2VzIDUwbXMgZm9yIFJhYmJpdCB0byB0YWtlIGEgbWVzc2FnZSBmcm9tIHRoaXMgcXVldWUsXFxyXFxucHV0IGl0IG9uIHRoZSBuZXR3b3JrIGFuZCBmb3IgaXQgdG8gYXJyaXZlIGF0IHRoZSBjb25zdW1lci4gSXQgdGFrZXNcXHJcXG40bXMgZm9yIHRoZSBjbGllbnQgdG8gcHJvY2VzcyB0aGUgbWVzc2FnZS4gT25jZSB0aGUgY29uc3VtZXIgaGFzXFxyXFxucHJvY2Vzc2VkIHRoZSBtZXNzYWdlLCBpdCBzZW5kcyBhbiBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImFja1wiXG4gICAgICB9KSwgXCIgYmFjayB0byBSYWJiaXQsIHdoaWNoIHRha2VzIGFcXHJcXG5mdXJ0aGVyIDUwbXMgdG8gYmUgc2VudCB0byBhbmQgcHJvY2Vzc2VkIGJ5IFJhYmJpdC4gU28gd2UgaGF2ZSBhIHRvdGFsXFxyXFxucm91bmQgdHJpcCB0aW1lIG9mIDEwNG1zLiBJZiB3ZSBoYXZlIGEgUW9TIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwicHJlZmV0Y2hcIlxuICAgICAgfSksIFwiIHNldHRpbmcgb2YgMVxcclxcbm1lc3NhZ2UgdGhlbiBSYWJiaXQgd29uJ3Qgc2VudCBvdXQgdGhlIG5leHQgbWVzc2FnZSB1bnRpbCBhZnRlciB0aGlzXFxyXFxucm91bmQgdHJpcCBjb21wbGV0ZXMuIFRodXMgdGhlIGNsaWVudCB3aWxsIGJlIGJ1c3kgZm9yIG9ubHkgNG1zIG9mXFxyXFxuZXZlcnkgMTA0bXMsIG9yIDMuOCUgb2YgdGhlIHRpbWUuIFdlIHdhbnQgaXQgdG8gYmUgYnVzeSAxMDAlIG9mIHRoZVxcclxcbnRpbWUuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuaW1nLCB7XG4gICAgICAgIHNyYzogcmVxdWlyZShcIiEvbW50L2QveHkyNDAxL2NvZGVEb2MvcmFiYml0bXEtd2Vic2l0ZS9ub2RlX21vZHVsZXMvdXJsLWxvYWRlci9kaXN0L2Nqcy5qcz9saW1pdD0xMDAwMCZuYW1lPWFzc2V0cy9pbWFnZXMvW25hbWVdLVtjb250ZW50aGFzaF0uW2V4dF0mZmFsbGJhY2s9L21udC9kL3h5MjQwMS9jb2RlRG9jL3JhYmJpdG1xLXdlYnNpdGUvbm9kZV9tb2R1bGVzL2ZpbGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vcW9zLnN2Z1wiKS5kZWZhdWx0ICsgXCJcIixcbiAgICAgICAgd2lkdGg6IFwiNjkzXCIsXG4gICAgICAgIGhlaWdodDogXCIxNzhcIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIklmIHdlIGRvIFwiLCBfanN4KF9jb21wb25lbnRzLmVtLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcInRvdGFsIHJvdW5kIHRyaXAgdGltZVwiXG4gICAgICB9KSwgXCIgLyBcIiwgX2pzeChfY29tcG9uZW50cy5lbSwge1xuICAgICAgICBjaGlsZHJlbjogXCJwcm9jZXNzaW5nIHRpbWUgb24gdGhlIGNsaWVudCBmb3JcXHJcXG5lYWNoIG1lc3NhZ2VcIlxuICAgICAgfSksIFwiLCB3ZSBnZXQgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCIxMDQgLyA0ID0gMjZcIlxuICAgICAgfSksIFwiLiBJZiB3ZSBoYXZlIGEgUW9TIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwicHJlZmV0Y2hcIlxuICAgICAgfSksIFwiIG9mXFxyXFxuMjYgbWVzc2FnZXMgdGhpcyBzb2x2ZXMgb3VyIHByb2JsZW06IGFzc3VtZSB0aGF0IHRoZSBjbGllbnQgaGFzIDI2XFxyXFxubWVzc2FnZXMgYnVmZmVyZWQsIHJlYWR5IGFuZCB3YWl0aW5nIGZvciBwcm9jZXNzaW5nLiAoVGhpcyBpcyBhXFxyXFxuc2Vuc2libGUgYXNzdW1wdGlvbjogb25jZSB5b3Ugc2V0IFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiYmFzaWMucW9zXCJcbiAgICAgIH0pLCBcIiBhbmQgdGhlbiBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImNvbnN1bWVcIlxuICAgICAgfSksIFwiIGZyb21cXHJcXG5hIHF1ZXVlLCBSYWJiaXQgd2lsbCBzZW5kIGFzIG1hbnkgbWVzc2FnZXMgYXMgaXQgY2FuIGZyb20gdGhlIHF1ZXVlXFxyXFxueW91J3ZlIHN1YnNjcmliZWQgdG8gdG8gdGhlIGNsaWVudCwgdXAgdG8gdGhlIFFvUyBsaW1pdC4gSWYgeW91IGFzc3VtZVxcclxcbm1lc3NhZ2VzIGFyZW4ndCB2ZXJ5IGJpZyBhbmQgYmFuZHdpZHRoIGlzIGhpZ2gsIGl0J3MgbGlrZWx5IFJhYmJpdFxcclxcbndpbGwgYmUgYWJsZSB0byBzZW5kIG1lc3NhZ2VzIHRvIHlvdXIgY29uc3VtaW5nIGNsaWVudCBmYXN0ZXIgdGhhblxcclxcbnlvdXIgY2xpZW50IGNhbiBwcm9jZXNzIHRoZW0uIFRodXMgaXQncyByZWFzb25hYmxlIChhbmQgc2ltcGxlcikgdG8gZG9cXHJcXG5hbGwgdGhlIG1hdGhzIGZyb20gdGhlIGFzc3VtcHRpb24gb2YgYSBmdWxsIGNsaWVudC1zaWRlIGJ1ZmZlci4pIElmXFxyXFxuZWFjaCBtZXNzYWdlIHRha2VzIDRtcyBvZiBwcm9jZXNzaW5nIHRvIGRlYWwgd2l0aCB0aGVuIGl0J2xsIHRha2UgYVxcclxcbnRvdGFsIG9mIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiMjYgKiA0ID0gMTA0bXNcIlxuICAgICAgfSksIFwiIHRvIGRlYWwgd2l0aCB0aGUgZW50aXJlIGJ1ZmZlci4gVGhlIGZpcnN0XFxyXFxuNG1zIGlzIHRoZSBjbGllbnQgcHJvY2Vzc2luZyBvZiB0aGUgZmlyc3QgbWVzc2FnZS4gVGhlIGNsaWVudCB0aGVuXFxyXFxuaXNzdWVzIGFuIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiYWNrXCJcbiAgICAgIH0pLCBcIiBhbmQgZ29lcyBvbiB0byBwcm9jZXNzIHRoZSBuZXh0IG1lc3NhZ2UgZnJvbSB0aGVcXHJcXG5idWZmZXIuIFRoYXQgYWNrIHRha2VzIDUwbXMgdG8gZ2V0IHRvIHRoZSBicm9rZXIuIFRoZSBicm9rZXIgdGhhblxcclxcbmlzc3VlcyBhIG5ldyBtZXNzYWdlIHRvIHRoZSBjbGllbnQsIHdoaWNoIHRha2VzIDUwbXMgdG8gZ2V0IHRoZXJlLCBzb1xcclxcbmJ5IHRoZSB0aW1lIDEwNG1zIGhhcyBwYXNzZWQgYW5kIHRoZSBjbGllbnQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmdcXHJcXG5pdHMgYnVmZmVyLCB0aGUgbmV4dCBtZXNzYWdlIGZyb20gdGhlIGJyb2tlciBoYXMgYWxyZWFkeSBhcnJpdmVkIGFuZFxcclxcbmlzIHJlYWR5IGFuZCB3YWl0aW5nIGZvciB0aGUgY2xpZW50IHRvIHByb2Nlc3MgaXQuIFRodXMgdGhlIGNsaWVudFxcclxcbnJlbWFpbnMgYnVzeSBhbGwgdGhlIHRpbWU6IGhhdmluZyBhIGJpZ2dlciBRb1MgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJwcmVmZXRjaFwiXG4gICAgICB9KSwgXCIgd2lsbCBub3RcXHJcXG5tYWtlIGl0IGdvIGZhc3RlcjsgYnV0IHdlIG1pbmltaXNlIHRoZSBidWZmZXIgc2l6ZSBhbmQgdGh1cyBsYXRlbmN5IG9mXFxyXFxubWVzc2FnZXMgaW4gdGhlIGNsaWVudDogbWVzc2FnZXMgYXJlIGJ1ZmZlcmVkIGJ5IHRoZSBjbGllbnQgZm9yIG5vXFxyXFxubG9uZ2VyIHRoYW4gdGhleSBuZWVkIHRvIGJlIGluIG9yZGVyIHRvIGtlZXAgdGhlIGNsaWVudCBzYXR1cmF0ZWQgd2l0aFxcclxcbndvcmsuIEluIGZhY3QsIHRoZSBjbGllbnQgaXMgYWJsZSB0byBmdWxseSBkcmFpbiB0aGUgYnVmZmVyIGJlZm9yZSB0aGVcXHJcXG5uZXh0IG1lc3NhZ2UgYXJyaXZlcywgdGh1cyB0aGUgYnVmZmVyIGFjdHVhbGx5IHN0YXlzIGVtcHR5LlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiVGhpcyBzb2x1dGlvbiBpcyBhYnNvbHV0ZWx5IGZpbmUsIHByb3ZpZGVkIHByb2Nlc3NpbmcgdGltZSBhbmQgbmV0d29ya1xcclxcbmJlaGF2aW91ciByZW1haW5zIHRoZSBzYW1lLiBCdXQgY29uc2lkZXIgd2hhdCBoYXBwZW5zIGlmIHN1ZGRlbmx5IHRoZVxcclxcbm5ldHdvcmsgaGFsdmVzIGluIHNwZWVkOiB5b3VyIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwicHJlZmV0Y2hcIlxuICAgICAgfSksIFwiIGJ1ZmZlciBpcyBubyBsb25nZXIgYmlnXFxyXFxuZW5vdWdoIGFuZCBub3cgdGhlIGNsaWVudCB3aWxsIHNpdCBpZGxlLCB3YWl0aW5nIGZvciBuZXcgbWVzc2FnZXMgdG9cXHJcXG5hcnJpdmUgYXMgdGhlIGNsaWVudCBpcyBhYmxlIHRvIHByb2Nlc3MgbWVzc2FnZXMgZmFzdGVyIHRoYW4gUmFiYml0XFxyXFxuY2FuIHN1cHBseSBmcmVzaCBtZXNzYWdlcy5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIlRvIGFkZHJlc3MgdGhpcyBwcm9ibGVtLCB3ZSBtaWdodCBqdXN0IGRlY2lkZSB0byBkb3VibGUgKG9yIG5lYXJseVxcclxcbmRvdWJsZSkgdGhlIFFvUyBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcInByZWZldGNoXCJcbiAgICAgIH0pLCBcIiBzaXplLiBJZiB3ZSBwdXNoIGl0IHRvIDUxIGZyb20gMjYsIHRoZW4gaWZcXHJcXG50aGUgY2xpZW50IHByb2Nlc3NpbmcgcmVtYWlucyBhdCA0bXMgcGVyIG1lc3NhZ2UsIHdlIG5vdyBoYXZlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiNTEgKiA0ID0gMjA0bXNcIlxuICAgICAgfSksIFwiIG9mIG1lc3NhZ2VzIGluIHRoZSBidWZmZXIsIG9mIHdoaWNoIDRtcyB3aWxsIGJlIHNwZW50XFxyXFxucHJvY2Vzc2luZyBhIG1lc3NhZ2UsIGxlYXZpbmcgMjAwbXMgZm9yIHRoZSBzZW5kaW5nIGFuIGFjayBiYWNrIHRvXFxyXFxuUmFiYml0IGFuZCByZWNlaXZpbmcgdGhlIG5leHQgbWVzc2FnZS4gVGh1cyB3ZSBjYW4gbm93IGNvcGUgd2l0aCB0aGVcXHJcXG5uZXR3b3JrIGhhbHZpbmcgaW4gc3BlZWQuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJCdXQgaWYgdGhlIG5ldHdvcmsncyBwZXJmb3JtaW5nIG5vcm1hbGx5LCBkb3VibGluZyBvdXIgUW9TIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwicHJlZmV0Y2hcIlxuICAgICAgfSksIFwiXFxyXFxubm93IG1lYW5zIGVhY2ggbWVzc2FnZSB3aWxsIHNpdCBpbiB0aGUgY2xpZW50IHNpZGUgYnVmZmVyIGZvciBhIHdoaWxlLFxcclxcbmluc3RlYWQgb2YgYmVpbmcgcHJvY2Vzc2VkIGltbWVkaWF0ZWx5IHVwb24gYXJyaXZhbCBhdCB0aGVcXHJcXG5jbGllbnQuIEFnYWluLCBzdGFydGluZyBmcm9tIGEgZnVsbCBidWZmZXIgb2Ygbm93IDUxIG1lc3NhZ2VzIHdlIGtub3dcXHJcXG50aGF0IG5ldyBtZXNzYWdlcyB3aWxsIHN0YXJ0IGFwcGVhcmluZyBhdCB0aGUgY2xpZW50IDEwMG1zIGFmdGVyIHRoZVxcclxcbmNsaWVudCBmaW5pc2hlcyBwcm9jZXNzaW5nIHRoZSBmaXJzdCBtZXNzYWdlLiBCdXQgaW4gdGhvc2UgMTAwbXMsIHRoZVxcclxcbmNsaWVudCB3aWxsIGhhdmUgcHJvY2Vzc2VkIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiMTAwIC8gNCA9IDI1XCJcbiAgICAgIH0pLCBcIiBtZXNzYWdlcyBvdXQgb2YgdGhlIDUwXFxyXFxuYXZhaWxhYmxlLiBXaGljaCBtZWFucyBhcyBhIG5ldyBtZXNzYWdlIGFycml2ZXMgYXQgdGhlIGNsaWVudCwgaXQnbGxcXHJcXG5iZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIgYXMgdGhlIGNsaWVudCByZW1vdmVzIGZyb20gdGhlIGhlYWRcXHJcXG5vZiB0aGUgYnVmZmVyLiBUaGUgYnVmZmVyIHdpbGwgdGh1cyBhbHdheXMgc3RheSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIjUwIC0gMjUgPSAyNVwiXG4gICAgICB9KSwgXCJcXHJcXG5tZXNzYWdlcyBsb25nIGFuZCBldmVyeSBtZXNzYWdlIHdpbGwgdGh1cyBzaXQgaW4gdGhlIGJ1ZmZlciBmb3IgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCIyNSAqIDQgPSAxMDBtc1wiXG4gICAgICB9KSwgXCIsIGluY3JlYXNpbmcgdGhlIGxhdGVuY3kgYmV0d2VlbiBSYWJiaXQgc2VuZGluZyBpdCB0byB0aGVcXHJcXG5jbGllbnQgYW5kIHRoZSBjbGllbnQgc3RhcnRpbmcgdG8gcHJvY2VzcyBpdCBmcm9tIDUwbXMgdG8gMTUwbXMuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJUaHVzIHdlIHNlZSB0aGF0IGluY3JlYXNpbmcgdGhlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwicHJlZmV0Y2hcIlxuICAgICAgfSksIFwiIGJ1ZmZlciBzbyB0aGF0IHRoZSBjbGllbnRcXHJcXG5jYW4gY29wZSB3aXRoIGRldGVyaW9yYXRlZCBuZXR3b3JrIHBlcmZvcm1hbmNlIHdoaWxzdCBrZWVwaW5nIHRoZVxcclxcbmNsaWVudCBidXN5LCBzdWJzdGFudGlhbGx5IGluY3JlYXNlcyB0aGUgbGF0ZW5jeSB3aGVuIHRoZSBuZXR3b3JrIGlzXFxyXFxucGVyZm9ybWluZyBub3JtYWxseS5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIkVxdWFsbHksIHJhdGhlciB0aGFuIHRoZSBuZXR3b3JrJ3MgcGVyZm9ybWFuY2UgZGV0ZXJpb3JhdGluZywgd2hhdFxcclxcbmhhcHBlbnMgaWYgdGhlIGNsaWVudCBzdGFydHMgdGFraW5nIDQwbXMgdG8gcHJvY2VzcyBlYWNoIG1lc3NhZ2VcXHJcXG5yYXRoZXIgdGhhbiA0bXM/IElmIHRoZSBxdWV1ZSBpbiBSYWJiaXQgd2FzIHByZXZpb3VzbHkgYXQgYSBzdGVhZHlcXHJcXG5sZW5ndGggKGkuZS4gaW5ncmVzcyBhbmQgZWdyZXNzIHJhdGVzIHdlcmUgdGhlIHNhbWUpLCBpdCdsbCBub3cgc3RhcnRcXHJcXG5ncm93aW5nIHJhcGlkbHksIGFzIHRoZSBlZ3Jlc3MgcmF0ZSBoYXMgZHJvcHBlZCB0byBhIHRlbnRoIG9mIHdoYXQgaXRcXHJcXG53YXMuIFlvdSBtaWdodCBkZWNpZGUgdG8gdHJ5IGFuZCB3b3JrIHRocm91Z2ggdGhpcyBncm93aW5nIGJhY2tsb2cgYnlcXHJcXG5hZGRpbmcgbW9yZSBjb25zdW1lcnMsIGJ1dCB0aGVyZSBhcmUgbWVzc2FnZXMgbm93IGJlaW5nIGJ1ZmZlcmVkIGJ5XFxyXFxudGhlIGV4aXN0aW5nIGNsaWVudHMuIEFzc3VtaW5nIHRoZSBvcmlnaW5hbCBidWZmZXIgc2l6ZSBvZiAyNlxcclxcbm1lc3NhZ2VzLCB0aGUgY2xpZW50IHdpbGwgc3BlbmQgNDBtcyBwcm9jZXNzaW5nIHRoZSBmaXJzdCBtZXNzYWdlLFxcclxcbndpbGwgdGhlbiBzZW5kIHRoZSBhY2sgYmFjayB0byBSYWJiaXQgYW5kIG1vdmUgb250byB0aGUgbmV4dFxcclxcbm1lc3NhZ2UuIFRoZSBhY2sgc3RpbGwgdGFrZXMgNTBtcyB0byBnZXQgdG8gUmFiYml0IGFuZCBhIGZ1cnRoZXIgNTBtc1xcclxcbmZvciBSYWJiaXQgdG8gc2VuZCBvdXQgYSBuZXcgbWVzc2FnZSwgYnV0IGluIHRoYXQgMTAwbXMsIHRoZSBjbGllbnRcXHJcXG5oYXMgb25seSB3b3JrZWQgdGhyb3VnaCBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIjEwMCAvIDQwID0gMi41XCJcbiAgICAgIH0pLCBcIiBmdXJ0aGVyIG1lc3NhZ2VzIHJhdGhlciB0aGFuXFxyXFxudGhlIHJlbWFpbmluZyAyNSBtZXNzYWdlcy4gVGh1cyB0aGUgYnVmZmVyIGlzIGF0IHRoaXMgcG9pbnQgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCIyNSAtIDMgPSAyMlwiXG4gICAgICB9KSwgXCIgbWVzc2FnZXMgbG9uZy4gVGhlIG5ldyBtZXNzYWdlIGFycml2aW5nIGZyb20gUmFiYml0LCByYXRoZXIgdGhhblxcclxcbmJlaW5nIHByb2Nlc3NlZCBpbW1lZGlhdGVseSwgbm93IHNpdHMgaW4gMjNyZCBwbGFjZSwgYmVoaW5kIDIyIG90aGVyXFxyXFxubWVzc2FnZXMgc3RpbGwgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQsIGFuZCB3aWxsIG5vdCBiZSB0b3VjaGVkIGJ5IHRoZVxcclxcbmNsaWVudCBmb3IgYSBmdXJ0aGVyIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiMjIgKiA0MCA9IDg4MG1zXCJcbiAgICAgIH0pLCBcIi4gR2l2ZW4gdGhlIG5ldHdvcmsgZGVsYXkgZnJvbVxcclxcblJhYmJpdCB0byB0aGUgY2xpZW50IGlzIG9ubHkgNTBtcywgdGhpcyBhZGRpdGlvbmFsIDg4MG1zIGRlbGF5IGlzIG5vd1xcclxcbjk1JSBvZiB0aGUgbGF0ZW5jeSAoXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCI4ODAgLyAoODgwICsgNTApID0gMC45NDZcIlxuICAgICAgfSksIFwiKS5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIkV2ZW4gd29yc2UsIHdoYXQgaGFwcGVucyBpZiB3ZSBkb3VibGVkIHRoZSBidWZmZXIgc2l6ZSB0byA1MSBtZXNzYWdlc1xcclxcbmluIG9yZGVyIHRvIGNvcGUgd2l0aCBuZXR3b3JrIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uPyBBZnRlciB0aGUgZmlyc3RcXHJcXG5tZXNzYWdlIGhhcyBiZWVuIHByb2Nlc3NlZCwgdGhlcmUgd2lsbCBiZSA1MCBmdXJ0aGVyIG1lc3NhZ2VzIGJ1ZmZlcmVkXFxyXFxuaW4gdGhlIGNsaWVudC4gMTAwbXMgbGF0ZXIgKGFzc3VtaW5nIHRoZSBuZXR3b3JrIGlzIHJ1bm5pbmcgbm9ybWFsbHkpLFxcclxcbmEgbmV3IG1lc3NhZ2Ugd2lsbCBhcnJpdmUgZnJvbSBSYWJiaXQsIGFuZCB0aGUgY2xpZW50IHdpbGwgYmUgaGFsZiB3YXlcXHJcXG50aHJvdWdoIHByb2Nlc3NpbmcgdGhlIDNyZCBvZiB0aG9zZSA1MCBtZXNzYWdlcyAodGhlIGJ1ZmZlciB3aWxsIG5vd1xcclxcbmJlIDQ3IG1lc3NhZ2VzIGxvbmcpLCB0aHVzIHRoZSBuZXcgbWVzc2FnZSB3aWxsIGJlIDQ4dGggaW4gdGhlIGJ1ZmZlcixcXHJcXG5hbmQgd2lsbCBub3QgYmUgdG91Y2hlZCBmb3IgYSBmdXJ0aGVyIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiNDcgKiA0MCA9IDE4ODBtc1wiXG4gICAgICB9KSwgXCIuIEFnYWluLCBnaXZlblxcclxcbnRoZSBuZXR3b3JrIGRlbGF5IG9mIGdldHRpbmcgdGhlIG1lc3NhZ2UgdG8gdGhlIGNsaWVudCBpcyBvbmx5IDUwbXMsXFxyXFxudGhpcyBmdXJ0aGVyIDE4ODBtcyBkZWxheSBub3cgbWVhbnMgY2xpZW50IHNpZGUgYnVmZmVyaW5nIGlzXFxyXFxucmVzcG9uc2libGUgZm9yIG92ZXIgOTclIG9mIHRoZSBsYXRlbmN5IChcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIjE4ODAgLyAoMTg4MCArIDUwKSA9IDAuOTc0XCJcbiAgICAgIH0pLCBcIikuIFRoaXMgbWF5IHZlcnkgd2VsbCBiZSB1bmFjY2VwdGFibGU6IHRoZSBkYXRhIG1heSBvbmx5IGJlXFxyXFxudmFsaWQgYW5kIHVzZWZ1bCBpZiBpdCdzIHByb2Nlc3NlZCBwcm9tcHRseSwgbm90IHNvbWUgMiBzZWNvbmRzIGFmdGVyXFxyXFxudGhlIGNsaWVudCByZWNlaXZlZCBpdCEgSWYgb3RoZXIgY29uc3VtaW5nIGNsaWVudHMgYXJlIGlkbGUsIHRoZXJlJ3NcXHJcXG5ub3RoaW5nIHRoZXkgY2FuIGRvOiBvbmNlIFJhYmJpdCBoYXMgc2VudCBhIG1lc3NhZ2UgdG8gYSBjbGllbnQsIHRoZVxcclxcbm1lc3NhZ2UgaXMgdGhlIGNsaWVudCdzIHJlc3BvbnNpYmlsaXR5IHVudGlsIGl0IGFja3Mgb3IgcmVqZWN0cyB0aGVcXHJcXG5tZXNzYWdlLiBDbGllbnRzIGNhbid0IHN0ZWFsIG1lc3NhZ2VzIGZyb20gZWFjaCBvdGhlciBvbmNlIHRoZSBtZXNzYWdlXFxyXFxuaGFzIGJlZW4gc2VudCB0byBhIGNsaWVudC4gV2hhdCB5b3Ugd2FudCBpcyBmb3IgY2xpZW50cyB0byBiZSBrZXB0XFxyXFxuYnVzeSwgYnV0IGZvciBjbGllbnRzIHRvIGJ1ZmZlciBhcyBmZXcgbWVzc2FnZXMgYXMgcG9zc2libGUgc28gdGhhdFxcclxcbm1lc3NhZ2VzIGFyZSBub3QgZGVsYXllZCBieSBjbGllbnQtc2lkZSBidWZmZXJzIGFuZCB0aHVzIG5ldyBjb25zdW1pbmdcXHJcXG5jbGllbnRzIGNhbiBiZSBxdWlja2x5IGZlZCB3aXRoIG1lc3NhZ2VzIGZyb20gUmFiYml0J3MgcXVldWUuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJTbywgdG9vIHNtYWxsIGEgYnVmZmVyIHJlc3VsdHMgaW4gY2xpZW50cyBnb2luZyBpZGxlIGlmIHRoZSBuZXR3b3JrXFxyXFxuZ2V0cyBzbG93ZXIsIGJ1dCB0b28gYmlnIGEgYnVmZmVyIHJlc3VsdHMgaW4gbG90cyBvZiBleHRyYSBsYXRlbmN5IGlmXFxyXFxudGhlIG5ldHdvcmsgcGVyZm9ybXMgbm9ybWFsbHksIGFuZCBodWdlIGFtb3VudHMgb2YgZXh0cmEgbGF0ZW5jeSBpZlxcclxcbnRoZSBjbGllbnQgc3VkZGVubHkgc3RhcnRzIHRha2luZyBsb25nZXIgdG8gcHJvY2VzcyBlYWNoIG1lc3NhZ2UgdGhhblxcclxcbm5vcm1hbC4gSXQncyBjbGVhciB0aGF0IHdoYXQgeW91IHJlYWxseSB3YW50IGlzIGEgdmFyeWluZyBidWZmZXJcXHJcXG5zaXplLiBUaGVzZSBwcm9ibGVtcyBhcmUgY29tbW9uIGFjcm9zcyBuZXR3b3JrIGRldmljZXMgYW5kIGhhdmUgYmVlblxcclxcbnRoZSBzdWJqZWN0IG9mIG11Y2ggc3R1ZHkuIFwiLCBfanN4KF9jb21wb25lbnRzLmVtLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIkFjdGl2ZSBRdWV1ZSBNYW5hZ2VtZW50XCJcbiAgICAgIH0pLCBcIiBhbGdvcml0aG1zIHNlZWtcXHJcXG50byB0cnkgYW5kIGRyb3Agb3IgcmVqZWN0IG1lc3NhZ2VzIHNvIHRoYXQgeW91IGF2b2lkIG1lc3NhZ2VzIHNpdHRpbmdcXHJcXG5pbiBidWZmZXJzIGZvciBsb25nIHBlcmlvZHMgb2YgdGltZS4gVGhlIGxvd2VzdCBsYXRlbmN5IGlzIGFjaGlldmVkXFxyXFxud2hlbiB0aGUgYnVmZmVyIGlzIGtlcHQgZW1wdHkgKGVhY2ggbWVzc2FnZSBzdWZmZXJzIG5ldHdvcmsgbGF0ZW5jeVxcclxcbm9ubHkgYW5kIGRvZXMgbm90IHNpdCBhcm91bmQgaW4gYSBidWZmZXIgYXQgYWxsKSBhbmQgYnVmZmVycyBhcmUgdGhlcmVcXHJcXG50byBhYnNvcmIgc3Bpa2VzLiBcIiwgX2pzeChfY29tcG9uZW50cy5hLCB7XG4gICAgICAgIGhyZWY6IFwiaHR0cDovL2dldHR5cy53b3JkcHJlc3MuY29tL1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJKaW0gR2V0dHlzXCJcbiAgICAgIH0pLCBcIiBoYXMgYmVlblxcclxcbndvcmtpbmcgb24gdGhpcyBwcm9ibGVtIGZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgbmV0d29yayByb3V0ZXJzOlxcclxcbmRpZmZlcmVuY2VzIGJldHdlZW4gcGVyZm9ybWFuY2Ugb2YgdGhlIExBTiBhbmQgdGhlIFdBTiBzdWZmZXIgZXhhY3RseVxcclxcbnRoZSBzYW1lIHNvcnRzIG9mIHByb2JsZW1zLiBJbmRlZWQgd2hlbmV2ZXIgeW91IGhhdmUgYSBidWZmZXIgYmV0d2VlblxcclxcbmEgcHJvZHVjZXIgKGluIG91ciBjYXNlIFJhYmJpdCkgYW5kIGEgY29uc3VtZXIgKHRoZSBjbGllbnQtc2lkZVxcclxcbmFwcGxpY2F0aW9uIGxvZ2ljKSB3aGVyZSB0aGUgcGVyZm9ybWFuY2Ugb2YgYm90aCBzaWRlcyBjYW4gdmFyeVxcclxcbmR5bmFtaWNhbGx5LCB5b3Ugd2lsbCBzdWZmZXIgdGhlc2Ugc29ydHMgb2YgcHJvYmxlbXMuIFJlY2VudGx5IGEgbmV3XFxyXFxuYWxnb3JpdGhtIGNhbGxlZFxcclxcblwiLCBfanN4KF9jb21wb25lbnRzLmEsIHtcbiAgICAgICAgaHJlZjogXCJodHRwczovL3F1ZXVlLmFjbS5vcmcvZGV0YWlsLmNmbT9pZD0yMjA5MzM2XCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNvbnRyb2xsZWQgRGVsYXlcIlxuICAgICAgfSksIFwiIGhhc1xcclxcbmJlZW4gcHVibGlzaGVkIHdoaWNoXFxyXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuYSwge1xuICAgICAgICBocmVmOiBcImh0dHA6Ly9hcnN0ZWNobmljYS5jb20vaW5mb3JtYXRpb24tdGVjaG5vbG9neS8yMDEyLzA1L2NvZGVsLWJ1ZmZlci1tYW5hZ2VtZW50LWNvdWxkLXNvbHZlLXRoZS1pbnRlcm5ldHMtYnVmZmVyYmxvYXQtamFtcy9cIixcbiAgICAgICAgY2hpbGRyZW46IFwiYXBwZWFycyB0byB3b3JrIHdlbGxcIlxuICAgICAgfSksIFwiXFxyXFxuaW4gc29sdmluZyB0aGVzZSBwcm9ibGVtcy5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIlRoZSBhdXRob3JzIGNsYWltIHRoYXQgdGhlaXIgXCIsIF9qc3goX2NvbXBvbmVudHMuZW0sIHtcbiAgICAgICAgY2hpbGRyZW46IFwiQ29EZWxcIlxuICAgICAgfSksIFwiIChcXFwiY29kZGxlXFxcIikgYWxnb3JpdGhtIGlzIGEgXFxcImtub2JcXHJcXG5mcmVlXFxcIiBhbGdvcml0aG0uIFRoaXMgaXMgYSBiaXQgb2YgYSBsaWUgcmVhbGx5OiB0aGVyZSBhcmUgdHdvIGtub2JzXFxyXFxuYW5kIHRoZXkgZG8gbmVlZCBzZXR0aW5nIGFwcHJvcHJpYXRlbHkuIEJ1dCB0aGV5IGRvbid0IG5lZWQgY2hhbmdpbmdcXHJcXG5ldmVyeSB0aW1lIHBlcmZvcm1hbmNlIGNoYW5nZXMsIHdoaWNoIGlzIGEgbWFzc2l2ZSBiZW5lZml0LiBJIGhhdmVcXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5hLCB7XG4gICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMjY1ODcxMlwiLFxuICAgICAgICBjaGlsZHJlbjogXCJpbXBsZW1lbnRlZCB0aGlzIGFsZ29yaXRobVwiXG4gICAgICB9KSwgXCIgZm9yIG91clxcclxcbkFNUVAgSmF2YSBDbGllbnQgYXMgYSB2YXJpYW50IG9mIHRoZSBRdWV1ZWluZ0NvbnN1bWVyLiBXaGlsc3QgdGhlXFxyXFxub3JpZ2luYWwgYWxnb3JpdGhtIGlzIGFpbWVkIGF0IHRoZSBUQ1AgbGF5ZXIsIHdoZXJlIGl0J3MgdmFsaWQgdG8ganVzdFxcclxcbmRyb3AgcGFja2V0cyAoVENQIGl0c2VsZiB3aWxsIHRha2UgY2FyZVxcclxcbm9mIHJlLXRyYW5zbWlzc2lvbiBvZiBsb3N0IHBhY2tldHMpLCBpbiBBTVFQIHRoYXQncyBub3Qgc28gcG9saXRlISBBcyBhIHJlc3VsdCxcXHJcXG5teSBpbXBsZW1lbnRhdGlvbiB1c2VzIFJhYmJpdCdzIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiYmFzaWMubmFja1wiXG4gICAgICB9KSwgXCIgZXh0ZW5zaW9uIHRvIGV4cGxpY2l0bHlcXHJcXG5yZXR1cm4gbWVzc2FnZXMgdG8gdGhlIHF1ZXVlIHNvIHRoZXkgY2FuIGJlIHByb2Nlc3NlZCBieSBvdGhlcnMuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5hLCB7XG4gICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMjY1ODcyN1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJVc2luZyBpdCBpcyBwcmV0dHkgbXVjaCB0aGUgc2FtZVwiXG4gICAgICB9KSwgXCIgYXNcXHJcXG50aGUgbm9ybWFsIFF1ZXVlaW5nQ29uc3VtZXIgZXhjZXB0IHRoYXQgeW91IHNob3VsZCBwcm92aWRlIHRocmVlIGV4dHJhXFxyXFxucGFyYW1ldGVycyB0byB0aGUgY29uc3RydWN0b3IgdG8gZ2V0IHRoZSBiZXN0IHBlcmZvcm1hbmNlLlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5vbCwge1xuICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW1wiVGhlIGZpcnN0IGlzIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJyZXF1ZXVlXCJcbiAgICAgICAgfSksIFwiIHdoaWNoIHNheXMgd2hldGhlciwgd2hlbiBtZXNzYWdlcyBhcmVcXHJcXG5uYWNrZWQsIHNob3VsZCB0aGV5IGJlIHJlcXVldWVkIG9yIGRpc2NhcmRlZC4gSWYgZmFsc2UsIHRoZXkgd2lsbFxcclxcbmJlIGRpc2NhcmRlZCB3aGljaCBtYXkgdHJpZ2dlciB0aGUgZGVhZCBsZXR0ZXIgZXhjaGFuZ2UgbWVjaGFuaXNtc1xcclxcbmlmIHRoZXkncmUgc2V0IHVwLlwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJUaGUgc2Vjb25kIGlzIHRoZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwidGFyZ2V0RGVsYXlcIlxuICAgICAgICB9KSwgXCIgd2hpY2ggaXMgdGhlIGFjY2VwdGFibGUgdGltZSBpblxcclxcbm1pbGxpc2Vjb25kcyBmb3IgbWVzc2FnZXMgdG8gd2FpdCBpbiB0aGUgY2xpZW50LXNpZGUgUW9TIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJwcmVmZXRjaFwiXG4gICAgICAgIH0pLCBcIlxcclxcbmJ1ZmZlci5cIl1cbiAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW1wiVGhlIHRoaXJkIGlzIHRoZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiaW50ZXJ2YWxcIlxuICAgICAgICB9KSwgXCIgYW5kIGlzIHRoZSBleHBlY3RlZCB3b3JzdCBjYXNlXFxyXFxucHJvY2Vzc2luZyB0aW1lIG9mIG9uZSBtZXNzYWdlIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBkb2Vzbid0IGhhdmVcXHJcXG50byBiZSBzcG90IG9uLCBidXQgd2l0aGluIGFuIG9yZGVyIG9mIG1hZ25pdHVkZSBjZXJ0YWlubHkgaGVscHMuXCJdXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIllvdSBzaG91bGQgc3RpbGwgc2V0IGEgUW9TIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwicHJlZmV0Y2hcIlxuICAgICAgfSksIFwiIHNpemUgYXBwcm9wcmlhdGVseS4gSWYgeW91IGRvXFxyXFxubm90LCB3aGF0IGlzIGxpa2VseSBpcyB0aGF0IHRoZSBjbGllbnQgd2lsbCBiZSBzZW50IGEgbG90IG9mIG1lc3NhZ2VzLFxcclxcbmFuZCB0aGUgYWxnb3JpdGhtIHdpbGwgdGhlbiBoYXZlIHRvIHJldHVybiB0aGVtIHRvIFJhYmJpdCBpZiB0aGV5IHNpdFxcclxcbmluIHRoZSBidWZmZXIgZm9yIHRvbyBsb25nLiBJdCdzIGVhc3kgdG8gZW5kIHVwIHdpdGggYSBsb3Qgb2YgZXh0cmFcXHJcXG5uZXR3b3JrIHRyYWZmaWMgYXMgbWVzc2FnZXMgYXJlIHJldHVybmVkIHRvIFJhYmJpdC4gVGhlIENvRGVsXFxyXFxuYWxnb3JpdGhtIGlzIG1lYW50IHRvIG9ubHkgc3RhcnQgZHJvcHBpbmcgKG9yIHJlamVjdGluZykgbWVzc2FnZXMgb25jZVxcclxcbnBlcmZvcm1hbmNlIGRpdmVyZ2VzIGZyb20gdGhlIG5vcm0sIHRodXMgYSB3b3JrZWQgZXhhbXBsZSBtaWdodCBoZWxwLlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiQWdhaW4sIGFzc3VtZSBuZXR3b3JrIHRyYXZlcnNhbCB0aW1lIGluIGVhY2ggZGlyZWN0aW9uIG9mIDUwbXMsIGFuZCB3ZVxcclxcbmV4cGVjdCB0aGUgY2xpZW50IHRvIHNwZW5kIDRtcyBvbiBhdmVyYWdlIHByb2Nlc3NpbmcgZWFjaCBtZXNzYWdlLCBidXRcXHJcXG50aGlzIGNhbiBzcGlrZSB0byAyMG1zLiBXZSB0aHVzIHNldCB0aGUgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJpbnRlcnZhbFwiXG4gICAgICB9KSwgXCIgcGFyYW1ldGVyIG9mIENvRGVsXFxyXFxudG8gMjAuIFNvbWV0aW1lcyB0aGUgbmV0d29yayBoYWx2ZXMgaW4gc3BlZWQsIHNvIHRoZSB0cmF2ZXJzYWwgdGltZVxcclxcbmNhbiBiZSAxMDBtcyBpbiBlYWNoIGRpcmVjdGlvbi4gVG8gY2F0ZXIgZm9yIHRoYXQsIHdlIHNldCB0aGVcXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImJhc2ljLnFvcyBwcmVmZXRjaFwiXG4gICAgICB9KSwgXCIgdG8gXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCIyMDQgLyA0ID0gNTFcIlxuICAgICAgfSksIFwiLiBZZXMsIHRoaXMgbWVhbnMgdGhhdCB0aGVcXHJcXG5idWZmZXIgd2lsbCByZW1haW4gMjUgbWVzc2FnZXMgbG9uZyBtb3N0IG9mIHRoZSB0aW1lIHdoZW4gdGhlIG5ldHdvcmtcXHJcXG5pcyBydW5uaW5nIG5vcm1hbGx5IChzZWUgd29ya2luZ3MgZWFybGllciksIGJ1dCB3ZSBkZWNpZGUgdGhhdCdzXFxyXFxuT0suIEVhY2ggbWVzc2FnZSB3aWxsIHRodXMgc2l0IGluIHRoZSBidWZmZXIgZm9yIGFuIGV4cGVjdGVkIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiMjUgKiA0ID0gMTAwbXNcIlxuICAgICAgfSksIFwiLCBzbyB3ZSBzZXQgdGhlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwidGFyZ2V0RGVsYXlcIlxuICAgICAgfSksIFwiIG9mIENvRGVsIHRvIDEwMC5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJXaGVuIHRoaW5ncyBhcmUgcnVubmluZyBub3JtYWxseSwgQ29EZWwgc2hvdWxkIG5vdCBnZXQgaW4gdGhlIHdheSwgYW5kXFxyXFxuZmV3IGlmIGFueSBtZXNzYWdlcyBzaG91bGQgYmUgYmVpbmcgbmFja2VkLiBCdXQgc2hvdWxkIHRoZSBjbGllbnRcXHJcXG5zdGFydCBwcm9jZXNzaW5nIG1lc3NhZ2VzIG1vcmUgc2xvd2x5IHRoYW4gbm9ybWFsLCBDb0RlbCB3aWxsIHNwb3RcXHJcXG50aGF0IG1lc3NhZ2VzIGhhdmUgYmVlbiBidWZmZXJlZCBieSB0aGUgY2xpZW50IGZvciB0b28gbG9uZywgYW5kIHdpbGxcXHJcXG5yZXR1cm4gdGhvc2UgbWVzc2FnZXMgdG8gdGhlIHF1ZXVlLiBJZiB0aG9zZSBtZXNzYWdlcyBhcmUgcmVxdWV1ZWRcXHJcXG50aGVuIHRoZXkgd2lsbCBiZWNvbWUgYXZhaWxhYmxlIGZvciBkZWxpdmVyeSB0byBvdGhlciBjbGllbnRzLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBpcyB2ZXJ5IG11Y2ggZXhwZXJpbWVudGFsIGF0IHRoZSBtb21lbnQsIGFuZCBpdCdzIHBvc3NpYmxlIHRvIHNlZVxcclxcbnJlYXNvbnMgd2h5IENvRGVsIGlzbid0IGFzIGFwcHJvcHJpYXRlIGZvciBkZWFsaW5nIHdpdGggQU1RUCBtZXNzYWdlc1xcclxcbmFzIGl0IGlzIGZvciBwbGFpbiBJUC4gSXQncyBhbHNvIHdvcnRoIHJlbWVtYmVyaW5nIHRoYXQgcmVxdWV1aW5nXFxyXFxubWVzc2FnZXMgdmlhIG5hY2tzIGlzIGEgZmFpcmx5IGV4cGVuc2l2ZSBvcGVyYXRpb24sIHNvIGl0J3MgYSBnb29kXFxyXFxuaWRlYSB0byBzZXQgdGhlIHBhcmFtZXRlcnMgb2YgQ29EZWwgdG8gZW5zdXJlIGluIG5vcm1hbCBvcGVyYXRpb24gdmVyeVxcclxcbmZldyBpZiBhbnkgbWVzc2FnZXMgYXJlIGJlaW5nIG5hY2tlZC4gVGhlIG1hbmFnZW1lbnQgcGx1Z2luIGlzIGFuIGVhc3lcXHJcXG53YXkgdG8gaW5zcGVjdCBob3cgbWFueSBtZXNzYWdlcyBhcmUgYmVpbmcgbmFja2VkLiBBcyBldmVyLCBjb21tZW50cyxcXHJcXG5mZWVkYmFjayBhbmQgaW1wcm92ZW1lbnRzIGFyZSBtb3N0IHdlbGNvbWUhXCJcbiAgICB9KV1cbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzID0ge30pIHtcbiAgY29uc3Qge3dyYXBwZXI6IE1EWExheW91dH0gPSB7XG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gTURYTGF5b3V0ID8gX2pzeChNRFhMYXlvdXQsIHtcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogX2pzeChfY3JlYXRlTWR4Q29udGVudCwge1xuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICB9KSA6IF9jcmVhdGVNZHhDb250ZW50KHByb3BzKTtcbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./blog/2012-05-11-some-queuing-theory-throughput-latency-and-bandwidth/index.md\n");

/***/ }),

/***/ "./node_modules/@mdx-js/react/lib/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MDXProvider: () => (/* binding */ MDXProvider),\n/* harmony export */   useMDXComponents: () => (/* binding */ useMDXComponents)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/**\n * @import {MDXComponents} from 'mdx/types.js'\n * @import {Component, ReactElement, ReactNode} from 'react'\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\n\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nfunction useMDXComponents(components) {\n  const contextComponents = react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {ReactElement}\n *   Element.\n * @satisfies {Component}\n */\nfunction MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JhYmJpdG1xLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9saWIvaW5kZXguanM/MjA0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge01EWENvbXBvbmVudHN9IGZyb20gJ21keC90eXBlcy5qcydcbiAqIEBpbXBvcnQge0NvbXBvbmVudCwgUmVhY3RFbGVtZW50LCBSZWFjdE5vZGV9IGZyb20gJ3JlYWN0J1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIE1lcmdlQ29tcG9uZW50c1xuICogICBDdXN0b20gbWVyZ2UgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1JlYWRvbmx5PE1EWENvbXBvbmVudHM+fSBjdXJyZW50Q29tcG9uZW50c1xuICogICBDdXJyZW50IGNvbXBvbmVudHMgZnJvbSB0aGUgY29udGV4dC5cbiAqIEByZXR1cm5zIHtNRFhDb21wb25lbnRzfVxuICogICBBZGRpdGlvbmFsIGNvbXBvbmVudHMuXG4gKlxuICogQHR5cGVkZWYgUHJvcHNcbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgYE1EWFByb3ZpZGVyYC5cbiAqIEBwcm9wZXJ0eSB7UmVhY3ROb2RlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2NoaWxkcmVuXVxuICogICBDaGlsZHJlbiAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtSZWFkb25seTxNRFhDb21wb25lbnRzPiB8IE1lcmdlQ29tcG9uZW50cyB8IG51bGwgfCB1bmRlZmluZWR9IFtjb21wb25lbnRzXVxuICogICBBZGRpdGlvbmFsIGNvbXBvbmVudHMgdG8gdXNlIG9yIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZW0gKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtkaXNhYmxlUGFyZW50Q29udGV4dD1mYWxzZV1cbiAqICAgVHVybiBvZmYgb3V0ZXIgY29tcG9uZW50IGNvbnRleHQgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuLyoqIEB0eXBlIHtSZWFkb25seTxNRFhDb21wb25lbnRzPn0gKi9cbmNvbnN0IGVtcHR5Q29tcG9uZW50cyA9IHt9XG5cbmNvbnN0IE1EWENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGVtcHR5Q29tcG9uZW50cylcblxuLyoqXG4gKiBHZXQgY3VycmVudCBjb21wb25lbnRzIGZyb20gdGhlIE1EWCBDb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHk8TURYQ29tcG9uZW50cz4gfCBNZXJnZUNvbXBvbmVudHMgfCBudWxsIHwgdW5kZWZpbmVkfSBbY29tcG9uZW50c11cbiAqICAgQWRkaXRpb25hbCBjb21wb25lbnRzIHRvIHVzZSBvciBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVtIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7TURYQ29tcG9uZW50c31cbiAqICAgQ3VycmVudCBjb21wb25lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTURYQ29tcG9uZW50cyhjb21wb25lbnRzKSB7XG4gIGNvbnN0IGNvbnRleHRDb21wb25lbnRzID0gUmVhY3QudXNlQ29udGV4dChNRFhDb250ZXh0KVxuXG4gIC8vIE1lbW9pemUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgdG9wLWxldmVsIGNvbnRleHQgY2hhbmdlc1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDdXN0b20gbWVyZ2UgdmlhIGEgZnVuY3Rpb24gcHJvcFxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzKGNvbnRleHRDb21wb25lbnRzKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gey4uLmNvbnRleHRDb21wb25lbnRzLCAuLi5jb21wb25lbnRzfVxuICAgIH0sXG4gICAgW2NvbnRleHRDb21wb25lbnRzLCBjb21wb25lbnRzXVxuICApXG59XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIE1EWCBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHk8UHJvcHM+fSBwcm9wZXJ0aWVzXG4gKiAgIFByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7UmVhY3RFbGVtZW50fVxuICogICBFbGVtZW50LlxuICogQHNhdGlzZmllcyB7Q29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gTURYUHJvdmlkZXIocHJvcGVydGllcykge1xuICAvKiogQHR5cGUge1JlYWRvbmx5PE1EWENvbXBvbmVudHM+fSAqL1xuICBsZXQgYWxsQ29tcG9uZW50c1xuXG4gIGlmIChwcm9wZXJ0aWVzLmRpc2FibGVQYXJlbnRDb250ZXh0KSB7XG4gICAgYWxsQ29tcG9uZW50cyA9XG4gICAgICB0eXBlb2YgcHJvcGVydGllcy5jb21wb25lbnRzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcHJvcGVydGllcy5jb21wb25lbnRzKGVtcHR5Q29tcG9uZW50cylcbiAgICAgICAgOiBwcm9wZXJ0aWVzLmNvbXBvbmVudHMgfHwgZW1wdHlDb21wb25lbnRzXG4gIH0gZWxzZSB7XG4gICAgYWxsQ29tcG9uZW50cyA9IHVzZU1EWENvbXBvbmVudHMocHJvcGVydGllcy5jb21wb25lbnRzKVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgTURYQ29udGV4dC5Qcm92aWRlcixcbiAgICB7dmFsdWU6IGFsbENvbXBvbmVudHN9LFxuICAgIHByb3BlcnRpZXMuY2hpbGRyZW5cbiAgKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@mdx-js/react/lib/index.js\n");

/***/ }),

/***/ "./node_modules/url-loader/dist/cjs.js?limit=10000&name=assets/images/[name]-[contenthash].[ext]&fallback=/mnt/d/xy2401/codeDoc/rabbitmq-website/node_modules/file-loader/dist/cjs.js!./blog/2012-05-11-some-queuing-theory-throughput-latency-and-bandwidth/qos.svg":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"assets/images/qos-795ea277e045793fafb2110f19e34633.svg\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXJsLWxvYWRlci9kaXN0L2Nqcy5qcz9saW1pdD0xMDAwMCZuYW1lPWFzc2V0cy9pbWFnZXMvW25hbWVdLVtjb250ZW50aGFzaF0uW2V4dF0mZmFsbGJhY2s9L21udC9kL3h5MjQwMS9jb2RlRG9jL3JhYmJpdG1xLXdlYnNpdGUvbm9kZV9tb2R1bGVzL2ZpbGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYmxvZy8yMDEyLTA1LTExLXNvbWUtcXVldWluZy10aGVvcnktdGhyb3VnaHB1dC1sYXRlbmN5LWFuZC1iYW5kd2lkdGgvcW9zLnN2ZyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYWJiaXRtcS13ZWJzaXRlLy4vYmxvZy8yMDEyLTA1LTExLXNvbWUtcXVldWluZy10aGVvcnktdGhyb3VnaHB1dC1sYXRlbmN5LWFuZC1iYW5kd2lkdGgvcW9zLnN2Zz81MTRjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvaW1hZ2VzL3Fvcy03OTVlYTI3N2UwNDU3OTNmYWZiMjExMGYxOWUzNDYzMy5zdmdcIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/url-loader/dist/cjs.js?limit=10000&name=assets/images/[name]-[contenthash].[ext]&fallback=/mnt/d/xy2401/codeDoc/rabbitmq-website/node_modules/file-loader/dist/cjs.js!./blog/2012-05-11-some-queuing-theory-throughput-latency-and-bandwidth/qos.svg\n");

/***/ })

}]);