"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkrabbitmq_website"] = globalThis["webpackChunkrabbitmq_website"] || []).push([["content---rabbitmq-website-blog-2011-05-17-can-you-hear-the-drums-erlando-411-b19"],{

/***/ "./.docusaurus/docusaurus-plugin-content-blog/default/site-blog-2011-05-17-can-you-hear-the-drums-erlando-index-md-411.json":
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"permalink":"/rabbitmq-website/blog/2011/05/17/can-you-hear-the-drums-erlando","editUrl":"https://github.com/rabbitmq/rabbitmq-website/tree/main/blog/2011-05-17-can-you-hear-the-drums-erlando/index.md","source":"@site/blog/2011-05-17-can-you-hear-the-drums-erlando/index.md","title":"Can you hear the drums, Erlando?","description":"Most of us at RabbitMQ HQ have spend time working in a number of functional languages in addition to Erlang, such as Haskell, Scheme, Lisp, OCaml or others. Whilst there is lots to like about Erlang, such as its VM/Emulator, there are inevitably features that we all miss from other languages. In my case, having spent a couple of years working in Haskell before returning to the RabbitMQ fold, all sorts of features are \\"missing\\", such as laziness, type classes, additional infix operators, the ability to specify precedence of functions, fewer parenthesis, partial application, more consistent standard libraries and do-notation. That\'s a fair list, and it\'ll take me a while to get around to implementing them all in Erlang, but here are two for starters.","date":"2011-05-17T00:00:00.000Z","tags":[{"inline":true,"label":"Programming Languages","permalink":"/rabbitmq-website/blog/tags/programming-languages"}],"readingTime":15.1,"hasTruncateMarker":true,"authors":[{"name":"Matthew Sackman","key":"matthew","page":null}],"frontMatter":{"title":"Can you hear the drums, Erlando?","tags":["Programming Languages"],"authors":["matthew"]},"unlisted":false,"prevItem":{"title":"RabbitMQ 2.5.0 released","permalink":"/rabbitmq-website/blog/2011/06/16/rabbitmq-250-released"},"nextItem":{"title":"Very fast and scalable topic routing - part 2","permalink":"/rabbitmq-website/blog/2011/03/28/very-fast-and-scalable-topic-routing-part-2"}}');

/***/ }),

/***/ "./blog/2011-05-17-can-you-hear-the-drums-erlando/index.md":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assets: () => (/* binding */ assets),\n/* harmony export */   contentTitle: () => (/* binding */ contentTitle),\n/* harmony export */   \"default\": () => (/* binding */ MDXContent),\n/* harmony export */   frontMatter: () => (/* binding */ frontMatter),\n/* harmony export */   metadata: () => (/* reexport default export from named module */ _site_docusaurus_docusaurus_plugin_content_blog_default_site_blog_2011_05_17_can_you_hear_the_drums_erlando_index_md_411_json__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   toc: () => (/* binding */ toc)\n/* harmony export */ });\n/* harmony import */ var _site_docusaurus_docusaurus_plugin_content_blog_default_site_blog_2011_05_17_can_you_hear_the_drums_erlando_index_md_411_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./.docusaurus/docusaurus-plugin-content-blog/default/site-blog-2011-05-17-can-you-hear-the-drums-erlando-index-md-411.json\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var _mdx_js_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/@mdx-js/react/lib/index.js\");\n\n\nconst frontMatter = {\n\ttitle: 'Can you hear the drums, Erlando?',\n\ttags: [\n\t\t'Programming Languages'\n\t],\n\tauthors: [\n\t\t'matthew'\n\t]\n};\nconst contentTitle = undefined;\n\nconst assets = {\n\"authorsImageUrls\": [undefined],\n};\n\n\n\nconst toc = [{\n  \"value\": \"Introduction\",\n  \"id\": \"introduction\",\n  \"level\": 2\n}, {\n  \"value\": \"Use\",\n  \"id\": \"use\",\n  \"level\": 2\n}, {\n  \"value\": \"Cut\",\n  \"id\": \"cut\",\n  \"level\": 2\n}, {\n  \"value\": \"Motivation\",\n  \"id\": \"motivation\",\n  \"level\": 3\n}, {\n  \"value\": \"Definition\",\n  \"id\": \"definition\",\n  \"level\": 3\n}, {\n  \"value\": \"Tuples\",\n  \"id\": \"tuples\",\n  \"level\": 4\n}, {\n  \"value\": \"Lists\",\n  \"id\": \"lists\",\n  \"level\": 4\n}, {\n  \"value\": \"Records\",\n  \"id\": \"records\",\n  \"level\": 4\n}, {\n  \"value\": \"Case\",\n  \"id\": \"case\",\n  \"level\": 4\n}, {\n  \"value\": \"Do\",\n  \"id\": \"do\",\n  \"level\": 2\n}, {\n  \"value\": \"The Inevitable Monad Tutorial\",\n  \"id\": \"the-inevitable-monad-tutorial\",\n  \"level\": 3\n}, {\n  \"value\": \"The Mechanics of a Comma\",\n  \"id\": \"the-mechanics-of-a-comma\",\n  \"level\": 4\n}, {\n  \"value\": \"Lots of different types of Monads\",\n  \"id\": \"lots-of-different-types-of-monads\",\n  \"level\": 4\n}, {\n  \"value\": \"Monad Transformers\",\n  \"id\": \"monad-transformers\",\n  \"level\": 4\n}, {\n  \"value\": \"Beyond Monads\",\n  \"id\": \"beyond-monads\",\n  \"level\": 3\n}];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    em: \"em\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h4: \"h4\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"Most of us at RabbitMQ HQ have spend time working in a number of functional languages in addition to Erlang, such as Haskell, Scheme, Lisp, OCaml or others. Whilst there is lots to like about Erlang, such as its VM/Emulator, there are inevitably features that we all miss from other languages. In my case, having spent a couple of years working in Haskell before returning to the RabbitMQ fold, all sorts of features are \\\"missing\\\", such as laziness, type classes, additional infix operators, the ability to specify precedence of functions, fewer parenthesis, partial application, more consistent standard libraries and do-notation. That's a fair list, and it'll take me a while to get around to implementing them all in Erlang, but here are two for starters.\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h2, {\n      id: \"introduction\",\n      children: \"Introduction\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n        href: \"http://hg.rabbitmq.com/erlando/\",\n        children: \"Erlando\"\n      }), \" is a set of syntax extensions for Erlang. Currently it\\r\\nconsists of two syntax extensions, both of which take the form of\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n        href: \"http://www.erlang.org/doc/man/erl_id_trans.html\",\n        children: \"parse transformers\"\n      }), \".\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.strong, {\n          children: \"Cut\"\n        }), \": This adds support for cuts to Erlang. These are\\r\\ninspired by the\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n          href: \"http://srfi.schemers.org/srfi-26/srfi-26.html\",\n          children: \"Scheme form of cuts\"\n        }), \". Cuts\\r\\ncan be thought of as a light-weight form of abstraction, with\\r\\nsimilarities to partial application (or currying).\"]\n      }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li, {\n        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.strong, {\n          children: \"Do\"\n        }), \": This adds support for do-syntax and monads to\\r\\nErlang. These are heavily inspired by \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n          href: \"http://haskell.org\",\n          children: \"Haskell\"\n        }), \",\\r\\nand the monads and libraries are near-mechanical translations from\\r\\nthe Haskell GHC libraries.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h2, {\n      id: \"use\",\n      children: \"Use\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"To use any of these parse transformers, you must add the necessary\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"-compile\"\n      }), \" attributes to your Erlang source files. For example:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"-module(test).\\r\\n-compile({parse_transform, cut}).\\r\\n-compile({parse_transform, do}).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Then, when compiling \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"test.erl\"\n      }), \", you must ensure \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"erlc\"\n      }), \" can locate\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"cut.beam\"\n      }), \" and/or \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"do.beam\"\n      }), \" by passing the suitable path to \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"erlc\"\n      }), \" with a\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"-pa\"\n      }), \" or \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"-pz\"\n      }), \" argument. For example:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-shell\",\n        children: \"erlc -Wall +debug_info -I ./include -pa ebin -o ebin  src/cut.erl\\r\\nerlc -Wall +debug_info -I ./include -pa ebin -o ebin  src/do.erl\\r\\nerlc -Wall +debug_info -I ./include -pa test/ebin -pa ./ebin -o test/ebin test/src/test.erl\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Note, if you're using QLC, you may find you need to be careful as to\\r\\nthe order of the parse transforms: I've found that the\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"-compile({parse_transform, cut}).\"\n      }), \" must occur before the\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"-include_lib(\\\"stdlib/include/qlc.hrl\\\").\"\n      })]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h2, {\n      id: \"cut\",\n      children: \"Cut\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h3, {\n      id: \"motivation\",\n      children: \"Motivation\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Cut is motivated by the frequency with which simple abstractions (in a\\r\\nlambda-calculus sense) are used in Erlang, and the relatively noisy\\r\\nnature of declaring \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"fun\"\n      }), \"s. For example, it's quite common to see code\\r\\nlike:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"with_resource(Resource, Fun) ->\\r\\n    case lookup_resource(Resource) of\\r\\n        {ok, R}          -> Fun(R);\\r\\n        {error, _} = Err -> Err\\r\\n    end.\\r\\n\\r\\nmy_fun(A, B, C) ->\\r\\n    with_resource(A, fun (Resource) ->\\r\\n                            my_resource_modification(Resource, B, C)\\r\\n                        end).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"I.e. a fun is very simply created in order to perform variable capture\\r\\nfrom the its surrounding scope but to leave holes for further\\r\\narguments to be provided. Using a cut, the function \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"my_fun\"\n      }), \" can be\\r\\nrewritten as:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"my_fun(A, B, C) ->\\r\\n    with_resource(A, my_resource_modification(_, B, C)).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h3, {\n      id: \"definition\",\n      children: \"Definition\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Normally, the variable \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"_\"\n      }), \" can only occur in patterns: i.e. where\\r\\nmatch occurs. This can be in assignment, in cases, and in function\\r\\nheads. For example:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"{_, bar} = {foo, bar}.\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Cut uses \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"_\"\n      }), \" in expressions to indicate where abstraction should\\r\\noccur. Abstraction from cuts is \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.strong, {\n        children: \"always\"\n      }), \" performed on the\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"shallowest\"\n      }), \" enclosing expression. For example:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"list_to_binary([1, 2, math:pow(2, _)]).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"will create the expression\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"list_to_binary([1, 2, fun (X) -> math:pow(2, X) end]).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"and not\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"fun (X) -> list_to_binary([1, 2, math:pow(2, X)]) end.\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"It is fine to use multiple cuts in the same expression, and the\\r\\narguments to the created abstraction will match the order in which the\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"_\"\n      }), \" var is found in the expression. For example:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"assert_sum_3(X, Y, Z, Sum) when X + Y + Z == Sum -> ok;\\r\\nassert_sum_3(_X, _Y, _Z, _Sum) -> {error, not_sum}.\\r\\n\\r\\ntest() ->\\r\\n    Equals12 = assert_sum_3(_, _, _, 12),\\r\\n    ok = Equals12(9, 2, 1).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"It is perfectly legal to take cuts of cuts as the abstraction created\\r\\nby the cut is a normal \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"fun\"\n      }), \" expression and thus can be re-cut as\\r\\nnecessary:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"test() ->\\r\\n    Equals12 = assert_sum_3(_, _, _, 12),\\r\\n    Equals5 = Equals12(_, _, 7),\\r\\n    ok = Equals5(2, 3).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Note that because a simple \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"fun\"\n      }), \" is being constructed by the cut, the\\r\\narguments are evaluated prior to the cut function. For example:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"f1(_, _) -> io:format(\\\"in f1~n\\\").\\r\\n\\r\\ntest() ->\\r\\n    F = f1(io:format(\\\"test line 1~n\\\"), _),\\r\\n    F(io:format(\\\"test line 2~n\\\")).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"will print out\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-shell\",\n        children: \"test line 2\\r\\ntest line 1\\r\\nin f1\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"This is because the cut creates \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"fun (X) -> f1(io:format(\\\"test line 1~n\\\"), X) end\"\n      }), \". Thus it is clear that \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"X\"\n      }), \" must be evaluated first,\\r\\nbefore the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"fun\"\n      }), \" can be invoked.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"Of course, no one would be crazy enough to have side-effects in\\r\\nfunction argument expressions, so this will never cause any issues!\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"Cuts are not limited to function calls. They can be used in any\\r\\nexpression where they make sense:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h4, {\n      id: \"tuples\",\n      children: \"Tuples\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"F = {_, 3},\\r\\n{a, 3} = F(a).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h4, {\n      id: \"lists\",\n      children: \"Lists\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"dbl_cons(List) -> [_, _ | List].\\r\\n\\r\\ntest() ->\\r\\n    F = dbl_cons([33]),\\r\\n    [7, 8, 33] = F(7, 8).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"Note that if you nest a list as a list tail in Erlang, it's still\\r\\ntreated as one expression. For example:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"A = [a, b | [c, d | [e]]]\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"is exactly the same (right from the Erlang parser onwards) as:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"A = [a, b, c, d, e]\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"I.e. those sub-lists, when they're in the tail position \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.strong, {\n        children: \"do not\"\n      }), \"\\r\\nform sub-expressions. Thus:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"F = [1, _, _, [_], 5 | [6, [_] | [_]]],\\r\\n%% This is the same as:\\r\\n%%  [1, _, _, [_], 5, 6, [_], _]\\r\\n[1, 2, 3, G, 5, 6, H, 8] = F(2, 3, 8),\\r\\n[4] = G(4),\\r\\n[7] = H(7).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"However, be very clear about the difference between \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \",\"\n      }), \" and \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"|\"\n      }), \": the\\r\\ntail of a list is \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.strong, {\n        children: \"only\"\n      }), \" defined following a \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"|\"\n      }), \". Following a \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \",\"\n      }), \",\\r\\nyou're just defining another list element.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"F = [_, [_]],\\r\\n%% This is **not** the same as [_, _] or its synonym: [_ | [_]]\\r\\n[a, G] = F(a),\\r\\n[b] = G(b).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h4, {\n      id: \"records\",\n      children: \"Records\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"-record(vector, { x, y, z }).\\r\\n\\r\\ntest() ->\\r\\n    GetZ = _#vector.z,\\r\\n    7 = GetZ(#vector { z = 7 }),\\r\\n    SetX = _#vector{x = _},\\r\\n    V = #vector{ x = 5, y = 4 } = SetX(#vector{ y = 4 }, 5).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h4, {\n      id: \"case\",\n      children: \"Case\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"F = case _ of\\r\\n        N when is_integer(N) -> N + N;\\r\\n        N                    -> N\\r\\n    end,\\r\\n10 = F(5),\\r\\nok = F(ok).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"See\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n        href: \"http://hg.rabbitmq.com/erlando/file/default/test/src/test_cut.erl\",\n        children: \"test_cut.erl\"\n      }), \"\\r\\nfor more examples, including use of cuts in list comprehensions and\\r\\nbinary construction.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"Note that cuts are not allowed where the result of the cut can only be\\r\\nuseful by interacting with the evaluation scope. For example:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"F = begin _, _, _ end.\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"This is not allowed, because the arguments to \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"F\"\n      }), \" would have to be\\r\\nevaluated before the invocation of its body, which would then have no\\r\\neffect, as they're already fully evaluated by that point.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h2, {\n      id: \"do\",\n      children: \"Do\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"The Do parse transformer permits Haskell-style \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"do-notation\"\n      }), \" in\\r\\nErlang, which makes using monads, and monad transformers possible and\\r\\neasy. Without \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"do-notation\"\n      }), \", monads tend to look like a lot of line\\r\\nnoise.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h3, {\n      id: \"the-inevitable-monad-tutorial\",\n      children: \"The Inevitable Monad Tutorial\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h4, {\n      id: \"the-mechanics-of-a-comma\",\n      children: \"The Mechanics of a Comma\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"What follows is a brief and mechanical introduction to monads. It\\r\\ndiffers from a lot of the Haskell monad tutorials, because they tend\\r\\nto view monads as a means of achieving sequencing of operations in\\r\\nHaskell, which is challenging because Haskell is a lazy\\r\\nlanguage. Erlang is not a lazy language, but the powerful abstractions\\r\\npossible from using monads are still very worthwhile. Whilst this is a\\r\\nvery mechanical tutorial, it should be possible to see the more\\r\\nadvanced abstractions possible.\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"Let's say we have the three lines of code:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"A = foo(),\\r\\nB = bar(A, dog),\\r\\nok.\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"They are three, simple statements, which are evaluated\\r\\nconsecutively. What a monad gives you is control over what happens\\r\\nbetween the statements: in Erlang, it is a programmatic comma.\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"If you wanted to implement a programmatic comma, how would you do it?\\r\\nYou might start with something like:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"A = foo(),\\r\\ncomma(),\\r\\nB = bar(A, dog),\\r\\ncomma(),\\r\\nok.\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"But that's not quite powerful enough, because unless \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"comma/0\"\n      }), \" throws\\r\\nsome sort of exception, it can't actually stop the subsequent\\r\\nexpression from being evaluated. Most of the time we'd probably like\\r\\nthe \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"comma/0\"\n      }), \" function to be able to act on some variables which are\\r\\ncurrently in scope, and that's not possible here either. So we should\\r\\nextend the function \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"comma/0\"\n      }), \" so that it takes the result of the\\r\\npreceding expression, and can choose whether or not the subsequent\\r\\nexpressions should be evaluated:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"comma(foo(),\\r\\n        fun (A) -> comma(bar(A, dog),\\r\\n                        fun (B) -> ok end)).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Thus the function \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"comma/2\"\n      }), \" takes all results from the previous\\r\\nexpression, and controls how and whether they are passed to the next\\r\\nexpression.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"As defined, the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"comma/2\"\n      }), \" function is the monadic function \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>=/2\"\n      }), \".\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Now it's pretty difficult to read the program with the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"comma/2\"\n      }), \"\\r\\nfunction (especially as Erlang annoyingly doesn't allow us to define\\r\\nnew infix functions), which is why some special syntax is\\r\\nnecessary. Haskell has it's \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"do-notation\"\n      }), \", and so we've borrowed from\\r\\nthat and abused Erlang's list comprehensions. Haskell also has lovely\\r\\ntype-classes, which we've sort of faked specifically for monads. So,\\r\\nwith the Do parse transformer, you can write in Erlang:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"do([Monad ||\\r\\n    A <- foo(),\\r\\n    B <- bar(A, dog),\\r\\n    ok]).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"which is readable and straightforward, but is transformed into:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"Monad:'>>='(foo(),\\r\\n            fun (A) -> Monad:'>>='(bar(A, dog),\\r\\n                                    fun (B) -> ok end)).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"There is no intention that this latter form is any more readable than\\r\\nthe \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"comma/2\"\n      }), \" form - it is not. However, it should be clear that the\\r\\nfunction \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"Monad:'>>='/2\"\n      }), \" now has complete control over what happens:\\r\\ndoes the fun on the right hand side ever get invoked? If so, with what\\r\\nvalue?\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h4, {\n      id: \"lots-of-different-types-of-monads\",\n      children: \"Lots of different types of Monads\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"So now that we have some relatively nice syntax for using monads, what\\r\\ncan we do with them? Also, in the code\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"do([Monad ||\\r\\n    A <- foo(),\\r\\n    B <- bar(A, dog),\\r\\n    ok]).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"what are the possible values of \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"Monad\"\n      }), \"?\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"The answer to the first question is \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"almost anything\"\n      }), \"; and to the\\r\\nlater question, is \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"any module name that implements the monad\\r\\nbehaviour\"\n      }), \".\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Above, we covered one of the three monadic operators, \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>=/2\"\n      }), \". The\\r\\nothers are:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li, {\n        children: [\"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n            children: \"return/1\"\n          }), \": This \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n            children: \"lifts\"\n          }), \" a value into the monad. We'll see examples\\r\\nof this shortly.\"]\n        }), \"\\n\"]\n      }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li, {\n        children: [\"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n            children: \"fail/1\"\n          }), \": This takes a term describing the error encountered, and\\r\\ninforms whichever monad currently in use that some sort of error has\\r\\noccurred.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Note that within \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"do-notation\"\n      }), \", any function call to functions named\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"return\"\n      }), \" or \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"fail\"\n      }), \", are automatically rewritten to invoke \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"return\"\n      }), \" or\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"fail\"\n      }), \" within the current monad.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Some people familiar with Haskell's monads may be expecting to see a\\r\\nfourth operator, \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>/2\"\n      }), \". Interestingly, it turns out that you can't\\r\\nimplement \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>/2\"\n      }), \" in a strict language unless all your monad types are\\r\\nbuilt on top a function. This is because in a strict language,\\r\\narguments to functions are evaluated before the function is\\r\\ninvoked. For \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>=/2\"\n      }), \", the 2nd argument is only reduced to a function\\r\\nprior to invocation of \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>=/2\"\n      }), \". But the 2nd argument to \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>/2\"\n      }), \" is not\\r\\na function, and so in strict languages, will be fully reduced prior to\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>/2\"\n      }), \" being invoked. This is problematic because the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>/2\"\n      }), \" operator\\r\\nis meant to be in control of whether or not subsequent expressions are\\r\\nevaluated. The only solution here would be to make the basic monad\\r\\ntype a function, which would then mean that the 2nd argument to\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>=/2\"\n      }), \" would become a function to a function to a result! However, it\\r\\nis required that \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"'>>'(A, B)\"\n      }), \" behaves identically to \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"'>>='(A, fun (_) -> B end)\"\n      }), \", and so that is what we do: whenever we come to a\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"do([Monad || A, B ])\"\n      }), \", we rewrite it to \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"'>>='(A, fun (_) -> B end)\"\n      }), \"\\r\\nrather than \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"'>>'(A, B)\"\n      }), \". The effect of this is that the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>/2\"\n      }), \"\\r\\noperator does not exist.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"The simplest monad possible is the Identity-monad:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"-module(identity_m).\\r\\n-behaviour(monad).\\r\\n-export(['>>='/2, return/1, fail/1]).\\r\\n\\r\\n'>>='(X, Fun) -> Fun(X).\\r\\nreturn(X)     -> X.\\r\\nfail(X)       -> throw({error, X}).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"This makes our programmatic comma behave just like Erlang's comma\\r\\nnormally does. The \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.strong, {\n        children: \"bind\"\n      }), \" operator (\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \">>=/2\"\n      }), \") does not inspect the\\r\\nvalues passed to it, and always invokes the subsequent expression fun.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"What could we do if we did inspect the values passed to the sequencing\\r\\ncombinators? One possibility results in the Maybe-monad:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"-module(maybe_m).\\r\\n-behaviour(monad).\\r\\n-export(['>>='/2, return/1, fail/1]).\\r\\n\\r\\n'>>='({just, X}, Fun) -> Fun(X);\\r\\n'>>='(nothing,  _Fun) -> nothing.\\r\\n\\r\\nreturn(X) -> {just, X}.\\r\\nfail(_X)  -> nothing.\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Thus if the result of the preceding expression is \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"nothing\"\n      }), \", then the\\r\\nsubsequent expressions are not evaluated. This means that we can write\\r\\nvery neat looking code which immediately stops should any failure be\\r\\nencountered.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"if_safe_div_zero(X, Y, Fun) ->\\r\\n    do([maybe_m ||\\r\\n        Result <- case Y == 0 of\\r\\n                        true  -> fail(\\\"Cannot divide by zero\\\");\\r\\n                        false -> return(X / Y)\\r\\n                    end,\\r\\n        return(Fun(Result))]).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"If \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"Y\"\n      }), \" is equal to 0, then \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"Fun\"\n      }), \" will not be invoked, and the result\\r\\nof the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"if_safe_div_zero\"\n      }), \" function call will be \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"nothing\"\n      }), \". If \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"Y\"\n      }), \" is\\r\\nnot equal to 0, then the result of the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"if_safe_div_zero\"\n      }), \" function\\r\\ncall will be \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"{just, Fun(X / Y)}\"\n      }), \".\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"We see here that within the do-block, there is no mention of \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"nothing\"\n      }), \"\\r\\nor \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"just\"\n      }), \": they are abstracted away by the Maybe-monad. As a result,\\r\\nit is possible to change the monad in use, without having to rewrite\\r\\nany further code.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"One common place to use a monad like the Maybe-monad is where you'd\\r\\notherwise have a lot of nested case statements in order to detect\\r\\nerrors. For example:\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"write_file(Path, Data, Modes) ->\\r\\n    Modes1 = [binary, write | (Modes -- [binary, write])],\\r\\n    case make_binary(Data) of\\r\\n        Bin when is_binary(Bin) ->\\r\\n            case file:open(Path, Modes1) of\\r\\n                {ok, Hdl} ->\\r\\n                    case file:write(Hdl, Bin) of\\r\\n                        ok ->\\r\\n                            case file:sync(Hdl) of\\r\\n                                ok ->\\r\\n                                    file:close(Hdl);\\r\\n                                {error, _} = E ->\\r\\n                                    file:close(Hdl),\\r\\n                                    E\\r\\n                            end;\\r\\n                        {error, _} = E ->\\r\\n                            file:close(Hdl),\\r\\n                            E\\r\\n                    end;\\r\\n                {error, _} = E -> E\\r\\n            end;\\r\\n        {error, _} = E -> E\\r\\n    end.\\r\\n\\r\\nmake_binary(Bin) when is_binary(Bin) ->\\r\\n    Bin;\\r\\nmake_binary(List) ->\\r\\n    try\\r\\n        iolist_to_binary(List)\\r\\n    catch error:Reason ->\\r\\n            {error, Reason}\\r\\n    end.\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"can be transformed into the much shorter\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"write_file(Path, Data, Modes) ->\\r\\n    Modes1 = [binary, write | (Modes -- [binary, write])],\\r\\n    do([error_m ||\\r\\n        Bin <- make_binary(Data),\\r\\n        {ok, Hdl} <- file:open(Path, Modes1),\\r\\n        {ok, Result} <- return(do([error_m ||\\r\\n                                    ok <- file:write(Hdl, Bin),\\r\\n                                    file:sync(Hdl)])),\\r\\n        file:close(Hdl),\\r\\n        Result]).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Note that we have a nested do-block so that, as with the non-monadic\\r\\ncode, we ensure that once the file is opened, we always call\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"file:close/1\"\n      }), \" even if an error occurs in a subsequent operation. This\\r\\nis achieved by wrapping the nested do-block with a \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"return/1\"\n      }), \" call:\\r\\neven if the inner do-block errors, the error is \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"lifted\"\n      }), \" to a\\r\\nnon-error value in the outer do-block, and thus execution continues to\\r\\nthe subsequent \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"file:close/1\"\n      }), \" call.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Here we are using an Error-monad which is remarkably similar to the\\r\\nMaybe-monad, but matches the typical Erlang practice of indicating\\r\\nerrors by an \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"{error, Reason}\"\n      }), \" tuple:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"-module(error_m).\\r\\n-behaviour(monad).\\r\\n-export(['>>='/2, return/1, fail/1]).\\r\\n\\r\\n'>>='({error, _Err} = Error, _Fun) -> Error;\\r\\n'>>='(Result,                 Fun) -> Fun(Result).\\r\\n\\r\\nreturn(X) -> {ok,    X}.\\r\\nfail(X)   -> {error, X}.\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h4, {\n      id: \"monad-transformers\",\n      children: \"Monad Transformers\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Monads can be \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"nested\"\n      }), \" by having do-blocks inside do-blocks, and\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"parameterized\"\n      }), \" by defining a monad as a transformation of another, inner,\\r\\nmonad. The State Transform is a very commonly used monad transformer,\\r\\nand is especially relevant for Erlang. Because Erlang is a\\r\\nsingle-assignment language, it's very common to end up with a lot of\\r\\ncode that incrementally numbers variables:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"State1 = init(Dimensions),\\r\\nState2 = plant_seeds(SeedCount, State1),\\r\\n{DidFlood, State3} = pour_on_water(WaterVolume, State2),\\r\\nState4 = apply_sunlight(Time, State3),\\r\\n{DidFlood2, State5} = pour_on_water(WaterVolume, State4),\\r\\n{Crop, State6} = harvest(State5),\\r\\n    ...\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"This is doubly annoying, not only because it looks awful, but also\\r\\nbecause you have to re-number many variables and references whenever a\\r\\nline is added or removed. Wouldn't it be nice if we could abstract out the\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"State\"\n      }), \"? We could then have a monad encapsulate the state and provide\\r\\nit to (and collect it from) the functions we wish to run.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"Our implementation of monad-transformers (like State) uses a \\\"hidden feature\\\"\\r\\nof the Erlang distribution called \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"parameterized modules\"\n      }), \". These are\\r\\ndescribed in \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a, {\n        href: \"http://ftp.sunet.se/pub/lang/erlang/workshop/2003/paper/p29-carlsson.pdf\",\n        children: \"Parameterized Modules in Erlang\"\n      }), \".\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"The State-transform can be applied to any monad. If we apply it to the\\r\\nIdentity-monad then we get what we're looking for. The key extra\\r\\nfunctionality that the State transformer provides us with is the\\r\\nability to \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"get\"\n      }), \" and \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"set\"\n      }), \" (or just plain \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"modify\"\n      }), \") state from within\\r\\nthe inner monad. If we use both the Do and Cut parse transformers, we\\r\\ncan write:\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre, {\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        className: \"language-erlang\",\n        children: \"StateT = state_t:new(identity_m),\\r\\nSM = StateT:modify(_),\\r\\nSMR = StateT:modify_and_return(_),\\r\\nStateT:exec(\\r\\n    do([StateT ||\\r\\n\\r\\n        StateT:put(init(Dimensions)),\\r\\n        SM(plant_seeds(SeedCount, _)),\\r\\n        DidFlood <- SMR(pour_on_water(WaterVolume, _)),\\r\\n        SM(apply_sunlight(Time, _)),\\r\\n        DidFlood2 <- SMR(pour_on_water(WaterVolume, _)),\\r\\n        Crop <- SMR(harvest(_)),\\r\\n        ...\\r\\n\\r\\n        ]), undefined).\\n\"\n      })\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"We start by creating a State-transform over the Identity-monad.\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"This is the syntax for \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"instantiating\"\n      }), \" parameterized modules. \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"StateT\"\n      }), \" is a\\r\\nvariable referencing a module instance which, in this case, is a monad.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"We set up two shorthands for running functions that either just\\r\\nmodify the state, or modify the state \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"and\"\n      }), \" return a result. Whilst\\r\\nthere's a bit of bookkeeping to do, we achieve our goal: there are no\\r\\nstate variables now to renumber whenever we make a change: we use cut\\r\\nto leave holes in the functions where State should be fed in, and we\\r\\nobey the protocol that if functions return both a result and state, it\\r\\nshould be in the form of a \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"{Result, State}\"\n      }), \" tuple. The\\r\\nState-transform does the rest.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h3, {\n      id: \"beyond-monads\",\n      children: \"Beyond Monads\"\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p, {\n      children: [\"There are some standard monad functions such as \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"join/2\"\n      }), \" and\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"sequence/2\"\n      }), \" available in the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"monad\"\n      }), \" module. We have also implemented\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"monad_plus\"\n      }), \" which works for monads where there's an obvious sense of\\r\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"zero\"\n      }), \"  and \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.em, {\n        children: \"plus\"\n      }), \" (currently Maybe-monad, List-monad, and Omega-monad).\\r\\nThe associated functions \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"guard\"\n      }), \", \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"msum\"\n      }), \" and \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"mfilter\"\n      }), \" are available\\r\\nin the \", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code, {\n        children: \"monad_plus\"\n      }), \" module.\"]\n    }), \"\\n\", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p, {\n      children: \"In many cases, a fairly mechanical translation from Haskell to Erlang\\r\\nis possible, so in many cases converting other monads or combinators should\\r\\nbe straightforward. However, the lack of type classes in Erlang is limiting.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MDXLayout, {\n    ...props,\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ibG9nLzIwMTEtMDUtMTctY2FuLXlvdS1oZWFyLXRoZS1kcnVtcy1lcmxhbmRvL2luZGV4Lm1kIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JhYmJpdG1xLXdlYnNpdGUvLi9ibG9nLzIwMTEtMDUtMTctY2FuLXlvdS1oZWFyLXRoZS1kcnVtcy1lcmxhbmRvL2luZGV4Lm1kPzljOGIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbmV4cG9ydCBjb25zdCBmcm9udE1hdHRlciA9IHtcblx0dGl0bGU6ICdDYW4geW91IGhlYXIgdGhlIGRydW1zLCBFcmxhbmRvPycsXG5cdHRhZ3M6IFtcblx0XHQnUHJvZ3JhbW1pbmcgTGFuZ3VhZ2VzJ1xuXHRdLFxuXHRhdXRob3JzOiBbXG5cdFx0J21hdHRoZXcnXG5cdF1cbn07XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gdW5kZWZpbmVkO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1ldGFkYXRhfSBmcm9tICdAc2l0ZS8uZG9jdXNhdXJ1cy9kb2N1c2F1cnVzLXBsdWdpbi1jb250ZW50LWJsb2cvZGVmYXVsdC9zaXRlLWJsb2ctMjAxMS0wNS0xNy1jYW4teW91LWhlYXItdGhlLWRydW1zLWVybGFuZG8taW5kZXgtbWQtNDExLmpzb24nXG5leHBvcnQgY29uc3QgYXNzZXRzID0ge1xuXCJhdXRob3JzSW1hZ2VVcmxzXCI6IFt1bmRlZmluZWRdLFxufTtcblxuaW1wb3J0IHtGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7dXNlTURYQ29tcG9uZW50cyBhcyBfcHJvdmlkZUNvbXBvbmVudHN9IGZyb20gXCJAbWR4LWpzL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgdG9jID0gW3tcbiAgXCJ2YWx1ZVwiOiBcIkludHJvZHVjdGlvblwiLFxuICBcImlkXCI6IFwiaW50cm9kdWN0aW9uXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiVXNlXCIsXG4gIFwiaWRcIjogXCJ1c2VcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJDdXRcIixcbiAgXCJpZFwiOiBcImN1dFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIk1vdGl2YXRpb25cIixcbiAgXCJpZFwiOiBcIm1vdGl2YXRpb25cIixcbiAgXCJsZXZlbFwiOiAzXG59LCB7XG4gIFwidmFsdWVcIjogXCJEZWZpbml0aW9uXCIsXG4gIFwiaWRcIjogXCJkZWZpbml0aW9uXCIsXG4gIFwibGV2ZWxcIjogM1xufSwge1xuICBcInZhbHVlXCI6IFwiVHVwbGVzXCIsXG4gIFwiaWRcIjogXCJ0dXBsZXNcIixcbiAgXCJsZXZlbFwiOiA0XG59LCB7XG4gIFwidmFsdWVcIjogXCJMaXN0c1wiLFxuICBcImlkXCI6IFwibGlzdHNcIixcbiAgXCJsZXZlbFwiOiA0XG59LCB7XG4gIFwidmFsdWVcIjogXCJSZWNvcmRzXCIsXG4gIFwiaWRcIjogXCJyZWNvcmRzXCIsXG4gIFwibGV2ZWxcIjogNFxufSwge1xuICBcInZhbHVlXCI6IFwiQ2FzZVwiLFxuICBcImlkXCI6IFwiY2FzZVwiLFxuICBcImxldmVsXCI6IDRcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkRvXCIsXG4gIFwiaWRcIjogXCJkb1wiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIlRoZSBJbmV2aXRhYmxlIE1vbmFkIFR1dG9yaWFsXCIsXG4gIFwiaWRcIjogXCJ0aGUtaW5ldml0YWJsZS1tb25hZC10dXRvcmlhbFwiLFxuICBcImxldmVsXCI6IDNcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIlRoZSBNZWNoYW5pY3Mgb2YgYSBDb21tYVwiLFxuICBcImlkXCI6IFwidGhlLW1lY2hhbmljcy1vZi1hLWNvbW1hXCIsXG4gIFwibGV2ZWxcIjogNFxufSwge1xuICBcInZhbHVlXCI6IFwiTG90cyBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgTW9uYWRzXCIsXG4gIFwiaWRcIjogXCJsb3RzLW9mLWRpZmZlcmVudC10eXBlcy1vZi1tb25hZHNcIixcbiAgXCJsZXZlbFwiOiA0XG59LCB7XG4gIFwidmFsdWVcIjogXCJNb25hZCBUcmFuc2Zvcm1lcnNcIixcbiAgXCJpZFwiOiBcIm1vbmFkLXRyYW5zZm9ybWVyc1wiLFxuICBcImxldmVsXCI6IDRcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkJleW9uZCBNb25hZHNcIixcbiAgXCJpZFwiOiBcImJleW9uZC1tb25hZHNcIixcbiAgXCJsZXZlbFwiOiAzXG59XTtcbmZ1bmN0aW9uIF9jcmVhdGVNZHhDb250ZW50KHByb3BzKSB7XG4gIGNvbnN0IF9jb21wb25lbnRzID0ge1xuICAgIGE6IFwiYVwiLFxuICAgIGNvZGU6IFwiY29kZVwiLFxuICAgIGVtOiBcImVtXCIsXG4gICAgaDI6IFwiaDJcIixcbiAgICBoMzogXCJoM1wiLFxuICAgIGg0OiBcImg0XCIsXG4gICAgbGk6IFwibGlcIixcbiAgICBwOiBcInBcIixcbiAgICBwcmU6IFwicHJlXCIsXG4gICAgc3Ryb25nOiBcInN0cm9uZ1wiLFxuICAgIHVsOiBcInVsXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk1vc3Qgb2YgdXMgYXQgUmFiYml0TVEgSFEgaGF2ZSBzcGVuZCB0aW1lIHdvcmtpbmcgaW4gYSBudW1iZXIgb2YgZnVuY3Rpb25hbCBsYW5ndWFnZXMgaW4gYWRkaXRpb24gdG8gRXJsYW5nLCBzdWNoIGFzIEhhc2tlbGwsIFNjaGVtZSwgTGlzcCwgT0NhbWwgb3Igb3RoZXJzLiBXaGlsc3QgdGhlcmUgaXMgbG90cyB0byBsaWtlIGFib3V0IEVybGFuZywgc3VjaCBhcyBpdHMgVk0vRW11bGF0b3IsIHRoZXJlIGFyZSBpbmV2aXRhYmx5IGZlYXR1cmVzIHRoYXQgd2UgYWxsIG1pc3MgZnJvbSBvdGhlciBsYW5ndWFnZXMuIEluIG15IGNhc2UsIGhhdmluZyBzcGVudCBhIGNvdXBsZSBvZiB5ZWFycyB3b3JraW5nIGluIEhhc2tlbGwgYmVmb3JlIHJldHVybmluZyB0byB0aGUgUmFiYml0TVEgZm9sZCwgYWxsIHNvcnRzIG9mIGZlYXR1cmVzIGFyZSBcXFwibWlzc2luZ1xcXCIsIHN1Y2ggYXMgbGF6aW5lc3MsIHR5cGUgY2xhc3NlcywgYWRkaXRpb25hbCBpbmZpeCBvcGVyYXRvcnMsIHRoZSBhYmlsaXR5IHRvIHNwZWNpZnkgcHJlY2VkZW5jZSBvZiBmdW5jdGlvbnMsIGZld2VyIHBhcmVudGhlc2lzLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBtb3JlIGNvbnNpc3RlbnQgc3RhbmRhcmQgbGlicmFyaWVzIGFuZCBkby1ub3RhdGlvbi4gVGhhdCdzIGEgZmFpciBsaXN0LCBhbmQgaXQnbGwgdGFrZSBtZSBhIHdoaWxlIHRvIGdldCBhcm91bmQgdG8gaW1wbGVtZW50aW5nIHRoZW0gYWxsIGluIEVybGFuZywgYnV0IGhlcmUgYXJlIHR3byBmb3Igc3RhcnRlcnMuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiaW50cm9kdWN0aW9uXCIsXG4gICAgICBjaGlsZHJlbjogXCJJbnRyb2R1Y3Rpb25cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuYSwge1xuICAgICAgICBocmVmOiBcImh0dHA6Ly9oZy5yYWJiaXRtcS5jb20vZXJsYW5kby9cIixcbiAgICAgICAgY2hpbGRyZW46IFwiRXJsYW5kb1wiXG4gICAgICB9KSwgXCIgaXMgYSBzZXQgb2Ygc3ludGF4IGV4dGVuc2lvbnMgZm9yIEVybGFuZy4gQ3VycmVudGx5IGl0XFxyXFxuY29uc2lzdHMgb2YgdHdvIHN5bnRheCBleHRlbnNpb25zLCBib3RoIG9mIHdoaWNoIHRha2UgdGhlIGZvcm0gb2ZcXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5hLCB7XG4gICAgICAgIGhyZWY6IFwiaHR0cDovL3d3dy5lcmxhbmcub3JnL2RvYy9tYW4vZXJsX2lkX3RyYW5zLmh0bWxcIixcbiAgICAgICAgY2hpbGRyZW46IFwicGFyc2UgdHJhbnNmb3JtZXJzXCJcbiAgICAgIH0pLCBcIi5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnN0cm9uZywge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIkN1dFwiXG4gICAgICAgIH0pLCBcIjogVGhpcyBhZGRzIHN1cHBvcnQgZm9yIGN1dHMgdG8gRXJsYW5nLiBUaGVzZSBhcmVcXHJcXG5pbnNwaXJlZCBieSB0aGVcXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5hLCB7XG4gICAgICAgICAgaHJlZjogXCJodHRwOi8vc3JmaS5zY2hlbWVycy5vcmcvc3JmaS0yNi9zcmZpLTI2Lmh0bWxcIixcbiAgICAgICAgICBjaGlsZHJlbjogXCJTY2hlbWUgZm9ybSBvZiBjdXRzXCJcbiAgICAgICAgfSksIFwiLiBDdXRzXFxyXFxuY2FuIGJlIHRob3VnaHQgb2YgYXMgYSBsaWdodC13ZWlnaHQgZm9ybSBvZiBhYnN0cmFjdGlvbiwgd2l0aFxcclxcbnNpbWlsYXJpdGllcyB0byBwYXJ0aWFsIGFwcGxpY2F0aW9uIChvciBjdXJyeWluZykuXCJdXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnN0cm9uZywge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIkRvXCJcbiAgICAgICAgfSksIFwiOiBUaGlzIGFkZHMgc3VwcG9ydCBmb3IgZG8tc3ludGF4IGFuZCBtb25hZHMgdG9cXHJcXG5FcmxhbmcuIFRoZXNlIGFyZSBoZWF2aWx5IGluc3BpcmVkIGJ5IFwiLCBfanN4KF9jb21wb25lbnRzLmEsIHtcbiAgICAgICAgICBocmVmOiBcImh0dHA6Ly9oYXNrZWxsLm9yZ1wiLFxuICAgICAgICAgIGNoaWxkcmVuOiBcIkhhc2tlbGxcIlxuICAgICAgICB9KSwgXCIsXFxyXFxuYW5kIHRoZSBtb25hZHMgYW5kIGxpYnJhcmllcyBhcmUgbmVhci1tZWNoYW5pY2FsIHRyYW5zbGF0aW9ucyBmcm9tXFxyXFxudGhlIEhhc2tlbGwgR0hDIGxpYnJhcmllcy5cIl1cbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJ1c2VcIixcbiAgICAgIGNoaWxkcmVuOiBcIlVzZVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJUbyB1c2UgYW55IG9mIHRoZXNlIHBhcnNlIHRyYW5zZm9ybWVycywgeW91IG11c3QgYWRkIHRoZSBuZWNlc3NhcnlcXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIi1jb21waWxlXCJcbiAgICAgIH0pLCBcIiBhdHRyaWJ1dGVzIHRvIHlvdXIgRXJsYW5nIHNvdXJjZSBmaWxlcy4gRm9yIGV4YW1wbGU6XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwiLW1vZHVsZSh0ZXN0KS5cXHJcXG4tY29tcGlsZSh7cGFyc2VfdHJhbnNmb3JtLCBjdXR9KS5cXHJcXG4tY29tcGlsZSh7cGFyc2VfdHJhbnNmb3JtLCBkb30pLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiVGhlbiwgd2hlbiBjb21waWxpbmcgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJ0ZXN0LmVybFwiXG4gICAgICB9KSwgXCIsIHlvdSBtdXN0IGVuc3VyZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImVybGNcIlxuICAgICAgfSksIFwiIGNhbiBsb2NhdGVcXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImN1dC5iZWFtXCJcbiAgICAgIH0pLCBcIiBhbmQvb3IgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJkby5iZWFtXCJcbiAgICAgIH0pLCBcIiBieSBwYXNzaW5nIHRoZSBzdWl0YWJsZSBwYXRoIHRvIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZXJsY1wiXG4gICAgICB9KSwgXCIgd2l0aCBhXFxyXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCItcGFcIlxuICAgICAgfSksIFwiIG9yIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiLXB6XCJcbiAgICAgIH0pLCBcIiBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1zaGVsbFwiLFxuICAgICAgICBjaGlsZHJlbjogXCJlcmxjIC1XYWxsICtkZWJ1Z19pbmZvIC1JIC4vaW5jbHVkZSAtcGEgZWJpbiAtbyBlYmluICBzcmMvY3V0LmVybFxcclxcbmVybGMgLVdhbGwgK2RlYnVnX2luZm8gLUkgLi9pbmNsdWRlIC1wYSBlYmluIC1vIGViaW4gIHNyYy9kby5lcmxcXHJcXG5lcmxjIC1XYWxsICtkZWJ1Z19pbmZvIC1JIC4vaW5jbHVkZSAtcGEgdGVzdC9lYmluIC1wYSAuL2ViaW4gLW8gdGVzdC9lYmluIHRlc3Qvc3JjL3Rlc3QuZXJsXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJOb3RlLCBpZiB5b3UncmUgdXNpbmcgUUxDLCB5b3UgbWF5IGZpbmQgeW91IG5lZWQgdG8gYmUgY2FyZWZ1bCBhcyB0b1xcclxcbnRoZSBvcmRlciBvZiB0aGUgcGFyc2UgdHJhbnNmb3JtczogSSd2ZSBmb3VuZCB0aGF0IHRoZVxcclxcblwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiLWNvbXBpbGUoe3BhcnNlX3RyYW5zZm9ybSwgY3V0fSkuXCJcbiAgICAgIH0pLCBcIiBtdXN0IG9jY3VyIGJlZm9yZSB0aGVcXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIi1pbmNsdWRlX2xpYihcXFwic3RkbGliL2luY2x1ZGUvcWxjLmhybFxcXCIpLlwiXG4gICAgICB9KV1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiY3V0XCIsXG4gICAgICBjaGlsZHJlbjogXCJDdXRcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgzLCB7XG4gICAgICBpZDogXCJtb3RpdmF0aW9uXCIsXG4gICAgICBjaGlsZHJlbjogXCJNb3RpdmF0aW9uXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIkN1dCBpcyBtb3RpdmF0ZWQgYnkgdGhlIGZyZXF1ZW5jeSB3aXRoIHdoaWNoIHNpbXBsZSBhYnN0cmFjdGlvbnMgKGluIGFcXHJcXG5sYW1iZGEtY2FsY3VsdXMgc2Vuc2UpIGFyZSB1c2VkIGluIEVybGFuZywgYW5kIHRoZSByZWxhdGl2ZWx5IG5vaXN5XFxyXFxubmF0dXJlIG9mIGRlY2xhcmluZyBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImZ1blwiXG4gICAgICB9KSwgXCJzLiBGb3IgZXhhbXBsZSwgaXQncyBxdWl0ZSBjb21tb24gdG8gc2VlIGNvZGVcXHJcXG5saWtlOlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZXJsYW5nXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIndpdGhfcmVzb3VyY2UoUmVzb3VyY2UsIEZ1bikgLT5cXHJcXG4gICAgY2FzZSBsb29rdXBfcmVzb3VyY2UoUmVzb3VyY2UpIG9mXFxyXFxuICAgICAgICB7b2ssIFJ9ICAgICAgICAgIC0+IEZ1bihSKTtcXHJcXG4gICAgICAgIHtlcnJvciwgX30gPSBFcnIgLT4gRXJyXFxyXFxuICAgIGVuZC5cXHJcXG5cXHJcXG5teV9mdW4oQSwgQiwgQykgLT5cXHJcXG4gICAgd2l0aF9yZXNvdXJjZShBLCBmdW4gKFJlc291cmNlKSAtPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteV9yZXNvdXJjZV9tb2RpZmljYXRpb24oUmVzb3VyY2UsIEIsIEMpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kKS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIkkuZS4gYSBmdW4gaXMgdmVyeSBzaW1wbHkgY3JlYXRlZCBpbiBvcmRlciB0byBwZXJmb3JtIHZhcmlhYmxlIGNhcHR1cmVcXHJcXG5mcm9tIHRoZSBpdHMgc3Vycm91bmRpbmcgc2NvcGUgYnV0IHRvIGxlYXZlIGhvbGVzIGZvciBmdXJ0aGVyXFxyXFxuYXJndW1lbnRzIHRvIGJlIHByb3ZpZGVkLiBVc2luZyBhIGN1dCwgdGhlIGZ1bmN0aW9uIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwibXlfZnVuXCJcbiAgICAgIH0pLCBcIiBjYW4gYmVcXHJcXG5yZXdyaXR0ZW4gYXM6XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwibXlfZnVuKEEsIEIsIEMpIC0+XFxyXFxuICAgIHdpdGhfcmVzb3VyY2UoQSwgbXlfcmVzb3VyY2VfbW9kaWZpY2F0aW9uKF8sIEIsIEMpKS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMywge1xuICAgICAgaWQ6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgY2hpbGRyZW46IFwiRGVmaW5pdGlvblwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJOb3JtYWxseSwgdGhlIHZhcmlhYmxlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiX1wiXG4gICAgICB9KSwgXCIgY2FuIG9ubHkgb2NjdXIgaW4gcGF0dGVybnM6IGkuZS4gd2hlcmVcXHJcXG5tYXRjaCBvY2N1cnMuIFRoaXMgY2FuIGJlIGluIGFzc2lnbm1lbnQsIGluIGNhc2VzLCBhbmQgaW4gZnVuY3Rpb25cXHJcXG5oZWFkcy4gRm9yIGV4YW1wbGU6XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwie18sIGJhcn0gPSB7Zm9vLCBiYXJ9LlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiQ3V0IHVzZXMgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJfXCJcbiAgICAgIH0pLCBcIiBpbiBleHByZXNzaW9ucyB0byBpbmRpY2F0ZSB3aGVyZSBhYnN0cmFjdGlvbiBzaG91bGRcXHJcXG5vY2N1ci4gQWJzdHJhY3Rpb24gZnJvbSBjdXRzIGlzIFwiLCBfanN4KF9jb21wb25lbnRzLnN0cm9uZywge1xuICAgICAgICBjaGlsZHJlbjogXCJhbHdheXNcIlxuICAgICAgfSksIFwiIHBlcmZvcm1lZCBvbiB0aGVcXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5lbSwge1xuICAgICAgICBjaGlsZHJlbjogXCJzaGFsbG93ZXN0XCJcbiAgICAgIH0pLCBcIiBlbmNsb3NpbmcgZXhwcmVzc2lvbi4gRm9yIGV4YW1wbGU6XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwibGlzdF90b19iaW5hcnkoWzEsIDIsIG1hdGg6cG93KDIsIF8pXSkuXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwid2lsbCBjcmVhdGUgdGhlIGV4cHJlc3Npb25cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZXJsYW5nXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcImxpc3RfdG9fYmluYXJ5KFsxLCAyLCBmdW4gKFgpIC0+IG1hdGg6cG93KDIsIFgpIGVuZF0pLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcImFuZCBub3RcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZXJsYW5nXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcImZ1biAoWCkgLT4gbGlzdF90b19iaW5hcnkoWzEsIDIsIG1hdGg6cG93KDIsIFgpXSkgZW5kLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiSXQgaXMgZmluZSB0byB1c2UgbXVsdGlwbGUgY3V0cyBpbiB0aGUgc2FtZSBleHByZXNzaW9uLCBhbmQgdGhlXFxyXFxuYXJndW1lbnRzIHRvIHRoZSBjcmVhdGVkIGFic3RyYWN0aW9uIHdpbGwgbWF0Y2ggdGhlIG9yZGVyIGluIHdoaWNoIHRoZVxcclxcblwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiX1wiXG4gICAgICB9KSwgXCIgdmFyIGlzIGZvdW5kIGluIHRoZSBleHByZXNzaW9uLiBGb3IgZXhhbXBsZTpcIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJhc3NlcnRfc3VtXzMoWCwgWSwgWiwgU3VtKSB3aGVuIFggKyBZICsgWiA9PSBTdW0gLT4gb2s7XFxyXFxuYXNzZXJ0X3N1bV8zKF9YLCBfWSwgX1osIF9TdW0pIC0+IHtlcnJvciwgbm90X3N1bX0uXFxyXFxuXFxyXFxudGVzdCgpIC0+XFxyXFxuICAgIEVxdWFsczEyID0gYXNzZXJ0X3N1bV8zKF8sIF8sIF8sIDEyKSxcXHJcXG4gICAgb2sgPSBFcXVhbHMxMig5LCAyLCAxKS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIkl0IGlzIHBlcmZlY3RseSBsZWdhbCB0byB0YWtlIGN1dHMgb2YgY3V0cyBhcyB0aGUgYWJzdHJhY3Rpb24gY3JlYXRlZFxcclxcbmJ5IHRoZSBjdXQgaXMgYSBub3JtYWwgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJmdW5cIlxuICAgICAgfSksIFwiIGV4cHJlc3Npb24gYW5kIHRodXMgY2FuIGJlIHJlLWN1dCBhc1xcclxcbm5lY2Vzc2FyeTpcIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJ0ZXN0KCkgLT5cXHJcXG4gICAgRXF1YWxzMTIgPSBhc3NlcnRfc3VtXzMoXywgXywgXywgMTIpLFxcclxcbiAgICBFcXVhbHM1ID0gRXF1YWxzMTIoXywgXywgNyksXFxyXFxuICAgIG9rID0gRXF1YWxzNSgyLCAzKS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIk5vdGUgdGhhdCBiZWNhdXNlIGEgc2ltcGxlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZnVuXCJcbiAgICAgIH0pLCBcIiBpcyBiZWluZyBjb25zdHJ1Y3RlZCBieSB0aGUgY3V0LCB0aGVcXHJcXG5hcmd1bWVudHMgYXJlIGV2YWx1YXRlZCBwcmlvciB0byB0aGUgY3V0IGZ1bmN0aW9uLiBGb3IgZXhhbXBsZTpcIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJmMShfLCBfKSAtPiBpbzpmb3JtYXQoXFxcImluIGYxfm5cXFwiKS5cXHJcXG5cXHJcXG50ZXN0KCkgLT5cXHJcXG4gICAgRiA9IGYxKGlvOmZvcm1hdChcXFwidGVzdCBsaW5lIDF+blxcXCIpLCBfKSxcXHJcXG4gICAgRihpbzpmb3JtYXQoXFxcInRlc3QgbGluZSAyfm5cXFwiKSkuXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwid2lsbCBwcmludCBvdXRcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2Utc2hlbGxcIixcbiAgICAgICAgY2hpbGRyZW46IFwidGVzdCBsaW5lIDJcXHJcXG50ZXN0IGxpbmUgMVxcclxcbmluIGYxXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJUaGlzIGlzIGJlY2F1c2UgdGhlIGN1dCBjcmVhdGVzIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZnVuIChYKSAtPiBmMShpbzpmb3JtYXQoXFxcInRlc3QgbGluZSAxfm5cXFwiKSwgWCkgZW5kXCJcbiAgICAgIH0pLCBcIi4gVGh1cyBpdCBpcyBjbGVhciB0aGF0IFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiWFwiXG4gICAgICB9KSwgXCIgbXVzdCBiZSBldmFsdWF0ZWQgZmlyc3QsXFxyXFxuYmVmb3JlIHRoZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImZ1blwiXG4gICAgICB9KSwgXCIgY2FuIGJlIGludm9rZWQuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiT2YgY291cnNlLCBubyBvbmUgd291bGQgYmUgY3JhenkgZW5vdWdoIHRvIGhhdmUgc2lkZS1lZmZlY3RzIGluXFxyXFxuZnVuY3Rpb24gYXJndW1lbnQgZXhwcmVzc2lvbnMsIHNvIHRoaXMgd2lsbCBuZXZlciBjYXVzZSBhbnkgaXNzdWVzIVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiQ3V0cyBhcmUgbm90IGxpbWl0ZWQgdG8gZnVuY3Rpb24gY2FsbHMuIFRoZXkgY2FuIGJlIHVzZWQgaW4gYW55XFxyXFxuZXhwcmVzc2lvbiB3aGVyZSB0aGV5IG1ha2Ugc2Vuc2U6XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oNCwge1xuICAgICAgaWQ6IFwidHVwbGVzXCIsXG4gICAgICBjaGlsZHJlbjogXCJUdXBsZXNcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZXJsYW5nXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkYgPSB7XywgM30sXFxyXFxue2EsIDN9ID0gRihhKS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oNCwge1xuICAgICAgaWQ6IFwibGlzdHNcIixcbiAgICAgIGNoaWxkcmVuOiBcIkxpc3RzXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJkYmxfY29ucyhMaXN0KSAtPiBbXywgXyB8IExpc3RdLlxcclxcblxcclxcbnRlc3QoKSAtPlxcclxcbiAgICBGID0gZGJsX2NvbnMoWzMzXSksXFxyXFxuICAgIFs3LCA4LCAzM10gPSBGKDcsIDgpLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk5vdGUgdGhhdCBpZiB5b3UgbmVzdCBhIGxpc3QgYXMgYSBsaXN0IHRhaWwgaW4gRXJsYW5nLCBpdCdzIHN0aWxsXFxyXFxudHJlYXRlZCBhcyBvbmUgZXhwcmVzc2lvbi4gRm9yIGV4YW1wbGU6XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJBID0gW2EsIGIgfCBbYywgZCB8IFtlXV1dXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiaXMgZXhhY3RseSB0aGUgc2FtZSAocmlnaHQgZnJvbSB0aGUgRXJsYW5nIHBhcnNlciBvbndhcmRzKSBhczpcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJBID0gW2EsIGIsIGMsIGQsIGVdXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJJLmUuIHRob3NlIHN1Yi1saXN0cywgd2hlbiB0aGV5J3JlIGluIHRoZSB0YWlsIHBvc2l0aW9uIFwiLCBfanN4KF9jb21wb25lbnRzLnN0cm9uZywge1xuICAgICAgICBjaGlsZHJlbjogXCJkbyBub3RcIlxuICAgICAgfSksIFwiXFxyXFxuZm9ybSBzdWItZXhwcmVzc2lvbnMuIFRodXM6XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwiRiA9IFsxLCBfLCBfLCBbX10sIDUgfCBbNiwgW19dIHwgW19dXV0sXFxyXFxuJSUgVGhpcyBpcyB0aGUgc2FtZSBhczpcXHJcXG4lJSAgWzEsIF8sIF8sIFtfXSwgNSwgNiwgW19dLCBfXVxcclxcblsxLCAyLCAzLCBHLCA1LCA2LCBILCA4XSA9IEYoMiwgMywgOCksXFxyXFxuWzRdID0gRyg0KSxcXHJcXG5bN10gPSBIKDcpLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiSG93ZXZlciwgYmUgdmVyeSBjbGVhciBhYm91dCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiLFwiXG4gICAgICB9KSwgXCIgYW5kIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwifFwiXG4gICAgICB9KSwgXCI6IHRoZVxcclxcbnRhaWwgb2YgYSBsaXN0IGlzIFwiLCBfanN4KF9jb21wb25lbnRzLnN0cm9uZywge1xuICAgICAgICBjaGlsZHJlbjogXCJvbmx5XCJcbiAgICAgIH0pLCBcIiBkZWZpbmVkIGZvbGxvd2luZyBhIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwifFwiXG4gICAgICB9KSwgXCIuIEZvbGxvd2luZyBhIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiLFwiXG4gICAgICB9KSwgXCIsXFxyXFxueW91J3JlIGp1c3QgZGVmaW5pbmcgYW5vdGhlciBsaXN0IGVsZW1lbnQuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwiRiA9IFtfLCBbX11dLFxcclxcbiUlIFRoaXMgaXMgKipub3QqKiB0aGUgc2FtZSBhcyBbXywgX10gb3IgaXRzIHN5bm9ueW06IFtfIHwgW19dXVxcclxcblthLCBHXSA9IEYoYSksXFxyXFxuW2JdID0gRyhiKS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oNCwge1xuICAgICAgaWQ6IFwicmVjb3Jkc1wiLFxuICAgICAgY2hpbGRyZW46IFwiUmVjb3Jkc1wiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwiLXJlY29yZCh2ZWN0b3IsIHsgeCwgeSwgeiB9KS5cXHJcXG5cXHJcXG50ZXN0KCkgLT5cXHJcXG4gICAgR2V0WiA9IF8jdmVjdG9yLnosXFxyXFxuICAgIDcgPSBHZXRaKCN2ZWN0b3IgeyB6ID0gNyB9KSxcXHJcXG4gICAgU2V0WCA9IF8jdmVjdG9ye3ggPSBffSxcXHJcXG4gICAgViA9ICN2ZWN0b3J7IHggPSA1LCB5ID0gNCB9ID0gU2V0WCgjdmVjdG9yeyB5ID0gNCB9LCA1KS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oNCwge1xuICAgICAgaWQ6IFwiY2FzZVwiLFxuICAgICAgY2hpbGRyZW46IFwiQ2FzZVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwiRiA9IGNhc2UgXyBvZlxcclxcbiAgICAgICAgTiB3aGVuIGlzX2ludGVnZXIoTikgLT4gTiArIE47XFxyXFxuICAgICAgICBOICAgICAgICAgICAgICAgICAgICAtPiBOXFxyXFxuICAgIGVuZCxcXHJcXG4xMCA9IEYoNSksXFxyXFxub2sgPSBGKG9rKS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIlNlZVxcclxcblwiLCBfanN4KF9jb21wb25lbnRzLmEsIHtcbiAgICAgICAgaHJlZjogXCJodHRwOi8vaGcucmFiYml0bXEuY29tL2VybGFuZG8vZmlsZS9kZWZhdWx0L3Rlc3Qvc3JjL3Rlc3RfY3V0LmVybFwiLFxuICAgICAgICBjaGlsZHJlbjogXCJ0ZXN0X2N1dC5lcmxcIlxuICAgICAgfSksIFwiXFxyXFxuZm9yIG1vcmUgZXhhbXBsZXMsIGluY2x1ZGluZyB1c2Ugb2YgY3V0cyBpbiBsaXN0IGNvbXByZWhlbnNpb25zIGFuZFxcclxcbmJpbmFyeSBjb25zdHJ1Y3Rpb24uXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiTm90ZSB0aGF0IGN1dHMgYXJlIG5vdCBhbGxvd2VkIHdoZXJlIHRoZSByZXN1bHQgb2YgdGhlIGN1dCBjYW4gb25seSBiZVxcclxcbnVzZWZ1bCBieSBpbnRlcmFjdGluZyB3aXRoIHRoZSBldmFsdWF0aW9uIHNjb3BlLiBGb3IgZXhhbXBsZTpcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZXJsYW5nXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkYgPSBiZWdpbiBfLCBfLCBfIGVuZC5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIlRoaXMgaXMgbm90IGFsbG93ZWQsIGJlY2F1c2UgdGhlIGFyZ3VtZW50cyB0byBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIkZcIlxuICAgICAgfSksIFwiIHdvdWxkIGhhdmUgdG8gYmVcXHJcXG5ldmFsdWF0ZWQgYmVmb3JlIHRoZSBpbnZvY2F0aW9uIG9mIGl0cyBib2R5LCB3aGljaCB3b3VsZCB0aGVuIGhhdmUgbm9cXHJcXG5lZmZlY3QsIGFzIHRoZXkncmUgYWxyZWFkeSBmdWxseSBldmFsdWF0ZWQgYnkgdGhhdCBwb2ludC5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZG9cIixcbiAgICAgIGNoaWxkcmVuOiBcIkRvXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIlRoZSBEbyBwYXJzZSB0cmFuc2Zvcm1lciBwZXJtaXRzIEhhc2tlbGwtc3R5bGUgXCIsIF9qc3goX2NvbXBvbmVudHMuZW0sIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZG8tbm90YXRpb25cIlxuICAgICAgfSksIFwiIGluXFxyXFxuRXJsYW5nLCB3aGljaCBtYWtlcyB1c2luZyBtb25hZHMsIGFuZCBtb25hZCB0cmFuc2Zvcm1lcnMgcG9zc2libGUgYW5kXFxyXFxuZWFzeS4gV2l0aG91dCBcIiwgX2pzeChfY29tcG9uZW50cy5lbSwge1xuICAgICAgICBjaGlsZHJlbjogXCJkby1ub3RhdGlvblwiXG4gICAgICB9KSwgXCIsIG1vbmFkcyB0ZW5kIHRvIGxvb2sgbGlrZSBhIGxvdCBvZiBsaW5lXFxyXFxubm9pc2UuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDMsIHtcbiAgICAgIGlkOiBcInRoZS1pbmV2aXRhYmxlLW1vbmFkLXR1dG9yaWFsXCIsXG4gICAgICBjaGlsZHJlbjogXCJUaGUgSW5ldml0YWJsZSBNb25hZCBUdXRvcmlhbFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDQsIHtcbiAgICAgIGlkOiBcInRoZS1tZWNoYW5pY3Mtb2YtYS1jb21tYVwiLFxuICAgICAgY2hpbGRyZW46IFwiVGhlIE1lY2hhbmljcyBvZiBhIENvbW1hXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJXaGF0IGZvbGxvd3MgaXMgYSBicmllZiBhbmQgbWVjaGFuaWNhbCBpbnRyb2R1Y3Rpb24gdG8gbW9uYWRzLiBJdFxcclxcbmRpZmZlcnMgZnJvbSBhIGxvdCBvZiB0aGUgSGFza2VsbCBtb25hZCB0dXRvcmlhbHMsIGJlY2F1c2UgdGhleSB0ZW5kXFxyXFxudG8gdmlldyBtb25hZHMgYXMgYSBtZWFucyBvZiBhY2hpZXZpbmcgc2VxdWVuY2luZyBvZiBvcGVyYXRpb25zIGluXFxyXFxuSGFza2VsbCwgd2hpY2ggaXMgY2hhbGxlbmdpbmcgYmVjYXVzZSBIYXNrZWxsIGlzIGEgbGF6eVxcclxcbmxhbmd1YWdlLiBFcmxhbmcgaXMgbm90IGEgbGF6eSBsYW5ndWFnZSwgYnV0IHRoZSBwb3dlcmZ1bCBhYnN0cmFjdGlvbnNcXHJcXG5wb3NzaWJsZSBmcm9tIHVzaW5nIG1vbmFkcyBhcmUgc3RpbGwgdmVyeSB3b3J0aHdoaWxlLiBXaGlsc3QgdGhpcyBpcyBhXFxyXFxudmVyeSBtZWNoYW5pY2FsIHR1dG9yaWFsLCBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gc2VlIHRoZSBtb3JlXFxyXFxuYWR2YW5jZWQgYWJzdHJhY3Rpb25zIHBvc3NpYmxlLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiTGV0J3Mgc2F5IHdlIGhhdmUgdGhlIHRocmVlIGxpbmVzIG9mIGNvZGU6XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJBID0gZm9vKCksXFxyXFxuQiA9IGJhcihBLCBkb2cpLFxcclxcbm9rLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoZXkgYXJlIHRocmVlLCBzaW1wbGUgc3RhdGVtZW50cywgd2hpY2ggYXJlIGV2YWx1YXRlZFxcclxcbmNvbnNlY3V0aXZlbHkuIFdoYXQgYSBtb25hZCBnaXZlcyB5b3UgaXMgY29udHJvbCBvdmVyIHdoYXQgaGFwcGVuc1xcclxcbmJldHdlZW4gdGhlIHN0YXRlbWVudHM6IGluIEVybGFuZywgaXQgaXMgYSBwcm9ncmFtbWF0aWMgY29tbWEuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJZiB5b3Ugd2FudGVkIHRvIGltcGxlbWVudCBhIHByb2dyYW1tYXRpYyBjb21tYSwgaG93IHdvdWxkIHlvdSBkbyBpdD9cXHJcXG5Zb3UgbWlnaHQgc3RhcnQgd2l0aCBzb21ldGhpbmcgbGlrZTpcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZXJsYW5nXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkEgPSBmb28oKSxcXHJcXG5jb21tYSgpLFxcclxcbkIgPSBiYXIoQSwgZG9nKSxcXHJcXG5jb21tYSgpLFxcclxcbm9rLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiQnV0IHRoYXQncyBub3QgcXVpdGUgcG93ZXJmdWwgZW5vdWdoLCBiZWNhdXNlIHVubGVzcyBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImNvbW1hLzBcIlxuICAgICAgfSksIFwiIHRocm93c1xcclxcbnNvbWUgc29ydCBvZiBleGNlcHRpb24sIGl0IGNhbid0IGFjdHVhbGx5IHN0b3AgdGhlIHN1YnNlcXVlbnRcXHJcXG5leHByZXNzaW9uIGZyb20gYmVpbmcgZXZhbHVhdGVkLiBNb3N0IG9mIHRoZSB0aW1lIHdlJ2QgcHJvYmFibHkgbGlrZVxcclxcbnRoZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImNvbW1hLzBcIlxuICAgICAgfSksIFwiIGZ1bmN0aW9uIHRvIGJlIGFibGUgdG8gYWN0IG9uIHNvbWUgdmFyaWFibGVzIHdoaWNoIGFyZVxcclxcbmN1cnJlbnRseSBpbiBzY29wZSwgYW5kIHRoYXQncyBub3QgcG9zc2libGUgaGVyZSBlaXRoZXIuIFNvIHdlIHNob3VsZFxcclxcbmV4dGVuZCB0aGUgZnVuY3Rpb24gXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJjb21tYS8wXCJcbiAgICAgIH0pLCBcIiBzbyB0aGF0IGl0IHRha2VzIHRoZSByZXN1bHQgb2YgdGhlXFxyXFxucHJlY2VkaW5nIGV4cHJlc3Npb24sIGFuZCBjYW4gY2hvb3NlIHdoZXRoZXIgb3Igbm90IHRoZSBzdWJzZXF1ZW50XFxyXFxuZXhwcmVzc2lvbnMgc2hvdWxkIGJlIGV2YWx1YXRlZDpcIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJjb21tYShmb28oKSxcXHJcXG4gICAgICAgIGZ1biAoQSkgLT4gY29tbWEoYmFyKEEsIGRvZyksXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuIChCKSAtPiBvayBlbmQpKS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIlRodXMgdGhlIGZ1bmN0aW9uIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiY29tbWEvMlwiXG4gICAgICB9KSwgXCIgdGFrZXMgYWxsIHJlc3VsdHMgZnJvbSB0aGUgcHJldmlvdXNcXHJcXG5leHByZXNzaW9uLCBhbmQgY29udHJvbHMgaG93IGFuZCB3aGV0aGVyIHRoZXkgYXJlIHBhc3NlZCB0byB0aGUgbmV4dFxcclxcbmV4cHJlc3Npb24uXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJBcyBkZWZpbmVkLCB0aGUgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJjb21tYS8yXCJcbiAgICAgIH0pLCBcIiBmdW5jdGlvbiBpcyB0aGUgbW9uYWRpYyBmdW5jdGlvbiBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIj4+PS8yXCJcbiAgICAgIH0pLCBcIi5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIk5vdyBpdCdzIHByZXR0eSBkaWZmaWN1bHQgdG8gcmVhZCB0aGUgcHJvZ3JhbSB3aXRoIHRoZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImNvbW1hLzJcIlxuICAgICAgfSksIFwiXFxyXFxuZnVuY3Rpb24gKGVzcGVjaWFsbHkgYXMgRXJsYW5nIGFubm95aW5nbHkgZG9lc24ndCBhbGxvdyB1cyB0byBkZWZpbmVcXHJcXG5uZXcgaW5maXggZnVuY3Rpb25zKSwgd2hpY2ggaXMgd2h5IHNvbWUgc3BlY2lhbCBzeW50YXggaXNcXHJcXG5uZWNlc3NhcnkuIEhhc2tlbGwgaGFzIGl0J3MgXCIsIF9qc3goX2NvbXBvbmVudHMuZW0sIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZG8tbm90YXRpb25cIlxuICAgICAgfSksIFwiLCBhbmQgc28gd2UndmUgYm9ycm93ZWQgZnJvbVxcclxcbnRoYXQgYW5kIGFidXNlZCBFcmxhbmcncyBsaXN0IGNvbXByZWhlbnNpb25zLiBIYXNrZWxsIGFsc28gaGFzIGxvdmVseVxcclxcbnR5cGUtY2xhc3Nlcywgd2hpY2ggd2UndmUgc29ydCBvZiBmYWtlZCBzcGVjaWZpY2FsbHkgZm9yIG1vbmFkcy4gU28sXFxyXFxud2l0aCB0aGUgRG8gcGFyc2UgdHJhbnNmb3JtZXIsIHlvdSBjYW4gd3JpdGUgaW4gRXJsYW5nOlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZXJsYW5nXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcImRvKFtNb25hZCB8fFxcclxcbiAgICBBIDwtIGZvbygpLFxcclxcbiAgICBCIDwtIGJhcihBLCBkb2cpLFxcclxcbiAgICBva10pLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIndoaWNoIGlzIHJlYWRhYmxlIGFuZCBzdHJhaWdodGZvcndhcmQsIGJ1dCBpcyB0cmFuc2Zvcm1lZCBpbnRvOlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwiTW9uYWQ6Jz4+PScoZm9vKCksXFxyXFxuICAgICAgICAgICAgZnVuIChBKSAtPiBNb25hZDonPj49JyhiYXIoQSwgZG9nKSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW4gKEIpIC0+IG9rIGVuZCkpLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiVGhlcmUgaXMgbm8gaW50ZW50aW9uIHRoYXQgdGhpcyBsYXR0ZXIgZm9ybSBpcyBhbnkgbW9yZSByZWFkYWJsZSB0aGFuXFxyXFxudGhlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiY29tbWEvMlwiXG4gICAgICB9KSwgXCIgZm9ybSAtIGl0IGlzIG5vdC4gSG93ZXZlciwgaXQgc2hvdWxkIGJlIGNsZWFyIHRoYXQgdGhlXFxyXFxuZnVuY3Rpb24gXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJNb25hZDonPj49Jy8yXCJcbiAgICAgIH0pLCBcIiBub3cgaGFzIGNvbXBsZXRlIGNvbnRyb2wgb3ZlciB3aGF0IGhhcHBlbnM6XFxyXFxuZG9lcyB0aGUgZnVuIG9uIHRoZSByaWdodCBoYW5kIHNpZGUgZXZlciBnZXQgaW52b2tlZD8gSWYgc28sIHdpdGggd2hhdFxcclxcbnZhbHVlP1wiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmg0LCB7XG4gICAgICBpZDogXCJsb3RzLW9mLWRpZmZlcmVudC10eXBlcy1vZi1tb25hZHNcIixcbiAgICAgIGNoaWxkcmVuOiBcIkxvdHMgb2YgZGlmZmVyZW50IHR5cGVzIG9mIE1vbmFkc1wiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiU28gbm93IHRoYXQgd2UgaGF2ZSBzb21lIHJlbGF0aXZlbHkgbmljZSBzeW50YXggZm9yIHVzaW5nIG1vbmFkcywgd2hhdFxcclxcbmNhbiB3ZSBkbyB3aXRoIHRoZW0/IEFsc28sIGluIHRoZSBjb2RlXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJkbyhbTW9uYWQgfHxcXHJcXG4gICAgQSA8LSBmb28oKSxcXHJcXG4gICAgQiA8LSBiYXIoQSwgZG9nKSxcXHJcXG4gICAgb2tdKS5cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIndoYXQgYXJlIHRoZSBwb3NzaWJsZSB2YWx1ZXMgb2YgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJNb25hZFwiXG4gICAgICB9KSwgXCI/XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJUaGUgYW5zd2VyIHRvIHRoZSBmaXJzdCBxdWVzdGlvbiBpcyBcIiwgX2pzeChfY29tcG9uZW50cy5lbSwge1xuICAgICAgICBjaGlsZHJlbjogXCJhbG1vc3QgYW55dGhpbmdcIlxuICAgICAgfSksIFwiOyBhbmQgdG8gdGhlXFxyXFxubGF0ZXIgcXVlc3Rpb24sIGlzIFwiLCBfanN4KF9jb21wb25lbnRzLmVtLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImFueSBtb2R1bGUgbmFtZSB0aGF0IGltcGxlbWVudHMgdGhlIG1vbmFkXFxyXFxuYmVoYXZpb3VyXCJcbiAgICAgIH0pLCBcIi5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIkFib3ZlLCB3ZSBjb3ZlcmVkIG9uZSBvZiB0aGUgdGhyZWUgbW9uYWRpYyBvcGVyYXRvcnMsIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiPj49LzJcIlxuICAgICAgfSksIFwiLiBUaGVcXHJcXG5vdGhlcnMgYXJlOlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwicmV0dXJuLzFcIlxuICAgICAgICAgIH0pLCBcIjogVGhpcyBcIiwgX2pzeChfY29tcG9uZW50cy5lbSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwibGlmdHNcIlxuICAgICAgICAgIH0pLCBcIiBhIHZhbHVlIGludG8gdGhlIG1vbmFkLiBXZSdsbCBzZWUgZXhhbXBsZXNcXHJcXG5vZiB0aGlzIHNob3J0bHkuXCJdXG4gICAgICAgIH0pLCBcIlxcblwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJmYWlsLzFcIlxuICAgICAgICAgIH0pLCBcIjogVGhpcyB0YWtlcyBhIHRlcm0gZGVzY3JpYmluZyB0aGUgZXJyb3IgZW5jb3VudGVyZWQsIGFuZFxcclxcbmluZm9ybXMgd2hpY2hldmVyIG1vbmFkIGN1cnJlbnRseSBpbiB1c2UgdGhhdCBzb21lIHNvcnQgb2YgZXJyb3IgaGFzXFxyXFxub2NjdXJyZWQuXCJdXG4gICAgICAgIH0pLCBcIlxcblwiXVxuICAgICAgfSksIFwiXFxuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJOb3RlIHRoYXQgd2l0aGluIFwiLCBfanN4KF9jb21wb25lbnRzLmVtLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImRvLW5vdGF0aW9uXCJcbiAgICAgIH0pLCBcIiwgYW55IGZ1bmN0aW9uIGNhbGwgdG8gZnVuY3Rpb25zIG5hbWVkXFxyXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJyZXR1cm5cIlxuICAgICAgfSksIFwiIG9yIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZmFpbFwiXG4gICAgICB9KSwgXCIsIGFyZSBhdXRvbWF0aWNhbGx5IHJld3JpdHRlbiB0byBpbnZva2UgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJyZXR1cm5cIlxuICAgICAgfSksIFwiIG9yXFxyXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJmYWlsXCJcbiAgICAgIH0pLCBcIiB3aXRoaW4gdGhlIGN1cnJlbnQgbW9uYWQuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJTb21lIHBlb3BsZSBmYW1pbGlhciB3aXRoIEhhc2tlbGwncyBtb25hZHMgbWF5IGJlIGV4cGVjdGluZyB0byBzZWUgYVxcclxcbmZvdXJ0aCBvcGVyYXRvciwgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCI+Pi8yXCJcbiAgICAgIH0pLCBcIi4gSW50ZXJlc3RpbmdseSwgaXQgdHVybnMgb3V0IHRoYXQgeW91IGNhbid0XFxyXFxuaW1wbGVtZW50IFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiPj4vMlwiXG4gICAgICB9KSwgXCIgaW4gYSBzdHJpY3QgbGFuZ3VhZ2UgdW5sZXNzIGFsbCB5b3VyIG1vbmFkIHR5cGVzIGFyZVxcclxcbmJ1aWx0IG9uIHRvcCBhIGZ1bmN0aW9uLiBUaGlzIGlzIGJlY2F1c2UgaW4gYSBzdHJpY3QgbGFuZ3VhZ2UsXFxyXFxuYXJndW1lbnRzIHRvIGZ1bmN0aW9ucyBhcmUgZXZhbHVhdGVkIGJlZm9yZSB0aGUgZnVuY3Rpb24gaXNcXHJcXG5pbnZva2VkLiBGb3IgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCI+Pj0vMlwiXG4gICAgICB9KSwgXCIsIHRoZSAybmQgYXJndW1lbnQgaXMgb25seSByZWR1Y2VkIHRvIGEgZnVuY3Rpb25cXHJcXG5wcmlvciB0byBpbnZvY2F0aW9uIG9mIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiPj49LzJcIlxuICAgICAgfSksIFwiLiBCdXQgdGhlIDJuZCBhcmd1bWVudCB0byBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIj4+LzJcIlxuICAgICAgfSksIFwiIGlzIG5vdFxcclxcbmEgZnVuY3Rpb24sIGFuZCBzbyBpbiBzdHJpY3QgbGFuZ3VhZ2VzLCB3aWxsIGJlIGZ1bGx5IHJlZHVjZWQgcHJpb3IgdG9cXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIj4+LzJcIlxuICAgICAgfSksIFwiIGJlaW5nIGludm9rZWQuIFRoaXMgaXMgcHJvYmxlbWF0aWMgYmVjYXVzZSB0aGUgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCI+Pi8yXCJcbiAgICAgIH0pLCBcIiBvcGVyYXRvclxcclxcbmlzIG1lYW50IHRvIGJlIGluIGNvbnRyb2wgb2Ygd2hldGhlciBvciBub3Qgc3Vic2VxdWVudCBleHByZXNzaW9ucyBhcmVcXHJcXG5ldmFsdWF0ZWQuIFRoZSBvbmx5IHNvbHV0aW9uIGhlcmUgd291bGQgYmUgdG8gbWFrZSB0aGUgYmFzaWMgbW9uYWRcXHJcXG50eXBlIGEgZnVuY3Rpb24sIHdoaWNoIHdvdWxkIHRoZW4gbWVhbiB0aGF0IHRoZSAybmQgYXJndW1lbnQgdG9cXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIj4+PS8yXCJcbiAgICAgIH0pLCBcIiB3b3VsZCBiZWNvbWUgYSBmdW5jdGlvbiB0byBhIGZ1bmN0aW9uIHRvIGEgcmVzdWx0ISBIb3dldmVyLCBpdFxcclxcbmlzIHJlcXVpcmVkIHRoYXQgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCInPj4nKEEsIEIpXCJcbiAgICAgIH0pLCBcIiBiZWhhdmVzIGlkZW50aWNhbGx5IHRvIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiJz4+PScoQSwgZnVuIChfKSAtPiBCIGVuZClcIlxuICAgICAgfSksIFwiLCBhbmQgc28gdGhhdCBpcyB3aGF0IHdlIGRvOiB3aGVuZXZlciB3ZSBjb21lIHRvIGFcXHJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImRvKFtNb25hZCB8fCBBLCBCIF0pXCJcbiAgICAgIH0pLCBcIiwgd2UgcmV3cml0ZSBpdCB0byBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIic+Pj0nKEEsIGZ1biAoXykgLT4gQiBlbmQpXCJcbiAgICAgIH0pLCBcIlxcclxcbnJhdGhlciB0aGFuIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiJz4+JyhBLCBCKVwiXG4gICAgICB9KSwgXCIuIFRoZSBlZmZlY3Qgb2YgdGhpcyBpcyB0aGF0IHRoZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIj4+LzJcIlxuICAgICAgfSksIFwiXFxyXFxub3BlcmF0b3IgZG9lcyBub3QgZXhpc3QuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhlIHNpbXBsZXN0IG1vbmFkIHBvc3NpYmxlIGlzIHRoZSBJZGVudGl0eS1tb25hZDpcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZXJsYW5nXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIi1tb2R1bGUoaWRlbnRpdHlfbSkuXFxyXFxuLWJlaGF2aW91cihtb25hZCkuXFxyXFxuLWV4cG9ydChbJz4+PScvMiwgcmV0dXJuLzEsIGZhaWwvMV0pLlxcclxcblxcclxcbic+Pj0nKFgsIEZ1bikgLT4gRnVuKFgpLlxcclxcbnJldHVybihYKSAgICAgLT4gWC5cXHJcXG5mYWlsKFgpICAgICAgIC0+IHRocm93KHtlcnJvciwgWH0pLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiVGhpcyBtYWtlcyBvdXIgcHJvZ3JhbW1hdGljIGNvbW1hIGJlaGF2ZSBqdXN0IGxpa2UgRXJsYW5nJ3MgY29tbWFcXHJcXG5ub3JtYWxseSBkb2VzLiBUaGUgXCIsIF9qc3goX2NvbXBvbmVudHMuc3Ryb25nLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImJpbmRcIlxuICAgICAgfSksIFwiIG9wZXJhdG9yIChcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIj4+PS8yXCJcbiAgICAgIH0pLCBcIikgZG9lcyBub3QgaW5zcGVjdCB0aGVcXHJcXG52YWx1ZXMgcGFzc2VkIHRvIGl0LCBhbmQgYWx3YXlzIGludm9rZXMgdGhlIHN1YnNlcXVlbnQgZXhwcmVzc2lvbiBmdW4uXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiV2hhdCBjb3VsZCB3ZSBkbyBpZiB3ZSBkaWQgaW5zcGVjdCB0aGUgdmFsdWVzIHBhc3NlZCB0byB0aGUgc2VxdWVuY2luZ1xcclxcbmNvbWJpbmF0b3JzPyBPbmUgcG9zc2liaWxpdHkgcmVzdWx0cyBpbiB0aGUgTWF5YmUtbW9uYWQ6XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCItbW9kdWxlKG1heWJlX20pLlxcclxcbi1iZWhhdmlvdXIobW9uYWQpLlxcclxcbi1leHBvcnQoWyc+Pj0nLzIsIHJldHVybi8xLCBmYWlsLzFdKS5cXHJcXG5cXHJcXG4nPj49Jyh7anVzdCwgWH0sIEZ1bikgLT4gRnVuKFgpO1xcclxcbic+Pj0nKG5vdGhpbmcsICBfRnVuKSAtPiBub3RoaW5nLlxcclxcblxcclxcbnJldHVybihYKSAtPiB7anVzdCwgWH0uXFxyXFxuZmFpbChfWCkgIC0+IG5vdGhpbmcuXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJUaHVzIGlmIHRoZSByZXN1bHQgb2YgdGhlIHByZWNlZGluZyBleHByZXNzaW9uIGlzIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwibm90aGluZ1wiXG4gICAgICB9KSwgXCIsIHRoZW4gdGhlXFxyXFxuc3Vic2VxdWVudCBleHByZXNzaW9ucyBhcmUgbm90IGV2YWx1YXRlZC4gVGhpcyBtZWFucyB0aGF0IHdlIGNhbiB3cml0ZVxcclxcbnZlcnkgbmVhdCBsb29raW5nIGNvZGUgd2hpY2ggaW1tZWRpYXRlbHkgc3RvcHMgc2hvdWxkIGFueSBmYWlsdXJlIGJlXFxyXFxuZW5jb3VudGVyZWQuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwiaWZfc2FmZV9kaXZfemVybyhYLCBZLCBGdW4pIC0+XFxyXFxuICAgIGRvKFttYXliZV9tIHx8XFxyXFxuICAgICAgICBSZXN1bHQgPC0gY2FzZSBZID09IDAgb2ZcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlICAtPiBmYWlsKFxcXCJDYW5ub3QgZGl2aWRlIGJ5IHplcm9cXFwiKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSAtPiByZXR1cm4oWCAvIFkpXFxyXFxuICAgICAgICAgICAgICAgICAgICBlbmQsXFxyXFxuICAgICAgICByZXR1cm4oRnVuKFJlc3VsdCkpXSkuXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJJZiBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIllcIlxuICAgICAgfSksIFwiIGlzIGVxdWFsIHRvIDAsIHRoZW4gXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJGdW5cIlxuICAgICAgfSksIFwiIHdpbGwgbm90IGJlIGludm9rZWQsIGFuZCB0aGUgcmVzdWx0XFxyXFxub2YgdGhlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiaWZfc2FmZV9kaXZfemVyb1wiXG4gICAgICB9KSwgXCIgZnVuY3Rpb24gY2FsbCB3aWxsIGJlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwibm90aGluZ1wiXG4gICAgICB9KSwgXCIuIElmIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiWVwiXG4gICAgICB9KSwgXCIgaXNcXHJcXG5ub3QgZXF1YWwgdG8gMCwgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImlmX3NhZmVfZGl2X3plcm9cIlxuICAgICAgfSksIFwiIGZ1bmN0aW9uXFxyXFxuY2FsbCB3aWxsIGJlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwie2p1c3QsIEZ1bihYIC8gWSl9XCJcbiAgICAgIH0pLCBcIi5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIldlIHNlZSBoZXJlIHRoYXQgd2l0aGluIHRoZSBkby1ibG9jaywgdGhlcmUgaXMgbm8gbWVudGlvbiBvZiBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIm5vdGhpbmdcIlxuICAgICAgfSksIFwiXFxyXFxub3IgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJqdXN0XCJcbiAgICAgIH0pLCBcIjogdGhleSBhcmUgYWJzdHJhY3RlZCBhd2F5IGJ5IHRoZSBNYXliZS1tb25hZC4gQXMgYSByZXN1bHQsXFxyXFxuaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSBtb25hZCBpbiB1c2UsIHdpdGhvdXQgaGF2aW5nIHRvIHJld3JpdGVcXHJcXG5hbnkgZnVydGhlciBjb2RlLlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk9uZSBjb21tb24gcGxhY2UgdG8gdXNlIGEgbW9uYWQgbGlrZSB0aGUgTWF5YmUtbW9uYWQgaXMgd2hlcmUgeW91J2RcXHJcXG5vdGhlcndpc2UgaGF2ZSBhIGxvdCBvZiBuZXN0ZWQgY2FzZSBzdGF0ZW1lbnRzIGluIG9yZGVyIHRvIGRldGVjdFxcclxcbmVycm9ycy4gRm9yIGV4YW1wbGU6XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJ3cml0ZV9maWxlKFBhdGgsIERhdGEsIE1vZGVzKSAtPlxcclxcbiAgICBNb2RlczEgPSBbYmluYXJ5LCB3cml0ZSB8IChNb2RlcyAtLSBbYmluYXJ5LCB3cml0ZV0pXSxcXHJcXG4gICAgY2FzZSBtYWtlX2JpbmFyeShEYXRhKSBvZlxcclxcbiAgICAgICAgQmluIHdoZW4gaXNfYmluYXJ5KEJpbikgLT5cXHJcXG4gICAgICAgICAgICBjYXNlIGZpbGU6b3BlbihQYXRoLCBNb2RlczEpIG9mXFxyXFxuICAgICAgICAgICAgICAgIHtvaywgSGRsfSAtPlxcclxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBmaWxlOndyaXRlKEhkbCwgQmluKSBvZlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9rIC0+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZmlsZTpzeW5jKEhkbCkgb2ZcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9rIC0+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTpjbG9zZShIZGwpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Vycm9yLCBffSA9IEUgLT5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlOmNsb3NlKEhkbCksXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAge2Vycm9yLCBffSA9IEUgLT5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTpjbG9zZShIZGwpLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFXFxyXFxuICAgICAgICAgICAgICAgICAgICBlbmQ7XFxyXFxuICAgICAgICAgICAgICAgIHtlcnJvciwgX30gPSBFIC0+IEVcXHJcXG4gICAgICAgICAgICBlbmQ7XFxyXFxuICAgICAgICB7ZXJyb3IsIF99ID0gRSAtPiBFXFxyXFxuICAgIGVuZC5cXHJcXG5cXHJcXG5tYWtlX2JpbmFyeShCaW4pIHdoZW4gaXNfYmluYXJ5KEJpbikgLT5cXHJcXG4gICAgQmluO1xcclxcbm1ha2VfYmluYXJ5KExpc3QpIC0+XFxyXFxuICAgIHRyeVxcclxcbiAgICAgICAgaW9saXN0X3RvX2JpbmFyeShMaXN0KVxcclxcbiAgICBjYXRjaCBlcnJvcjpSZWFzb24gLT5cXHJcXG4gICAgICAgICAgICB7ZXJyb3IsIFJlYXNvbn1cXHJcXG4gICAgZW5kLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcImNhbiBiZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSBtdWNoIHNob3J0ZXJcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZXJsYW5nXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIndyaXRlX2ZpbGUoUGF0aCwgRGF0YSwgTW9kZXMpIC0+XFxyXFxuICAgIE1vZGVzMSA9IFtiaW5hcnksIHdyaXRlIHwgKE1vZGVzIC0tIFtiaW5hcnksIHdyaXRlXSldLFxcclxcbiAgICBkbyhbZXJyb3JfbSB8fFxcclxcbiAgICAgICAgQmluIDwtIG1ha2VfYmluYXJ5KERhdGEpLFxcclxcbiAgICAgICAge29rLCBIZGx9IDwtIGZpbGU6b3BlbihQYXRoLCBNb2RlczEpLFxcclxcbiAgICAgICAge29rLCBSZXN1bHR9IDwtIHJldHVybihkbyhbZXJyb3JfbSB8fFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9rIDwtIGZpbGU6d3JpdGUoSGRsLCBCaW4pLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6c3luYyhIZGwpXSkpLFxcclxcbiAgICAgICAgZmlsZTpjbG9zZShIZGwpLFxcclxcbiAgICAgICAgUmVzdWx0XSkuXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJOb3RlIHRoYXQgd2UgaGF2ZSBhIG5lc3RlZCBkby1ibG9jayBzbyB0aGF0LCBhcyB3aXRoIHRoZSBub24tbW9uYWRpY1xcclxcbmNvZGUsIHdlIGVuc3VyZSB0aGF0IG9uY2UgdGhlIGZpbGUgaXMgb3BlbmVkLCB3ZSBhbHdheXMgY2FsbFxcclxcblwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZmlsZTpjbG9zZS8xXCJcbiAgICAgIH0pLCBcIiBldmVuIGlmIGFuIGVycm9yIG9jY3VycyBpbiBhIHN1YnNlcXVlbnQgb3BlcmF0aW9uLiBUaGlzXFxyXFxuaXMgYWNoaWV2ZWQgYnkgd3JhcHBpbmcgdGhlIG5lc3RlZCBkby1ibG9jayB3aXRoIGEgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJyZXR1cm4vMVwiXG4gICAgICB9KSwgXCIgY2FsbDpcXHJcXG5ldmVuIGlmIHRoZSBpbm5lciBkby1ibG9jayBlcnJvcnMsIHRoZSBlcnJvciBpcyBcIiwgX2pzeChfY29tcG9uZW50cy5lbSwge1xuICAgICAgICBjaGlsZHJlbjogXCJsaWZ0ZWRcIlxuICAgICAgfSksIFwiIHRvIGFcXHJcXG5ub24tZXJyb3IgdmFsdWUgaW4gdGhlIG91dGVyIGRvLWJsb2NrLCBhbmQgdGh1cyBleGVjdXRpb24gY29udGludWVzIHRvXFxyXFxudGhlIHN1YnNlcXVlbnQgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJmaWxlOmNsb3NlLzFcIlxuICAgICAgfSksIFwiIGNhbGwuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJIZXJlIHdlIGFyZSB1c2luZyBhbiBFcnJvci1tb25hZCB3aGljaCBpcyByZW1hcmthYmx5IHNpbWlsYXIgdG8gdGhlXFxyXFxuTWF5YmUtbW9uYWQsIGJ1dCBtYXRjaGVzIHRoZSB0eXBpY2FsIEVybGFuZyBwcmFjdGljZSBvZiBpbmRpY2F0aW5nXFxyXFxuZXJyb3JzIGJ5IGFuIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwie2Vycm9yLCBSZWFzb259XCJcbiAgICAgIH0pLCBcIiB0dXBsZTpcIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCItbW9kdWxlKGVycm9yX20pLlxcclxcbi1iZWhhdmlvdXIobW9uYWQpLlxcclxcbi1leHBvcnQoWyc+Pj0nLzIsIHJldHVybi8xLCBmYWlsLzFdKS5cXHJcXG5cXHJcXG4nPj49Jyh7ZXJyb3IsIF9FcnJ9ID0gRXJyb3IsIF9GdW4pIC0+IEVycm9yO1xcclxcbic+Pj0nKFJlc3VsdCwgICAgICAgICAgICAgICAgIEZ1bikgLT4gRnVuKFJlc3VsdCkuXFxyXFxuXFxyXFxucmV0dXJuKFgpIC0+IHtvaywgICAgWH0uXFxyXFxuZmFpbChYKSAgIC0+IHtlcnJvciwgWH0uXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDQsIHtcbiAgICAgIGlkOiBcIm1vbmFkLXRyYW5zZm9ybWVyc1wiLFxuICAgICAgY2hpbGRyZW46IFwiTW9uYWQgVHJhbnNmb3JtZXJzXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIk1vbmFkcyBjYW4gYmUgXCIsIF9qc3goX2NvbXBvbmVudHMuZW0sIHtcbiAgICAgICAgY2hpbGRyZW46IFwibmVzdGVkXCJcbiAgICAgIH0pLCBcIiBieSBoYXZpbmcgZG8tYmxvY2tzIGluc2lkZSBkby1ibG9ja3MsIGFuZFxcclxcblwiLCBfanN4KF9jb21wb25lbnRzLmVtLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcInBhcmFtZXRlcml6ZWRcIlxuICAgICAgfSksIFwiIGJ5IGRlZmluaW5nIGEgbW9uYWQgYXMgYSB0cmFuc2Zvcm1hdGlvbiBvZiBhbm90aGVyLCBpbm5lcixcXHJcXG5tb25hZC4gVGhlIFN0YXRlIFRyYW5zZm9ybSBpcyBhIHZlcnkgY29tbW9ubHkgdXNlZCBtb25hZCB0cmFuc2Zvcm1lcixcXHJcXG5hbmQgaXMgZXNwZWNpYWxseSByZWxldmFudCBmb3IgRXJsYW5nLiBCZWNhdXNlIEVybGFuZyBpcyBhXFxyXFxuc2luZ2xlLWFzc2lnbm1lbnQgbGFuZ3VhZ2UsIGl0J3MgdmVyeSBjb21tb24gdG8gZW5kIHVwIHdpdGggYSBsb3Qgb2ZcXHJcXG5jb2RlIHRoYXQgaW5jcmVtZW50YWxseSBudW1iZXJzIHZhcmlhYmxlczpcIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWVybGFuZ1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJTdGF0ZTEgPSBpbml0KERpbWVuc2lvbnMpLFxcclxcblN0YXRlMiA9IHBsYW50X3NlZWRzKFNlZWRDb3VudCwgU3RhdGUxKSxcXHJcXG57RGlkRmxvb2QsIFN0YXRlM30gPSBwb3VyX29uX3dhdGVyKFdhdGVyVm9sdW1lLCBTdGF0ZTIpLFxcclxcblN0YXRlNCA9IGFwcGx5X3N1bmxpZ2h0KFRpbWUsIFN0YXRlMyksXFxyXFxue0RpZEZsb29kMiwgU3RhdGU1fSA9IHBvdXJfb25fd2F0ZXIoV2F0ZXJWb2x1bWUsIFN0YXRlNCksXFxyXFxue0Nyb3AsIFN0YXRlNn0gPSBoYXJ2ZXN0KFN0YXRlNSksXFxyXFxuICAgIC4uLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiVGhpcyBpcyBkb3VibHkgYW5ub3lpbmcsIG5vdCBvbmx5IGJlY2F1c2UgaXQgbG9va3MgYXdmdWwsIGJ1dCBhbHNvXFxyXFxuYmVjYXVzZSB5b3UgaGF2ZSB0byByZS1udW1iZXIgbWFueSB2YXJpYWJsZXMgYW5kIHJlZmVyZW5jZXMgd2hlbmV2ZXIgYVxcclxcbmxpbmUgaXMgYWRkZWQgb3IgcmVtb3ZlZC4gV291bGRuJ3QgaXQgYmUgbmljZSBpZiB3ZSBjb3VsZCBhYnN0cmFjdCBvdXQgdGhlXFxyXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJTdGF0ZVwiXG4gICAgICB9KSwgXCI/IFdlIGNvdWxkIHRoZW4gaGF2ZSBhIG1vbmFkIGVuY2Fwc3VsYXRlIHRoZSBzdGF0ZSBhbmQgcHJvdmlkZVxcclxcbml0IHRvIChhbmQgY29sbGVjdCBpdCBmcm9tKSB0aGUgZnVuY3Rpb25zIHdlIHdpc2ggdG8gcnVuLlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiT3VyIGltcGxlbWVudGF0aW9uIG9mIG1vbmFkLXRyYW5zZm9ybWVycyAobGlrZSBTdGF0ZSkgdXNlcyBhIFxcXCJoaWRkZW4gZmVhdHVyZVxcXCJcXHJcXG5vZiB0aGUgRXJsYW5nIGRpc3RyaWJ1dGlvbiBjYWxsZWQgXCIsIF9qc3goX2NvbXBvbmVudHMuZW0sIHtcbiAgICAgICAgY2hpbGRyZW46IFwicGFyYW1ldGVyaXplZCBtb2R1bGVzXCJcbiAgICAgIH0pLCBcIi4gVGhlc2UgYXJlXFxyXFxuZGVzY3JpYmVkIGluIFwiLCBfanN4KF9jb21wb25lbnRzLmEsIHtcbiAgICAgICAgaHJlZjogXCJodHRwOi8vZnRwLnN1bmV0LnNlL3B1Yi9sYW5nL2VybGFuZy93b3Jrc2hvcC8yMDAzL3BhcGVyL3AyOS1jYXJsc3Nvbi5wZGZcIixcbiAgICAgICAgY2hpbGRyZW46IFwiUGFyYW1ldGVyaXplZCBNb2R1bGVzIGluIEVybGFuZ1wiXG4gICAgICB9KSwgXCIuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJUaGUgU3RhdGUtdHJhbnNmb3JtIGNhbiBiZSBhcHBsaWVkIHRvIGFueSBtb25hZC4gSWYgd2UgYXBwbHkgaXQgdG8gdGhlXFxyXFxuSWRlbnRpdHktbW9uYWQgdGhlbiB3ZSBnZXQgd2hhdCB3ZSdyZSBsb29raW5nIGZvci4gVGhlIGtleSBleHRyYVxcclxcbmZ1bmN0aW9uYWxpdHkgdGhhdCB0aGUgU3RhdGUgdHJhbnNmb3JtZXIgcHJvdmlkZXMgdXMgd2l0aCBpcyB0aGVcXHJcXG5hYmlsaXR5IHRvIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZ2V0XCJcbiAgICAgIH0pLCBcIiBhbmQgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJzZXRcIlxuICAgICAgfSksIFwiIChvciBqdXN0IHBsYWluIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwibW9kaWZ5XCJcbiAgICAgIH0pLCBcIikgc3RhdGUgZnJvbSB3aXRoaW5cXHJcXG50aGUgaW5uZXIgbW9uYWQuIElmIHdlIHVzZSBib3RoIHRoZSBEbyBhbmQgQ3V0IHBhcnNlIHRyYW5zZm9ybWVycywgd2VcXHJcXG5jYW4gd3JpdGU6XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1lcmxhbmdcIixcbiAgICAgICAgY2hpbGRyZW46IFwiU3RhdGVUID0gc3RhdGVfdDpuZXcoaWRlbnRpdHlfbSksXFxyXFxuU00gPSBTdGF0ZVQ6bW9kaWZ5KF8pLFxcclxcblNNUiA9IFN0YXRlVDptb2RpZnlfYW5kX3JldHVybihfKSxcXHJcXG5TdGF0ZVQ6ZXhlYyhcXHJcXG4gICAgZG8oW1N0YXRlVCB8fFxcclxcblxcclxcbiAgICAgICAgU3RhdGVUOnB1dChpbml0KERpbWVuc2lvbnMpKSxcXHJcXG4gICAgICAgIFNNKHBsYW50X3NlZWRzKFNlZWRDb3VudCwgXykpLFxcclxcbiAgICAgICAgRGlkRmxvb2QgPC0gU01SKHBvdXJfb25fd2F0ZXIoV2F0ZXJWb2x1bWUsIF8pKSxcXHJcXG4gICAgICAgIFNNKGFwcGx5X3N1bmxpZ2h0KFRpbWUsIF8pKSxcXHJcXG4gICAgICAgIERpZEZsb29kMiA8LSBTTVIocG91cl9vbl93YXRlcihXYXRlclZvbHVtZSwgXykpLFxcclxcbiAgICAgICAgQ3JvcCA8LSBTTVIoaGFydmVzdChfKSksXFxyXFxuICAgICAgICAuLi5cXHJcXG5cXHJcXG4gICAgICAgIF0pLCB1bmRlZmluZWQpLlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIldlIHN0YXJ0IGJ5IGNyZWF0aW5nIGEgU3RhdGUtdHJhbnNmb3JtIG92ZXIgdGhlIElkZW50aXR5LW1vbmFkLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJUaGlzIGlzIHRoZSBzeW50YXggZm9yIFwiLCBfanN4KF9jb21wb25lbnRzLmVtLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImluc3RhbnRpYXRpbmdcIlxuICAgICAgfSksIFwiIHBhcmFtZXRlcml6ZWQgbW9kdWxlcy4gXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJTdGF0ZVRcIlxuICAgICAgfSksIFwiIGlzIGFcXHJcXG52YXJpYWJsZSByZWZlcmVuY2luZyBhIG1vZHVsZSBpbnN0YW5jZSB3aGljaCwgaW4gdGhpcyBjYXNlLCBpcyBhIG1vbmFkLlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiV2Ugc2V0IHVwIHR3byBzaG9ydGhhbmRzIGZvciBydW5uaW5nIGZ1bmN0aW9ucyB0aGF0IGVpdGhlciBqdXN0XFxyXFxubW9kaWZ5IHRoZSBzdGF0ZSwgb3IgbW9kaWZ5IHRoZSBzdGF0ZSBcIiwgX2pzeChfY29tcG9uZW50cy5lbSwge1xuICAgICAgICBjaGlsZHJlbjogXCJhbmRcIlxuICAgICAgfSksIFwiIHJldHVybiBhIHJlc3VsdC4gV2hpbHN0XFxyXFxudGhlcmUncyBhIGJpdCBvZiBib29ra2VlcGluZyB0byBkbywgd2UgYWNoaWV2ZSBvdXIgZ29hbDogdGhlcmUgYXJlIG5vXFxyXFxuc3RhdGUgdmFyaWFibGVzIG5vdyB0byByZW51bWJlciB3aGVuZXZlciB3ZSBtYWtlIGEgY2hhbmdlOiB3ZSB1c2UgY3V0XFxyXFxudG8gbGVhdmUgaG9sZXMgaW4gdGhlIGZ1bmN0aW9ucyB3aGVyZSBTdGF0ZSBzaG91bGQgYmUgZmVkIGluLCBhbmQgd2VcXHJcXG5vYmV5IHRoZSBwcm90b2NvbCB0aGF0IGlmIGZ1bmN0aW9ucyByZXR1cm4gYm90aCBhIHJlc3VsdCBhbmQgc3RhdGUsIGl0XFxyXFxuc2hvdWxkIGJlIGluIHRoZSBmb3JtIG9mIGEgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJ7UmVzdWx0LCBTdGF0ZX1cIlxuICAgICAgfSksIFwiIHR1cGxlLiBUaGVcXHJcXG5TdGF0ZS10cmFuc2Zvcm0gZG9lcyB0aGUgcmVzdC5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMywge1xuICAgICAgaWQ6IFwiYmV5b25kLW1vbmFkc1wiLFxuICAgICAgY2hpbGRyZW46IFwiQmV5b25kIE1vbmFkc1wiXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJUaGVyZSBhcmUgc29tZSBzdGFuZGFyZCBtb25hZCBmdW5jdGlvbnMgc3VjaCBhcyBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImpvaW4vMlwiXG4gICAgICB9KSwgXCIgYW5kXFxyXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJzZXF1ZW5jZS8yXCJcbiAgICAgIH0pLCBcIiBhdmFpbGFibGUgaW4gdGhlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwibW9uYWRcIlxuICAgICAgfSksIFwiIG1vZHVsZS4gV2UgaGF2ZSBhbHNvIGltcGxlbWVudGVkXFxyXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJtb25hZF9wbHVzXCJcbiAgICAgIH0pLCBcIiB3aGljaCB3b3JrcyBmb3IgbW9uYWRzIHdoZXJlIHRoZXJlJ3MgYW4gb2J2aW91cyBzZW5zZSBvZlxcclxcblwiLCBfanN4KF9jb21wb25lbnRzLmVtLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcInplcm9cIlxuICAgICAgfSksIFwiICBhbmQgXCIsIF9qc3goX2NvbXBvbmVudHMuZW0sIHtcbiAgICAgICAgY2hpbGRyZW46IFwicGx1c1wiXG4gICAgICB9KSwgXCIgKGN1cnJlbnRseSBNYXliZS1tb25hZCwgTGlzdC1tb25hZCwgYW5kIE9tZWdhLW1vbmFkKS5cXHJcXG5UaGUgYXNzb2NpYXRlZCBmdW5jdGlvbnMgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJndWFyZFwiXG4gICAgICB9KSwgXCIsIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwibXN1bVwiXG4gICAgICB9KSwgXCIgYW5kIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwibWZpbHRlclwiXG4gICAgICB9KSwgXCIgYXJlIGF2YWlsYWJsZVxcclxcbmluIHRoZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIm1vbmFkX3BsdXNcIlxuICAgICAgfSksIFwiIG1vZHVsZS5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbiBtYW55IGNhc2VzLCBhIGZhaXJseSBtZWNoYW5pY2FsIHRyYW5zbGF0aW9uIGZyb20gSGFza2VsbCB0byBFcmxhbmdcXHJcXG5pcyBwb3NzaWJsZSwgc28gaW4gbWFueSBjYXNlcyBjb252ZXJ0aW5nIG90aGVyIG1vbmFkcyBvciBjb21iaW5hdG9ycyBzaG91bGRcXHJcXG5iZSBzdHJhaWdodGZvcndhcmQuIEhvd2V2ZXIsIHRoZSBsYWNrIG9mIHR5cGUgY2xhc3NlcyBpbiBFcmxhbmcgaXMgbGltaXRpbmcuXCJcbiAgICB9KV1cbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzID0ge30pIHtcbiAgY29uc3Qge3dyYXBwZXI6IE1EWExheW91dH0gPSB7XG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gTURYTGF5b3V0ID8gX2pzeChNRFhMYXlvdXQsIHtcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogX2pzeChfY3JlYXRlTWR4Q29udGVudCwge1xuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICB9KSA6IF9jcmVhdGVNZHhDb250ZW50KHByb3BzKTtcbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./blog/2011-05-17-can-you-hear-the-drums-erlando/index.md\n");

/***/ }),

/***/ "./node_modules/@mdx-js/react/lib/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MDXProvider: () => (/* binding */ MDXProvider),\n/* harmony export */   useMDXComponents: () => (/* binding */ useMDXComponents)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/**\n * @import {MDXComponents} from 'mdx/types.js'\n * @import {Component, ReactElement, ReactNode} from 'react'\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\n\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nfunction useMDXComponents(components) {\n  const contextComponents = react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {ReactElement}\n *   Element.\n * @satisfies {Component}\n */\nfunction MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JhYmJpdG1xLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9saWIvaW5kZXguanM/MjA0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge01EWENvbXBvbmVudHN9IGZyb20gJ21keC90eXBlcy5qcydcbiAqIEBpbXBvcnQge0NvbXBvbmVudCwgUmVhY3RFbGVtZW50LCBSZWFjdE5vZGV9IGZyb20gJ3JlYWN0J1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIE1lcmdlQ29tcG9uZW50c1xuICogICBDdXN0b20gbWVyZ2UgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1JlYWRvbmx5PE1EWENvbXBvbmVudHM+fSBjdXJyZW50Q29tcG9uZW50c1xuICogICBDdXJyZW50IGNvbXBvbmVudHMgZnJvbSB0aGUgY29udGV4dC5cbiAqIEByZXR1cm5zIHtNRFhDb21wb25lbnRzfVxuICogICBBZGRpdGlvbmFsIGNvbXBvbmVudHMuXG4gKlxuICogQHR5cGVkZWYgUHJvcHNcbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgYE1EWFByb3ZpZGVyYC5cbiAqIEBwcm9wZXJ0eSB7UmVhY3ROb2RlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2NoaWxkcmVuXVxuICogICBDaGlsZHJlbiAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtSZWFkb25seTxNRFhDb21wb25lbnRzPiB8IE1lcmdlQ29tcG9uZW50cyB8IG51bGwgfCB1bmRlZmluZWR9IFtjb21wb25lbnRzXVxuICogICBBZGRpdGlvbmFsIGNvbXBvbmVudHMgdG8gdXNlIG9yIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZW0gKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtkaXNhYmxlUGFyZW50Q29udGV4dD1mYWxzZV1cbiAqICAgVHVybiBvZmYgb3V0ZXIgY29tcG9uZW50IGNvbnRleHQgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuLyoqIEB0eXBlIHtSZWFkb25seTxNRFhDb21wb25lbnRzPn0gKi9cbmNvbnN0IGVtcHR5Q29tcG9uZW50cyA9IHt9XG5cbmNvbnN0IE1EWENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGVtcHR5Q29tcG9uZW50cylcblxuLyoqXG4gKiBHZXQgY3VycmVudCBjb21wb25lbnRzIGZyb20gdGhlIE1EWCBDb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHk8TURYQ29tcG9uZW50cz4gfCBNZXJnZUNvbXBvbmVudHMgfCBudWxsIHwgdW5kZWZpbmVkfSBbY29tcG9uZW50c11cbiAqICAgQWRkaXRpb25hbCBjb21wb25lbnRzIHRvIHVzZSBvciBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVtIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7TURYQ29tcG9uZW50c31cbiAqICAgQ3VycmVudCBjb21wb25lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTURYQ29tcG9uZW50cyhjb21wb25lbnRzKSB7XG4gIGNvbnN0IGNvbnRleHRDb21wb25lbnRzID0gUmVhY3QudXNlQ29udGV4dChNRFhDb250ZXh0KVxuXG4gIC8vIE1lbW9pemUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgdG9wLWxldmVsIGNvbnRleHQgY2hhbmdlc1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDdXN0b20gbWVyZ2UgdmlhIGEgZnVuY3Rpb24gcHJvcFxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzKGNvbnRleHRDb21wb25lbnRzKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gey4uLmNvbnRleHRDb21wb25lbnRzLCAuLi5jb21wb25lbnRzfVxuICAgIH0sXG4gICAgW2NvbnRleHRDb21wb25lbnRzLCBjb21wb25lbnRzXVxuICApXG59XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIE1EWCBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHk8UHJvcHM+fSBwcm9wZXJ0aWVzXG4gKiAgIFByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7UmVhY3RFbGVtZW50fVxuICogICBFbGVtZW50LlxuICogQHNhdGlzZmllcyB7Q29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gTURYUHJvdmlkZXIocHJvcGVydGllcykge1xuICAvKiogQHR5cGUge1JlYWRvbmx5PE1EWENvbXBvbmVudHM+fSAqL1xuICBsZXQgYWxsQ29tcG9uZW50c1xuXG4gIGlmIChwcm9wZXJ0aWVzLmRpc2FibGVQYXJlbnRDb250ZXh0KSB7XG4gICAgYWxsQ29tcG9uZW50cyA9XG4gICAgICB0eXBlb2YgcHJvcGVydGllcy5jb21wb25lbnRzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcHJvcGVydGllcy5jb21wb25lbnRzKGVtcHR5Q29tcG9uZW50cylcbiAgICAgICAgOiBwcm9wZXJ0aWVzLmNvbXBvbmVudHMgfHwgZW1wdHlDb21wb25lbnRzXG4gIH0gZWxzZSB7XG4gICAgYWxsQ29tcG9uZW50cyA9IHVzZU1EWENvbXBvbmVudHMocHJvcGVydGllcy5jb21wb25lbnRzKVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgTURYQ29udGV4dC5Qcm92aWRlcixcbiAgICB7dmFsdWU6IGFsbENvbXBvbmVudHN9LFxuICAgIHByb3BlcnRpZXMuY2hpbGRyZW5cbiAgKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@mdx-js/react/lib/index.js\n");

/***/ })

}]);