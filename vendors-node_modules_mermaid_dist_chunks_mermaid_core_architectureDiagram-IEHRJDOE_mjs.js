/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkrabbitmq_website"] = globalThis["webpackChunkrabbitmq_website"] || []).push([["vendors-node_modules_mermaid_dist_chunks_mermaid_core_architectureDiagram-IEHRJDOE_mjs"],{

/***/ "./node_modules/cytoscape-fcose/cytoscape-fcose.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(\"./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 658:\n/***/ ((module) => {\n\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n\n/***/ 548:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1129__) => {\n\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/*\n * Auxiliary functions\n */\n\nvar LinkedList = __nested_webpack_require_1129__(140).layoutBase.LinkedList;\n\nvar auxiliary = {};\n\n// get the top most nodes\nauxiliary.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n// find disconnected components and create dummy nodes that connect them\nauxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n  var queue = new LinkedList();\n  var visited = new Set();\n  var visitedTopMostNodes = [];\n  var currentNeighbor = void 0;\n  var minDegreeNode = void 0;\n  var minDegree = void 0;\n\n  var isConnected = false;\n  var count = 1;\n  var nodesConnectedToDummy = [];\n  var components = [];\n\n  var _loop = function _loop() {\n    var cmpt = cy.collection();\n    components.push(cmpt);\n\n    var currentNode = topMostNodes[0];\n    var childrenOfCurrentNode = cy.collection();\n    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n    visitedTopMostNodes.push(currentNode);\n\n    childrenOfCurrentNode.forEach(function (node) {\n      queue.push(node);\n      visited.add(node);\n      cmpt.merge(node);\n    });\n\n    var _loop2 = function _loop2() {\n      currentNode = queue.shift();\n\n      // Traverse all neighbors of this node\n      var neighborNodes = cy.collection();\n      currentNode.neighborhood().nodes().forEach(function (node) {\n        if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n          neighborNodes.merge(node);\n        }\n      });\n\n      for (var i = 0; i < neighborNodes.length; i++) {\n        var neighborNode = neighborNodes[i];\n        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n\n          childrenOfNeighbor.forEach(function (node) {\n            queue.push(node);\n            visited.add(node);\n            cmpt.merge(node);\n            if (topMostNodes.has(node)) {\n              visitedTopMostNodes.push(node);\n            }\n          });\n        }\n      }\n    };\n\n    while (queue.length != 0) {\n      _loop2();\n    }\n\n    cmpt.forEach(function (node) {\n      eles.intersection(node.connectedEdges()).forEach(function (e) {\n        // connectedEdges() usually cached\n        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n          // has() is cheap\n          cmpt.merge(e);\n        }\n      });\n    });\n\n    if (visitedTopMostNodes.length == topMostNodes.length) {\n      isConnected = true;\n    }\n\n    if (!isConnected || isConnected && count > 1) {\n      minDegreeNode = visitedTopMostNodes[0];\n      minDegree = minDegreeNode.connectedEdges().length;\n      visitedTopMostNodes.forEach(function (node) {\n        if (node.connectedEdges().length < minDegree) {\n          minDegree = node.connectedEdges().length;\n          minDegreeNode = node;\n        }\n      });\n      nodesConnectedToDummy.push(minDegreeNode.id());\n      // TO DO: Check efficiency of this part\n      var temp = cy.collection();\n      temp.merge(visitedTopMostNodes[0]);\n      visitedTopMostNodes.forEach(function (node) {\n        temp.merge(node);\n      });\n      visitedTopMostNodes = [];\n      topMostNodes = topMostNodes.difference(temp);\n      count++;\n    }\n  };\n\n  do {\n    _loop();\n  } while (!isConnected);\n\n  if (dummyNodes) {\n    if (nodesConnectedToDummy.length > 0) {\n      dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n    }\n  }\n  return components;\n};\n\n// relocates componentResult to originalCenter if there is no fixedNodeConstraint\nauxiliary.relocateComponent = function (originalCenter, componentResult, options) {\n  if (!options.fixedNodeConstraint) {\n    var minXCoord = Number.POSITIVE_INFINITY;\n    var maxXCoord = Number.NEGATIVE_INFINITY;\n    var minYCoord = Number.POSITIVE_INFINITY;\n    var maxYCoord = Number.NEGATIVE_INFINITY;\n    if (options.quality == \"draft\") {\n      // calculate current bounding box\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          var key = _ref2[0];\n          var value = _ref2[1];\n\n          var cyNode = options.cy.getElementById(key);\n          if (cyNode) {\n            var nodeBB = cyNode.boundingBox();\n            var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n            var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n            var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n            var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n\n            if (leftX < minXCoord) minXCoord = leftX;\n            if (rightX > maxXCoord) maxXCoord = rightX;\n            if (topY < minYCoord) minYCoord = topY;\n            if (bottomY > maxYCoord) maxYCoord = bottomY;\n          }\n        }\n        // find difference between current and original center\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      componentResult.xCoords = componentResult.xCoords.map(function (x) {\n        return x + diffOnX;\n      });\n      componentResult.yCoords = componentResult.yCoords.map(function (y) {\n        return y + diffOnY;\n      });\n    } else {\n      // calculate current bounding box\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        var leftX = node.getRect().x;\n        var rightX = node.getRect().x + node.getRect().width;\n        var topY = node.getRect().y;\n        var bottomY = node.getRect().y + node.getRect().height;\n\n        if (leftX < minXCoord) minXCoord = leftX;\n        if (rightX > maxXCoord) maxXCoord = rightX;\n        if (topY < minYCoord) minYCoord = topY;\n        if (bottomY > maxYCoord) maxYCoord = bottomY;\n      });\n      // find difference between current and original center\n      var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n      });\n    }\n  }\n};\n\nauxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n  // calculate bounds\n  var left = Number.MAX_SAFE_INTEGER;\n  var right = Number.MIN_SAFE_INTEGER;\n  var top = Number.MAX_SAFE_INTEGER;\n  var bottom = Number.MIN_SAFE_INTEGER;\n  var nodeLeft = void 0;\n  var nodeRight = void 0;\n  var nodeTop = void 0;\n  var nodeBottom = void 0;\n\n  var nodes = parentNode.descendants().not(\":parent\");\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var node = nodes[i];\n\n    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingBox = {};\n  boundingBox.topLeftX = left;\n  boundingBox.topLeftY = top;\n  boundingBox.width = right - left;\n  boundingBox.height = bottom - top;\n  return boundingBox;\n};\n\n// This function finds and returns parent nodes whose all children are hidden\nauxiliary.calcParentsWithoutChildren = function (cy, eles) {\n  var parentsWithoutChildren = cy.collection();\n  eles.nodes(':parent').forEach(function (parent) {\n    var check = false;\n    parent.children().forEach(function (child) {\n      if (child.css('display') != 'none') {\n        check = true;\n      }\n    });\n    if (!check) {\n      parentsWithoutChildren.merge(parent);\n    }\n  });\n\n  return parentsWithoutChildren;\n};\n\nmodule.exports = auxiliary;\n\n/***/ }),\n\n/***/ 816:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_10973__) => {\n\n\n\n/**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/\n\nvar aux = __nested_webpack_require_10973__(548);\nvar CoSELayout = __nested_webpack_require_10973__(140).CoSELayout;\nvar CoSENode = __nested_webpack_require_10973__(140).CoSENode;\nvar PointD = __nested_webpack_require_10973__(140).layoutBase.PointD;\nvar DimensionD = __nested_webpack_require_10973__(140).layoutBase.DimensionD;\nvar LayoutConstants = __nested_webpack_require_10973__(140).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __nested_webpack_require_10973__(140).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __nested_webpack_require_10973__(140).CoSEConstants;\n\n// main function that cose layout is processed\nvar coseLayout = function coseLayout(options, spectralResult) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n\n  var nodeIndexes = void 0;\n  var xCoords = void 0;\n  var yCoords = void 0;\n  var idToLNode = {};\n\n  if (options.randomize) {\n    nodeIndexes = spectralResult[\"nodeIndexes\"];\n    xCoords = spectralResult[\"xCoords\"];\n    yCoords = spectralResult[\"yCoords\"];\n  }\n\n  var isFn = function isFn(fn) {\n    return typeof fn === 'function';\n  };\n\n  var optFn = function optFn(opt, ele) {\n    if (isFn(opt)) {\n      return opt(ele);\n    } else {\n      return opt;\n    }\n  };\n\n  /**** Postprocessing functions ****/\n\n  var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n\n  // transfer cytoscape nodes to cose nodes\n  var processChildrenList = function processChildrenList(parent, children, layout, options) {\n    var size = children.length;\n    for (var i = 0; i < size; i++) {\n      var theChild = children[i];\n      var children_of_children = null;\n      if (theChild.intersection(parentsWithoutChildren).length == 0) {\n        children_of_children = theChild.children();\n      }\n      var theNode = void 0;\n\n      var dimensions = theChild.layoutDimensions({\n        nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n      });\n\n      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n        if (options.randomize) {\n          if (!theChild.isParent()) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n            } else {\n              // for the parentsWithoutChildren\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n            }\n          }\n        } else {\n          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n        }\n      } else {\n        theNode = parent.add(new CoSENode(this.graphManager));\n      }\n      // Attach id to the layout node and repulsion value\n      theNode.id = theChild.data(\"id\");\n      theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n      // Attach the paddings of cy node to layout node\n      theNode.paddingLeft = parseInt(theChild.css('padding'));\n      theNode.paddingTop = parseInt(theChild.css('padding'));\n      theNode.paddingRight = parseInt(theChild.css('padding'));\n      theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n      //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n      //These properties will be used while updating bounds of compounds during iterations or tiling\n      //and will be used for simple nodes while transferring final positions to cytoscape\n      if (options.nodeDimensionsIncludeLabels) {\n        theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;\n        theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;\n        theNode.labelPosVertical = theChild.css(\"text-valign\");\n        theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n      }\n\n      // Map the layout node\n      idToLNode[theChild.data(\"id\")] = theNode;\n\n      if (isNaN(theNode.rect.x)) {\n        theNode.rect.x = 0;\n      }\n\n      if (isNaN(theNode.rect.y)) {\n        theNode.rect.y = 0;\n      }\n\n      if (children_of_children != null && children_of_children.length > 0) {\n        var theNewGraph = void 0;\n        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n        processChildrenList(theNewGraph, children_of_children, layout, options);\n      }\n    }\n  };\n\n  // transfer cytoscape edges to cose edges\n  var processEdges = function processEdges(layout, gm, edges) {\n    var idealLengthTotal = 0;\n    var edgeCount = 0;\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var sourceNode = idToLNode[edge.data(\"source\")];\n      var targetNode = idToLNode[edge.data(\"target\")];\n      if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n        e1.id = edge.id();\n        e1.idealLength = optFn(options.idealEdgeLength, edge);\n        e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n        idealLengthTotal += e1.idealLength;\n        edgeCount++;\n      }\n    }\n    // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n    // in case there is no edge, use other options\n    if (options.idealEdgeLength != null) {\n      if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength)) // in case there is no edge, but option gives a value to use\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else // in case there is no edge and we cannot get a value from option (because it's a function)\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      // we need to update these constant values based on the ideal edge length constant\n      CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    }\n  };\n\n  // transfer cytoscape constraints to cose layout\n  var processConstraints = function processConstraints(layout, options) {\n    // get nodes to be fixed\n    if (options.fixedNodeConstraint) {\n      layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n    }\n    // get nodes to be aligned\n    if (options.alignmentConstraint) {\n      layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n    }\n    // get nodes to be relatively placed\n    if (options.relativePlacementConstraint) {\n      layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n    }\n  };\n\n  /**** Apply postprocessing ****/\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n\n  if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n  CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n  // This part is for debug/demo purpose\n  if (options.step == \"transformed\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"enforced\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"cose\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n  if (options.step == \"all\") {\n    if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n\n  if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n  } else {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n  }\n\n  var coseLayout = new CoSELayout();\n  var gm = coseLayout.newGraphManager();\n\n  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n  processEdges(coseLayout, gm, edges);\n  processConstraints(coseLayout, options);\n\n  coseLayout.runLayout();\n\n  return idToLNode;\n};\n\nmodule.exports = { coseLayout: coseLayout };\n\n/***/ }),\n\n/***/ 212:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_22455__) => {\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n  The implementation of the fcose layout algorithm\n*/\n\nvar assign = __nested_webpack_require_22455__(658);\nvar aux = __nested_webpack_require_22455__(548);\n\nvar _require = __nested_webpack_require_22455__(657),\n    spectralLayout = _require.spectralLayout;\n\nvar _require2 = __nested_webpack_require_22455__(816),\n    coseLayout = _require2.coseLayout;\n\nvar defaults = Object.freeze({\n\n  // 'draft', 'default' or 'proof' \n  // - 'draft' only applies spectral layout \n  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n  quality: \"default\",\n  // Use random node positions at beginning of layout\n  // if this is set to false, then quality option must be \"proof\"\n  randomize: true,\n  // Whether or not to animate the layout\n  animate: true,\n  // Duration of animation in ms, if enabled\n  animationDuration: 1000,\n  // Easing of animation, if enabled\n  animationEasing: undefined,\n  // Fit the viewport to the repositioned nodes\n  fit: true,\n  // Padding around layout\n  padding: 30,\n  // Whether to include labels in node dimensions. Valid in \"proof\" quality\n  nodeDimensionsIncludeLabels: false,\n  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n  uniformNodeDimensions: false,\n  // Whether to pack disconnected components - valid only if randomize: true\n  packComponents: true,\n  // Layout step - all, transformed, enforced, cose - for debug purpose only\n  step: \"all\",\n\n  /* spectral layout options */\n\n  // False for random, true for greedy\n  samplingType: true,\n  // Sample size to construct distance matrix\n  sampleSize: 25,\n  // Separation amount between nodes\n  nodeSeparation: 75,\n  // Power iteration tolerance\n  piTol: 0.0000001,\n\n  /* CoSE layout options */\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 4500;\n  },\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 50;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 0.45;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n  tilingCompareBy: undefined,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout  \n  initialEnergyOnIncremental: 0.3,\n\n  /* constraint options */\n\n  // Fix required nodes to predefined positions\n  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n  fixedNodeConstraint: undefined,\n  // Align required nodes in vertical/horizontal direction\n  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n  alignmentConstraint: undefined,\n  // Place two nodes relatively in vertical/horizontal direction \n  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n  relativePlacementConstraint: undefined,\n\n  /* layout event callbacks */\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n});\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    this.options = assign({}, defaults, options);\n  }\n\n  _createClass(Layout, [{\n    key: 'run',\n    value: function run() {\n      var layout = this;\n      var options = this.options;\n      var cy = options.cy;\n      var eles = options.eles;\n\n      var spectralResult = [];\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var coseResult = [];\n      var components = void 0;\n      var componentCenters = [];\n\n      // basic validity check for constraint inputs \n      if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n        options.fixedNodeConstraint = undefined;\n      }\n\n      if (options.alignmentConstraint) {\n        if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n          options.alignmentConstraint.vertical = undefined;\n        }\n        if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n          options.alignmentConstraint.horizontal = undefined;\n        }\n      }\n\n      if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n        options.relativePlacementConstraint = undefined;\n      }\n\n      // if any constraint exists, set some options\n      var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n      if (constraintExist) {\n        // constraints work with these options\n        options.tile = false;\n        options.packComponents = false;\n      }\n\n      // decide component packing is enabled or not\n      var layUtil = void 0;\n      var packingEnabled = false;\n      if (cy.layoutUtilities && options.packComponents) {\n        layUtil = cy.layoutUtilities(\"get\");\n        if (!layUtil) layUtil = cy.layoutUtilities();\n        packingEnabled = true;\n      }\n\n      if (eles.nodes().length > 0) {\n        // if packing is not enabled, perform layout on the whole graph\n        if (!packingEnabled) {\n          // store component center\n          var boundingBox = options.eles.boundingBox();\n          componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          // apply spectral layout\n          if (options.randomize) {\n            var result = spectralLayout(options);\n            spectralResult.push(result);\n          }\n          // apply cose layout as postprocessing\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            coseResult.push(coseLayout(options, spectralResult[0]));\n            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n          } else {\n            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n          }\n        } else {\n          // packing is enabled\n          var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n          components = aux.connectComponents(cy, options.eles, topMostNodes);\n          // store component centers\n          components.forEach(function (component) {\n            var boundingBox = component.boundingBox();\n            componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          });\n\n          //send each component to spectral layout if randomized\n          if (options.randomize) {\n            components.forEach(function (component) {\n              options.eles = component;\n              spectralResult.push(spectralLayout(options));\n            });\n          }\n\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            var toBeTiledNodes = cy.collection();\n            if (options.tile) {\n              // behave nodes to be tiled as one component\n              var nodeIndexes = new Map();\n              var _xCoords = [];\n              var _yCoords = [];\n              var count = 0;\n              var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n              var indexesToBeDeleted = [];\n              components.forEach(function (component, index) {\n                if (component.edges().length == 0) {\n                  component.nodes().forEach(function (node, i) {\n                    toBeTiledNodes.merge(component.nodes()[i]);\n                    if (!node.isParent()) {\n                      tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                      tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                      tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                    }\n                  });\n                  indexesToBeDeleted.push(index);\n                }\n              });\n              if (toBeTiledNodes.length > 1) {\n                var _boundingBox = toBeTiledNodes.boundingBox();\n                componentCenters.push({ x: _boundingBox.x1 + _boundingBox.w / 2, y: _boundingBox.y1 + _boundingBox.h / 2 });\n                components.push(toBeTiledNodes);\n                spectralResult.push(tempSpectralResult);\n                for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                  components.splice(indexesToBeDeleted[i], 1);\n                  spectralResult.splice(indexesToBeDeleted[i], 1);\n                  componentCenters.splice(indexesToBeDeleted[i], 1);\n                };\n              }\n            }\n            components.forEach(function (component, index) {\n              // send each component to cose layout\n              options.eles = component;\n              coseResult.push(coseLayout(options, spectralResult[index]));\n              aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n            });\n          } else {\n            components.forEach(function (component, index) {\n              aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n            });\n          }\n\n          // packing\n          var componentsEvaluated = new Set();\n          if (components.length > 1) {\n            var subgraphs = [];\n            var hiddenEles = eles.filter(function (ele) {\n              return ele.css('display') == 'none';\n            });\n            components.forEach(function (component, index) {\n              var nodeIndexes = void 0;\n              if (options.quality == \"draft\") {\n                nodeIndexes = spectralResult[index].nodeIndexes;\n              }\n\n              if (component.nodes().not(hiddenEles).length > 0) {\n                var subgraph = {};\n                subgraph.edges = [];\n                subgraph.nodes = [];\n                var nodeIndex = void 0;\n                component.nodes().not(hiddenEles).forEach(function (node) {\n                  if (options.quality == \"draft\") {\n                    if (!node.isParent()) {\n                      nodeIndex = nodeIndexes.get(node.id());\n                      subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n                    } else {\n                      var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                      subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n                    }\n                  } else {\n                    if (coseResult[index][node.id()]) {\n                      subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n                    }\n                  }\n                });\n                component.edges().forEach(function (edge) {\n                  var source = edge.source();\n                  var target = edge.target();\n                  if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                    if (options.quality == \"draft\") {\n                      var sourceNodeIndex = nodeIndexes.get(source.id());\n                      var targetNodeIndex = nodeIndexes.get(target.id());\n                      var sourceCenter = [];\n                      var targetCenter = [];\n                      if (source.isParent()) {\n                        var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                        sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                      } else {\n                        sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                        sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                      }\n                      if (target.isParent()) {\n                        var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                        targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                      } else {\n                        targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                        targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                      }\n                      subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n                    } else {\n                      if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                        subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n                      }\n                    }\n                  }\n                });\n                if (subgraph.nodes.length > 0) {\n                  subgraphs.push(subgraph);\n                  componentsEvaluated.add(index);\n                }\n              }\n            });\n            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n            if (options.quality == \"draft\") {\n              spectralResult.forEach(function (result, index) {\n                var newXCoords = result.xCoords.map(function (x) {\n                  return x + shiftResult[index].dx;\n                });\n                var newYCoords = result.yCoords.map(function (y) {\n                  return y + shiftResult[index].dy;\n                });\n                result.xCoords = newXCoords;\n                result.yCoords = newYCoords;\n              });\n            } else {\n              var _count = 0;\n              componentsEvaluated.forEach(function (index) {\n                Object.keys(coseResult[index]).forEach(function (item) {\n                  var nodeRectangle = coseResult[index][item];\n                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                });\n                _count++;\n              });\n            }\n          }\n        }\n      }\n\n      // get each element's calculated position\n      var getPositions = function getPositions(ele, i) {\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n          var pos = void 0;\n          var node = void 0;\n          var theId = ele.data('id');\n          coseResult.forEach(function (result) {\n            if (theId in result) {\n              pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };\n              node = result[theId];\n            }\n          });\n          if (options.nodeDimensionsIncludeLabels) {\n            if (node.labelWidth) {\n              if (node.labelPosHorizontal == \"left\") {\n                pos.x += node.labelWidth / 2;\n              } else if (node.labelPosHorizontal == \"right\") {\n                pos.x -= node.labelWidth / 2;\n              }\n            }\n            if (node.labelHeight) {\n              if (node.labelPosVertical == \"top\") {\n                pos.y += node.labelHeight / 2;\n              } else if (node.labelPosVertical == \"bottom\") {\n                pos.y -= node.labelHeight / 2;\n              }\n            }\n          }\n          if (pos == undefined) pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: pos.x,\n            y: pos.y\n          };\n        } else {\n          var _pos = void 0;\n          spectralResult.forEach(function (result) {\n            var index = result.nodeIndexes.get(ele.id());\n            if (index != undefined) {\n              _pos = { x: result.xCoords[index], y: result.yCoords[index] };\n            }\n          });\n          if (_pos == undefined) _pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: _pos.x,\n            y: _pos.y\n          };\n        }\n      };\n\n      // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n      if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n        // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n        var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n        var _hiddenEles = eles.filter(function (ele) {\n          return ele.css('display') == 'none';\n        });\n        options.eles = eles.not(_hiddenEles);\n\n        eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n\n        if (parentsWithoutChildren.length > 0) {\n          parentsWithoutChildren.forEach(function (ele) {\n            ele.position(getPositions(ele));\n          });\n        }\n      } else {\n        console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n\n/***/ 657:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_41986__) => {\n\n\n\n/**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/\n\nvar aux = __nested_webpack_require_41986__(548);\nvar Matrix = __nested_webpack_require_41986__(140).layoutBase.Matrix;\nvar SVD = __nested_webpack_require_41986__(140).layoutBase.SVD;\n\n// main function that spectral layout is processed\nvar spectralLayout = function spectralLayout(options) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var parentNodes = eles.nodes(\":parent\");\n\n  var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n  var nodeIndexes = new Map(); // map to keep indexes to nodes\n  var parentChildMap = new Map(); // mapping btw. compound and its representative node \n  var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n  var xCoords = [];\n  var yCoords = [];\n\n  var samplesColumn = []; // sampled vertices\n  var minDistancesColumn = [];\n  var C = []; // column sampling matrix\n  var PHI = []; // intersection of column and row sampling matrices \n  var INV = []; // inverse of PHI \n\n  var firstSample = void 0; // the first sampled node\n  var nodeSize = void 0;\n\n  var infinity = 100000000;\n  var small = 0.000000001;\n\n  var piTol = options.piTol;\n  var samplingType = options.samplingType; // false for random, true for greedy\n  var nodeSeparation = options.nodeSeparation;\n  var sampleSize = void 0;\n\n  /**** Spectral-preprocessing functions ****/\n\n  /**** Spectral layout functions ****/\n\n  // determine which columns to be sampled\n  var randomSampleCR = function randomSampleCR() {\n    var sample = 0;\n    var count = 0;\n    var flag = false;\n\n    while (count < sampleSize) {\n      sample = Math.floor(Math.random() * nodeSize);\n\n      flag = false;\n      for (var i = 0; i < count; i++) {\n        if (samplesColumn[i] == sample) {\n          flag = true;\n          break;\n        }\n      }\n\n      if (!flag) {\n        samplesColumn[count] = sample;\n        count++;\n      } else {\n        continue;\n      }\n    }\n  };\n\n  // takes the index of the node(pivot) to initiate BFS as a parameter\n  var BFS = function BFS(pivot, index, samplingMethod) {\n    var path = []; // the front of the path\n    var front = 0; // the back of the path\n    var back = 0;\n    var current = 0;\n    var temp = void 0;\n    var distance = [];\n\n    var max_dist = 0; // the furthest node to be returned\n    var max_ind = 1;\n\n    for (var i = 0; i < nodeSize; i++) {\n      distance[i] = infinity;\n    }\n\n    path[back] = pivot;\n    distance[pivot] = 0;\n\n    while (back >= front) {\n      current = path[front++];\n      var neighbors = allNodesNeighborhood[current];\n      for (var _i = 0; _i < neighbors.length; _i++) {\n        temp = nodeIndexes.get(neighbors[_i]);\n        if (distance[temp] == infinity) {\n          distance[temp] = distance[current] + 1;\n          path[++back] = temp;\n        }\n      }\n      C[current][index] = distance[current] * nodeSeparation;\n    }\n\n    if (samplingMethod) {\n      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n        if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n      }\n\n      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n        if (minDistancesColumn[_i3] > max_dist) {\n          max_dist = minDistancesColumn[_i3];\n          max_ind = _i3;\n        }\n      }\n    }\n    return max_ind;\n  };\n\n  // apply BFS to all nodes or selected samples\n  var allBFS = function allBFS(samplingMethod) {\n\n    var sample = void 0;\n\n    if (!samplingMethod) {\n      randomSampleCR();\n\n      // call BFS\n      for (var i = 0; i < sampleSize; i++) {\n        BFS(samplesColumn[i], i, samplingMethod, false);\n      }\n    } else {\n      sample = Math.floor(Math.random() * nodeSize);\n      firstSample = sample;\n\n      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n        minDistancesColumn[_i4] = infinity;\n      }\n\n      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n        samplesColumn[_i5] = sample;\n        sample = BFS(sample, _i5, samplingMethod);\n      }\n    }\n\n    // form the squared distances for C\n    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n      for (var j = 0; j < sampleSize; j++) {\n        C[_i6][j] *= C[_i6][j];\n      }\n    }\n\n    // form PHI\n    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n      PHI[_i7] = [];\n    }\n\n    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n      for (var _j = 0; _j < sampleSize; _j++) {\n        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n      }\n    }\n  };\n\n  // perform the SVD algorithm and apply a regularization step\n  var sample = function sample() {\n\n    var SVDResult = SVD.svd(PHI);\n\n    var a_q = SVDResult.S;\n    var a_u = SVDResult.U;\n    var a_v = SVDResult.V;\n\n    var max_s = a_q[0] * a_q[0] * a_q[0];\n\n    var a_Sig = [];\n\n    //  regularization\n    for (var i = 0; i < sampleSize; i++) {\n      a_Sig[i] = [];\n      for (var j = 0; j < sampleSize; j++) {\n        a_Sig[i][j] = 0;\n        if (i == j) {\n          a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n        }\n      }\n    }\n\n    INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n  };\n\n  // calculate final coordinates \n  var powerIteration = function powerIteration() {\n    // two largest eigenvalues\n    var theta1 = void 0;\n    var theta2 = void 0;\n\n    // initial guesses for eigenvectors\n    var Y1 = [];\n    var Y2 = [];\n\n    var V1 = [];\n    var V2 = [];\n\n    for (var i = 0; i < nodeSize; i++) {\n      Y1[i] = Math.random();\n      Y2[i] = Math.random();\n    }\n\n    Y1 = Matrix.normalize(Y1);\n    Y2 = Matrix.normalize(Y2);\n\n    var count = 0;\n    // to keep track of the improvement ratio in power iteration\n    var current = small;\n    var previous = small;\n\n    var temp = void 0;\n\n    while (true) {\n      count++;\n\n      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n        V1[_i9] = Y1[_i9];\n      }\n\n      Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n      theta1 = Matrix.dotProduct(V1, Y1);\n      Y1 = Matrix.normalize(Y1);\n\n      current = Matrix.dotProduct(V1, Y1);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n      V1[_i10] = Y1[_i10];\n    }\n\n    count = 0;\n    previous = small;\n    while (true) {\n      count++;\n\n      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n        V2[_i11] = Y2[_i11];\n      }\n\n      V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n      Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n      theta2 = Matrix.dotProduct(V2, Y2);\n      Y2 = Matrix.normalize(Y2);\n\n      current = Matrix.dotProduct(V2, Y2);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n      V2[_i12] = Y2[_i12];\n    }\n\n    // theta1 now contains dominant eigenvalue\n    // theta2 now contains the second-largest eigenvalue\n    // V1 now contains theta1's eigenvector\n    // V2 now contains theta2's eigenvector\n\n    //populate the two vectors\n    xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n    yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n  };\n\n  /**** Preparation for spectral layout (Preprocessing) ****/\n\n  // connect disconnected components (first top level, then inside of each compound node)\n  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n\n  parentNodes.forEach(function (ele) {\n    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n  });\n\n  // assign indexes to nodes (first real, then dummy nodes)\n  var index = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    if (!nodes[i].isParent()) {\n      nodeIndexes.set(nodes[i].id(), index++);\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      nodeIndexes.set(key, index++);\n    }\n\n    // instantiate the neighborhood matrix\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n    allNodesNeighborhood[_i13] = [];\n  }\n\n  // form a parent-child map to keep representative node of each compound node  \n  parentNodes.forEach(function (ele) {\n    var children = ele.children().intersection(eles);\n\n    //      let random = 0;\n    while (children.nodes(\":childless\").length == 0) {\n      //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n      children = children.nodes()[0].children().intersection(eles);\n    }\n    //  select the representative node - we can apply different methods here\n    //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n    var index = 0;\n    var min = children.nodes(\":childless\")[0].connectedEdges().length;\n    children.nodes(\":childless\").forEach(function (ele2, i) {\n      if (ele2.connectedEdges().length < min) {\n        min = ele2.connectedEdges().length;\n        index = i;\n      }\n    });\n    parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n  });\n\n  // add neighborhood relations (first real, then dummy nodes)\n  nodes.forEach(function (ele) {\n    var eleIndex = void 0;\n\n    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n\n    ele.neighborhood().nodes().forEach(function (node) {\n      if (eles.intersection(ele.edgesWith(node)).length > 0) {\n        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n      }\n    });\n  });\n\n  var _loop = function _loop(_key) {\n    var eleIndex = nodeIndexes.get(_key);\n    var disconnectedId = void 0;\n    dummyNodes.get(_key).forEach(function (id) {\n      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n\n      allNodesNeighborhood[eleIndex].push(disconnectedId);\n      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n    });\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      _loop(_key);\n    }\n\n    // nodeSize now only considers the size of transformed graph\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  nodeSize = nodeIndexes.size;\n\n  var spectralResult = void 0;\n\n  // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n  // So skip spectral and layout the graph with cose\n  if (nodeSize > 2) {\n    // if # of nodes in transformed graph is smaller than sample size,\n    // then use # of nodes as sample size\n    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n    // instantiates the partial matrices that will be used in spectral layout\n    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n      C[_i14] = [];\n    }\n    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n      INV[_i15] = [];\n    }\n\n    /**** Apply spectral layout ****/\n\n    if (options.quality == \"draft\" || options.step == \"all\") {\n      allBFS(samplingType);\n      sample();\n      powerIteration();\n\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    } else {\n      nodeIndexes.forEach(function (value, key) {\n        xCoords.push(cy.getElementById(key).position(\"x\"));\n        yCoords.push(cy.getElementById(key).position(\"y\"));\n      });\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    }\n    return spectralResult;\n  } else {\n    var iterator = nodeIndexes.keys();\n    var firstNode = cy.getElementById(iterator.next().value);\n    var firstNodePos = firstNode.position();\n    var firstNodeWidth = firstNode.outerWidth();\n    xCoords.push(firstNodePos.x);\n    yCoords.push(firstNodePos.y);\n    if (nodeSize == 2) {\n      var secondNode = cy.getElementById(iterator.next().value);\n      var secondNodeWidth = secondNode.outerWidth();\n      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n      yCoords.push(firstNodePos.y);\n    }\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  }\n};\n\nmodule.exports = { spectralLayout: spectralLayout };\n\n/***/ }),\n\n/***/ 579:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_55337__) => {\n\n\n\nvar impl = __nested_webpack_require_55337__(212);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n\n/***/ 140:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_56127__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_56127__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_56127__(579);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL2N5dG9zY2FwZS1mY29zZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmFiYml0bXEtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUtZmNvc2UvY3l0b3NjYXBlLWZjb3NlLmpzP2I2NDciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiY29zZS1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImNvc2UtYmFzZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjeXRvc2NhcGVGY29zZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY3l0b3NjYXBlRmNvc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJjb3NlQmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNDBfXykge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNjU4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5cbi8vIFNpbXBsZSwgaW50ZXJuYWwgT2JqZWN0LmFzc2lnbigpIHBvbHlmaWxsIGZvciBvcHRpb25zIG9iamVjdHMgZXRjLlxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3JjcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzcmNzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHNyY3MuZm9yRWFjaChmdW5jdGlvbiAoc3JjKSB7XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICByZXR1cm4gdGd0W2tdID0gc3JjW2tdO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGd0O1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU0ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuLypcbiAqIEF1eGlsaWFyeSBmdW5jdGlvbnNcbiAqL1xuXG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLkxpbmtlZExpc3Q7XG5cbnZhciBhdXhpbGlhcnkgPSB7fTtcblxuLy8gZ2V0IHRoZSB0b3AgbW9zdCBub2Rlc1xuYXV4aWxpYXJ5LmdldFRvcE1vc3ROb2RlcyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbm9kZXNNYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGVzTWFwW25vZGVzW2ldLmlkKCldID0gdHJ1ZTtcbiAgfVxuICB2YXIgcm9vdHMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBlbGUgPSBpO1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gZWxlLnBhcmVudCgpWzBdO1xuICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGVzTWFwW3BhcmVudC5pZCgpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KClbMF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gcm9vdHM7XG59O1xuXG4vLyBmaW5kIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIGFuZCBjcmVhdGUgZHVtbXkgbm9kZXMgdGhhdCBjb25uZWN0IHRoZW1cbmF1eGlsaWFyeS5jb25uZWN0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdG9wTW9zdE5vZGVzLCBkdW1teU5vZGVzKSB7XG4gIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgdmlzaXRlZFRvcE1vc3ROb2RlcyA9IFtdO1xuICB2YXIgY3VycmVudE5laWdoYm9yID0gdm9pZCAwO1xuICB2YXIgbWluRGVncmVlTm9kZSA9IHZvaWQgMDtcbiAgdmFyIG1pbkRlZ3JlZSA9IHZvaWQgMDtcblxuICB2YXIgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgdmFyIGNvdW50ID0gMTtcbiAgdmFyIG5vZGVzQ29ubmVjdGVkVG9EdW1teSA9IFtdO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBjbXB0ID0gY3kuY29sbGVjdGlvbigpO1xuICAgIGNvbXBvbmVudHMucHVzaChjbXB0KTtcblxuICAgIHZhciBjdXJyZW50Tm9kZSA9IHRvcE1vc3ROb2Rlc1swXTtcbiAgICB2YXIgY2hpbGRyZW5PZkN1cnJlbnROb2RlID0gY3kuY29sbGVjdGlvbigpO1xuICAgIGNoaWxkcmVuT2ZDdXJyZW50Tm9kZS5tZXJnZShjdXJyZW50Tm9kZSkubWVyZ2UoY3VycmVudE5vZGUuZGVzY2VuZGFudHMoKS5pbnRlcnNlY3Rpb24oZWxlcykpO1xuICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMucHVzaChjdXJyZW50Tm9kZSk7XG5cbiAgICBjaGlsZHJlbk9mQ3VycmVudE5vZGUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgY21wdC5tZXJnZShub2RlKTtcbiAgICB9KTtcblxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgICB2YXIgbmVpZ2hib3JOb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGN1cnJlbnROb2RlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoZWxlcy5pbnRlcnNlY3Rpb24oY3VycmVudE5vZGUuZWRnZXNXaXRoKG5vZGUpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbmVpZ2hib3JOb2Rlcy5tZXJnZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcbiAgICAgICAgY3VycmVudE5laWdoYm9yID0gdG9wTW9zdE5vZGVzLmludGVyc2VjdGlvbihuZWlnaGJvck5vZGUudW5pb24obmVpZ2hib3JOb2RlLmFuY2VzdG9ycygpKSk7XG4gICAgICAgIGlmIChjdXJyZW50TmVpZ2hib3IgIT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yWzBdKSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk9mTmVpZ2hib3IgPSBjdXJyZW50TmVpZ2hib3IudW5pb24oY3VycmVudE5laWdoYm9yLmRlc2NlbmRhbnRzKCkpO1xuXG4gICAgICAgICAgY2hpbGRyZW5PZk5laWdoYm9yLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgICAgICAgIGNtcHQubWVyZ2Uobm9kZSk7XG4gICAgICAgICAgICBpZiAodG9wTW9zdE5vZGVzLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICBfbG9vcDIoKTtcbiAgICB9XG5cbiAgICBjbXB0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGVsZXMuaW50ZXJzZWN0aW9uKG5vZGUuY29ubmVjdGVkRWRnZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBjb25uZWN0ZWRFZGdlcygpIHVzdWFsbHkgY2FjaGVkXG4gICAgICAgIGlmIChjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgIC8vIGhhcygpIGlzIGNoZWFwXG4gICAgICAgICAgY21wdC5tZXJnZShlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAodmlzaXRlZFRvcE1vc3ROb2Rlcy5sZW5ndGggPT0gdG9wTW9zdE5vZGVzLmxlbmd0aCkge1xuICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaXNDb25uZWN0ZWQgfHwgaXNDb25uZWN0ZWQgJiYgY291bnQgPiAxKSB7XG4gICAgICBtaW5EZWdyZWVOb2RlID0gdmlzaXRlZFRvcE1vc3ROb2Rlc1swXTtcbiAgICAgIG1pbkRlZ3JlZSA9IG1pbkRlZ3JlZU5vZGUuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGggPCBtaW5EZWdyZWUpIHtcbiAgICAgICAgICBtaW5EZWdyZWUgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgICAgICAgIG1pbkRlZ3JlZU5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5vZGVzQ29ubmVjdGVkVG9EdW1teS5wdXNoKG1pbkRlZ3JlZU5vZGUuaWQoKSk7XG4gICAgICAvLyBUTyBETzogQ2hlY2sgZWZmaWNpZW5jeSBvZiB0aGlzIHBhcnRcbiAgICAgIHZhciB0ZW1wID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgdGVtcC5tZXJnZSh2aXNpdGVkVG9wTW9zdE5vZGVzWzBdKTtcbiAgICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0ZW1wLm1lcmdlKG5vZGUpO1xuICAgICAgfSk7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzID0gW107XG4gICAgICB0b3BNb3N0Tm9kZXMgPSB0b3BNb3N0Tm9kZXMuZGlmZmVyZW5jZSh0ZW1wKTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9O1xuXG4gIGRvIHtcbiAgICBfbG9vcCgpO1xuICB9IHdoaWxlICghaXNDb25uZWN0ZWQpO1xuXG4gIGlmIChkdW1teU5vZGVzKSB7XG4gICAgaWYgKG5vZGVzQ29ubmVjdGVkVG9EdW1teS5sZW5ndGggPiAwKSB7XG4gICAgICBkdW1teU5vZGVzLnNldCgnZHVtbXknICsgKGR1bW15Tm9kZXMuc2l6ZSArIDEpLCBub2Rlc0Nvbm5lY3RlZFRvRHVtbXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50cztcbn07XG5cbi8vIHJlbG9jYXRlcyBjb21wb25lbnRSZXN1bHQgdG8gb3JpZ2luYWxDZW50ZXIgaWYgdGhlcmUgaXMgbm8gZml4ZWROb2RlQ29uc3RyYWludFxuYXV4aWxpYXJ5LnJlbG9jYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKG9yaWdpbmFsQ2VudGVyLCBjb21wb25lbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICB2YXIgbWluWENvb3JkID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBtYXhYQ29vcmQgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1pbllDb29yZCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4WUNvb3JkID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBjb21wb25lbnRSZXN1bHQubm9kZUluZGV4ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG4gICAgICAgICAgdmFyIGtleSA9IF9yZWYyWzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgdmFyIGN5Tm9kZSA9IG9wdGlvbnMuY3kuZ2V0RWxlbWVudEJ5SWQoa2V5KTtcbiAgICAgICAgICBpZiAoY3lOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUJCID0gY3lOb2RlLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB2YXIgbGVmdFggPSBjb21wb25lbnRSZXN1bHQueENvb3Jkc1t2YWx1ZV0gLSBub2RlQkIudyAvIDI7XG4gICAgICAgICAgICB2YXIgcmlnaHRYID0gY29tcG9uZW50UmVzdWx0LnhDb29yZHNbdmFsdWVdICsgbm9kZUJCLncgLyAyO1xuICAgICAgICAgICAgdmFyIHRvcFkgPSBjb21wb25lbnRSZXN1bHQueUNvb3Jkc1t2YWx1ZV0gLSBub2RlQkIuaCAvIDI7XG4gICAgICAgICAgICB2YXIgYm90dG9tWSA9IGNvbXBvbmVudFJlc3VsdC55Q29vcmRzW3ZhbHVlXSArIG5vZGVCQi5oIC8gMjtcblxuICAgICAgICAgICAgaWYgKGxlZnRYIDwgbWluWENvb3JkKSBtaW5YQ29vcmQgPSBsZWZ0WDtcbiAgICAgICAgICAgIGlmIChyaWdodFggPiBtYXhYQ29vcmQpIG1heFhDb29yZCA9IHJpZ2h0WDtcbiAgICAgICAgICAgIGlmICh0b3BZIDwgbWluWUNvb3JkKSBtaW5ZQ29vcmQgPSB0b3BZO1xuICAgICAgICAgICAgaWYgKGJvdHRvbVkgPiBtYXhZQ29vcmQpIG1heFlDb29yZCA9IGJvdHRvbVk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIG9yaWdpbmFsIGNlbnRlclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkaWZmT25YID0gb3JpZ2luYWxDZW50ZXIueCAtIChtYXhYQ29vcmQgKyBtaW5YQ29vcmQpIC8gMjtcbiAgICAgIHZhciBkaWZmT25ZID0gb3JpZ2luYWxDZW50ZXIueSAtIChtYXhZQ29vcmQgKyBtaW5ZQ29vcmQpIC8gMjtcbiAgICAgIC8vIG1vdmUgY29tcG9uZW50IHRvIG9yaWdpbmFsIGNlbnRlclxuICAgICAgY29tcG9uZW50UmVzdWx0LnhDb29yZHMgPSBjb21wb25lbnRSZXN1bHQueENvb3Jkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggKyBkaWZmT25YO1xuICAgICAgfSk7XG4gICAgICBjb21wb25lbnRSZXN1bHQueUNvb3JkcyA9IGNvbXBvbmVudFJlc3VsdC55Q29vcmRzLm1hcChmdW5jdGlvbiAoeSkge1xuICAgICAgICByZXR1cm4geSArIGRpZmZPblk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2FsY3VsYXRlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgICBPYmplY3Qua2V5cyhjb21wb25lbnRSZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRSZXN1bHRbaXRlbV07XG4gICAgICAgIHZhciBsZWZ0WCA9IG5vZGUuZ2V0UmVjdCgpLng7XG4gICAgICAgIHZhciByaWdodFggPSBub2RlLmdldFJlY3QoKS54ICsgbm9kZS5nZXRSZWN0KCkud2lkdGg7XG4gICAgICAgIHZhciB0b3BZID0gbm9kZS5nZXRSZWN0KCkueTtcbiAgICAgICAgdmFyIGJvdHRvbVkgPSBub2RlLmdldFJlY3QoKS55ICsgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0O1xuXG4gICAgICAgIGlmIChsZWZ0WCA8IG1pblhDb29yZCkgbWluWENvb3JkID0gbGVmdFg7XG4gICAgICAgIGlmIChyaWdodFggPiBtYXhYQ29vcmQpIG1heFhDb29yZCA9IHJpZ2h0WDtcbiAgICAgICAgaWYgKHRvcFkgPCBtaW5ZQ29vcmQpIG1pbllDb29yZCA9IHRvcFk7XG4gICAgICAgIGlmIChib3R0b21ZID4gbWF4WUNvb3JkKSBtYXhZQ29vcmQgPSBib3R0b21ZO1xuICAgICAgfSk7XG4gICAgICAvLyBmaW5kIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBvcmlnaW5hbCBjZW50ZXJcbiAgICAgIHZhciBfZGlmZk9uWCA9IG9yaWdpbmFsQ2VudGVyLnggLSAobWF4WENvb3JkICsgbWluWENvb3JkKSAvIDI7XG4gICAgICB2YXIgX2RpZmZPblkgPSBvcmlnaW5hbENlbnRlci55IC0gKG1heFlDb29yZCArIG1pbllDb29yZCkgLyAyO1xuICAgICAgLy8gbW92ZSBjb21wb25lbnQgdG8gb3JpZ2luYWwgY2VudGVyXG4gICAgICBPYmplY3Qua2V5cyhjb21wb25lbnRSZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRSZXN1bHRbaXRlbV07XG4gICAgICAgIG5vZGUuc2V0Q2VudGVyKG5vZGUuZ2V0Q2VudGVyWCgpICsgX2RpZmZPblgsIG5vZGUuZ2V0Q2VudGVyWSgpICsgX2RpZmZPblkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuXG5hdXhpbGlhcnkuY2FsY0JvdW5kaW5nQm94ID0gZnVuY3Rpb24gKHBhcmVudE5vZGUsIHhDb29yZHMsIHlDb29yZHMsIG5vZGVJbmRleGVzKSB7XG4gIC8vIGNhbGN1bGF0ZSBib3VuZHNcbiAgdmFyIGxlZnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIHJpZ2h0ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gIHZhciB0b3AgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIGJvdHRvbSA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICB2YXIgbm9kZUxlZnQgPSB2b2lkIDA7XG4gIHZhciBub2RlUmlnaHQgPSB2b2lkIDA7XG4gIHZhciBub2RlVG9wID0gdm9pZCAwO1xuICB2YXIgbm9kZUJvdHRvbSA9IHZvaWQgMDtcblxuICB2YXIgbm9kZXMgPSBwYXJlbnROb2RlLmRlc2NlbmRhbnRzKCkubm90KFwiOnBhcmVudFwiKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIG5vZGVMZWZ0ID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gLSBub2RlLndpZHRoKCkgLyAyO1xuICAgIG5vZGVSaWdodCA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldICsgbm9kZS53aWR0aCgpIC8gMjtcbiAgICBub2RlVG9wID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gLSBub2RlLmhlaWdodCgpIC8gMjtcbiAgICBub2RlQm90dG9tID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gKyBub2RlLmhlaWdodCgpIC8gMjtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ0JveCA9IHt9O1xuICBib3VuZGluZ0JveC50b3BMZWZ0WCA9IGxlZnQ7XG4gIGJvdW5kaW5nQm94LnRvcExlZnRZID0gdG9wO1xuICBib3VuZGluZ0JveC53aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgYm91bmRpbmdCb3guaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICByZXR1cm4gYm91bmRpbmdCb3g7XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGZpbmRzIGFuZCByZXR1cm5zIHBhcmVudCBub2RlcyB3aG9zZSBhbGwgY2hpbGRyZW4gYXJlIGhpZGRlblxuYXV4aWxpYXJ5LmNhbGNQYXJlbnRzV2l0aG91dENoaWxkcmVuID0gZnVuY3Rpb24gKGN5LCBlbGVzKSB7XG4gIHZhciBwYXJlbnRzV2l0aG91dENoaWxkcmVuID0gY3kuY29sbGVjdGlvbigpO1xuICBlbGVzLm5vZGVzKCc6cGFyZW50JykuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgdmFyIGNoZWNrID0gZmFsc2U7XG4gICAgcGFyZW50LmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5jc3MoJ2Rpc3BsYXknKSAhPSAnbm9uZScpIHtcbiAgICAgICAgY2hlY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4ubWVyZ2UocGFyZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJlbnRzV2l0aG91dENoaWxkcmVuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhdXhpbGlhcnk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG4vKipcbiAgVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwb3N0cHJvY2Vzc2luZyBwYXJ0IHRoYXQgYXBwbGllcyBDb1NFIGxheW91dCBvdmVyIHRoZSBzcGVjdHJhbCBsYXlvdXRcbiovXG5cbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG52YXIgQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5Db1NFTGF5b3V0O1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLkNvU0VOb2RlO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLlBvaW50RDtcbnZhciBEaW1lbnNpb25EID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuRGltZW5zaW9uRDtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5MYXlvdXRDb25zdGFudHM7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5GRExheW91dENvbnN0YW50cztcbnZhciBDb1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLkNvU0VDb25zdGFudHM7XG5cbi8vIG1haW4gZnVuY3Rpb24gdGhhdCBjb3NlIGxheW91dCBpcyBwcm9jZXNzZWRcbnZhciBjb3NlTGF5b3V0ID0gZnVuY3Rpb24gY29zZUxheW91dChvcHRpb25zLCBzcGVjdHJhbFJlc3VsdCkge1xuXG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcblxuICB2YXIgbm9kZUluZGV4ZXMgPSB2b2lkIDA7XG4gIHZhciB4Q29vcmRzID0gdm9pZCAwO1xuICB2YXIgeUNvb3JkcyA9IHZvaWQgMDtcbiAgdmFyIGlkVG9MTm9kZSA9IHt9O1xuXG4gIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIG5vZGVJbmRleGVzID0gc3BlY3RyYWxSZXN1bHRbXCJub2RlSW5kZXhlc1wiXTtcbiAgICB4Q29vcmRzID0gc3BlY3RyYWxSZXN1bHRbXCJ4Q29vcmRzXCJdO1xuICAgIHlDb29yZHMgPSBzcGVjdHJhbFJlc3VsdFtcInlDb29yZHNcIl07XG4gIH1cblxuICB2YXIgaXNGbiA9IGZ1bmN0aW9uIGlzRm4oZm4pIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nO1xuICB9O1xuXG4gIHZhciBvcHRGbiA9IGZ1bmN0aW9uIG9wdEZuKG9wdCwgZWxlKSB7XG4gICAgaWYgKGlzRm4ob3B0KSkge1xuICAgICAgcmV0dXJuIG9wdChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0O1xuICAgIH1cbiAgfTtcblxuICAvKioqKiBQb3N0cHJvY2Vzc2luZyBmdW5jdGlvbnMgKioqKi9cblxuICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGF1eC5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbihjeSwgZWxlcyk7XG5cbiAgLy8gdHJhbnNmZXIgY3l0b3NjYXBlIG5vZGVzIHRvIGNvc2Ugbm9kZXNcbiAgdmFyIHByb2Nlc3NDaGlsZHJlbkxpc3QgPSBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRyZW5MaXN0KHBhcmVudCwgY2hpbGRyZW4sIGxheW91dCwgb3B0aW9ucykge1xuICAgIHZhciBzaXplID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBjaGlsZHJlbl9vZl9jaGlsZHJlbiA9IG51bGw7XG4gICAgICBpZiAodGhlQ2hpbGQuaW50ZXJzZWN0aW9uKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNoaWxkcmVuX29mX2NoaWxkcmVuID0gdGhlQ2hpbGQuY2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGVOb2RlID0gdm9pZCAwO1xuXG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoZUNoaWxkLmxheW91dERpbWVuc2lvbnMoe1xuICAgICAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoZUNoaWxkLm91dGVyV2lkdGgoKSAhPSBudWxsICYmIHRoZUNoaWxkLm91dGVySGVpZ2h0KCkgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgICBpZiAoIXRoZUNoaWxkLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHRoZUNoaWxkLmlkKCkpXSAtIGRpbWVuc2lvbnMudyAvIDIsIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHRoZUNoaWxkLmlkKCkpXSAtIGRpbWVuc2lvbnMuaCAvIDIpLCBuZXcgRGltZW5zaW9uRChwYXJzZUZsb2F0KGRpbWVuc2lvbnMudyksIHBhcnNlRmxvYXQoZGltZW5zaW9ucy5oKSkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcmVudEluZm8gPSBhdXguY2FsY0JvdW5kaW5nQm94KHRoZUNoaWxkLCB4Q29vcmRzLCB5Q29vcmRzLCBub2RlSW5kZXhlcyk7XG4gICAgICAgICAgICBpZiAodGhlQ2hpbGQuaW50ZXJzZWN0aW9uKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHBhcmVudEluZm8udG9wTGVmdFgsIHBhcmVudEluZm8udG9wTGVmdFkpLCBuZXcgRGltZW5zaW9uRChwYXJlbnRJbmZvLndpZHRoLCBwYXJlbnRJbmZvLmhlaWdodCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGZvciB0aGUgcGFyZW50c1dpdGhvdXRDaGlsZHJlblxuICAgICAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RChwYXJlbnRJbmZvLnRvcExlZnRYLCBwYXJlbnRJbmZvLnRvcExlZnRZKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHRoZUNoaWxkLnBvc2l0aW9uKCd4JykgLSBkaW1lbnNpb25zLncgLyAyLCB0aGVDaGlsZC5wb3NpdGlvbigneScpIC0gZGltZW5zaW9ucy5oIC8gMiksIG5ldyBEaW1lbnNpb25EKHBhcnNlRmxvYXQoZGltZW5zaW9ucy53KSwgcGFyc2VGbG9hdChkaW1lbnNpb25zLmgpKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUodGhpcy5ncmFwaE1hbmFnZXIpKTtcbiAgICAgIH1cbiAgICAgIC8vIEF0dGFjaCBpZCB0byB0aGUgbGF5b3V0IG5vZGUgYW5kIHJlcHVsc2lvbiB2YWx1ZVxuICAgICAgdGhlTm9kZS5pZCA9IHRoZUNoaWxkLmRhdGEoXCJpZFwiKTtcbiAgICAgIHRoZU5vZGUubm9kZVJlcHVsc2lvbiA9IG9wdEZuKG9wdGlvbnMubm9kZVJlcHVsc2lvbiwgdGhlQ2hpbGQpO1xuICAgICAgLy8gQXR0YWNoIHRoZSBwYWRkaW5ncyBvZiBjeSBub2RlIHRvIGxheW91dCBub2RlXG4gICAgICB0aGVOb2RlLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nVG9wID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nUmlnaHQgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgICB0aGVOb2RlLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG5cbiAgICAgIC8vQXR0YWNoIHRoZSBsYWJlbCBwcm9wZXJ0aWVzIHRvIGJvdGggY29tcG91bmQgYW5kIHNpbXBsZSBub2RlcyBpZiBsYWJlbHMgd2lsbCBiZSBpbmNsdWRlZCBpbiBub2RlIGRpbWVuc2lvbnNcbiAgICAgIC8vVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgd2hpbGUgdXBkYXRpbmcgYm91bmRzIG9mIGNvbXBvdW5kcyBkdXJpbmcgaXRlcmF0aW9ucyBvciB0aWxpbmdcbiAgICAgIC8vYW5kIHdpbGwgYmUgdXNlZCBmb3Igc2ltcGxlIG5vZGVzIHdoaWxlIHRyYW5zZmVycmluZyBmaW5hbCBwb3NpdGlvbnMgdG8gY3l0b3NjYXBlXG4gICAgICBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFdpZHRoID0gdGhlQ2hpbGQuYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiB0cnVlLCBpbmNsdWRlTm9kZXM6IGZhbHNlLCBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlIH0pLnc7XG4gICAgICAgIHRoZU5vZGUubGFiZWxIZWlnaHQgPSB0aGVDaGlsZC5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IHRydWUsIGluY2x1ZGVOb2RlczogZmFsc2UsIGluY2x1ZGVPdmVybGF5czogZmFsc2UgfSkuaDtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID0gdGhlQ2hpbGQuY3NzKFwidGV4dC12YWxpZ25cIik7XG4gICAgICAgIHRoZU5vZGUubGFiZWxQb3NIb3Jpem9udGFsID0gdGhlQ2hpbGQuY3NzKFwidGV4dC1oYWxpZ25cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcCB0aGUgbGF5b3V0IG5vZGVcbiAgICAgIGlkVG9MTm9kZVt0aGVDaGlsZC5kYXRhKFwiaWRcIildID0gdGhlTm9kZTtcblxuICAgICAgaWYgKGlzTmFOKHRoZU5vZGUucmVjdC54KSkge1xuICAgICAgICB0aGVOb2RlLnJlY3QueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueSkpIHtcbiAgICAgICAgdGhlTm9kZS5yZWN0LnkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGRyZW5fb2ZfY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbl9vZl9jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0aGVOZXdHcmFwaCA9IHZvaWQgMDtcbiAgICAgICAgdGhlTmV3R3JhcGggPSBsYXlvdXQuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKGxheW91dC5uZXdHcmFwaCgpLCB0aGVOb2RlKTtcbiAgICAgICAgcHJvY2Vzc0NoaWxkcmVuTGlzdCh0aGVOZXdHcmFwaCwgY2hpbGRyZW5fb2ZfY2hpbGRyZW4sIGxheW91dCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHRyYW5zZmVyIGN5dG9zY2FwZSBlZGdlcyB0byBjb3NlIGVkZ2VzXG4gIHZhciBwcm9jZXNzRWRnZXMgPSBmdW5jdGlvbiBwcm9jZXNzRWRnZXMobGF5b3V0LCBnbSwgZWRnZXMpIHtcbiAgICB2YXIgaWRlYWxMZW5ndGhUb3RhbCA9IDA7XG4gICAgdmFyIGVkZ2VDb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBzb3VyY2VOb2RlID0gaWRUb0xOb2RlW2VkZ2UuZGF0YShcInNvdXJjZVwiKV07XG4gICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGlkVG9MTm9kZVtlZGdlLmRhdGEoXCJ0YXJnZXRcIildO1xuICAgICAgaWYgKHNvdXJjZU5vZGUgJiYgdGFyZ2V0Tm9kZSAmJiBzb3VyY2VOb2RlICE9PSB0YXJnZXROb2RlICYmIHNvdXJjZU5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHRhcmdldE5vZGUpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHZhciBlMSA9IGdtLmFkZChsYXlvdXQubmV3RWRnZSgpLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKTtcbiAgICAgICAgZTEuaWQgPSBlZGdlLmlkKCk7XG4gICAgICAgIGUxLmlkZWFsTGVuZ3RoID0gb3B0Rm4ob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgsIGVkZ2UpO1xuICAgICAgICBlMS5lZGdlRWxhc3RpY2l0eSA9IG9wdEZuKG9wdGlvbnMuZWRnZUVsYXN0aWNpdHksIGVkZ2UpO1xuICAgICAgICBpZGVhbExlbmd0aFRvdGFsICs9IGUxLmlkZWFsTGVuZ3RoO1xuICAgICAgICBlZGdlQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgdGhlIGlkZWFsIGVkZ2UgbGVuZ3RoIGNvbnN0YW50IHdpdGggdGhlIGF2Zy4gaWRlYWwgbGVuZ3RoIHZhbHVlIGFmdGVyIHByb2Nlc3NpbmcgZWRnZXNcbiAgICAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UsIHVzZSBvdGhlciBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgIGlmIChlZGdlQ291bnQgPiAwKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gaWRlYWxMZW5ndGhUb3RhbCAvIGVkZ2VDb3VudDtlbHNlIGlmICghaXNGbihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkpIC8vIGluIGNhc2UgdGhlcmUgaXMgbm8gZWRnZSwgYnV0IG9wdGlvbiBnaXZlcyBhIHZhbHVlIHRvIHVzZVxuICAgICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7ZWxzZSAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UgYW5kIHdlIGNhbm5vdCBnZXQgYSB2YWx1ZSBmcm9tIG9wdGlvbiAoYmVjYXVzZSBpdCdzIGEgZnVuY3Rpb24pXG4gICAgICAgIENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSA1MDtcbiAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiYXNlZCBvbiB0aGUgaWRlYWwgZWRnZSBsZW5ndGggY29uc3RhbnRcbiAgICAgIENvU0VDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwLjA7XG4gICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cbiAgfTtcblxuICAvLyB0cmFuc2ZlciBjeXRvc2NhcGUgY29uc3RyYWludHMgdG8gY29zZSBsYXlvdXRcbiAgdmFyIHByb2Nlc3NDb25zdHJhaW50cyA9IGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cyhsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgZml4ZWRcbiAgICBpZiAob3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgICBsYXlvdXQuY29uc3RyYWludHNbXCJmaXhlZE5vZGVDb25zdHJhaW50XCJdID0gb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50O1xuICAgIH1cbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgYWxpZ25lZFxuICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGxheW91dC5jb25zdHJhaW50c1tcImFsaWdubWVudENvbnN0cmFpbnRcIl0gPSBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQ7XG4gICAgfVxuICAgIC8vIGdldCBub2RlcyB0byBiZSByZWxhdGl2ZWx5IHBsYWNlZFxuICAgIGlmIChvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgbGF5b3V0LmNvbnN0cmFpbnRzW1wicmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50XCJdID0gb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKioqIEFwcGx5IHBvc3Rwcm9jZXNzaW5nICoqKiovXG4gIGlmIChvcHRpb25zLm5lc3RpbmdGYWN0b3IgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eTtcbiAgaWYgKG9wdGlvbnMubnVtSXRlciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBvcHRpb25zLm51bUl0ZXI7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2U7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWwgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw7XG5cbiAgaWYgKG9wdGlvbnMudGlsaW5nQ29tcGFyZUJ5ICE9IG51bGwpIENvU0VDb25zdGFudHMuVElMSU5HX0NPTVBBUkVfQlkgPSBvcHRpb25zLnRpbGluZ0NvbXBhcmVCeTtcblxuICBpZiAob3B0aW9ucy5xdWFsaXR5ID09ICdwcm9vZicpIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMjtlbHNlIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMDtcblxuICBDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IEZETGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscztcbiAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gIW9wdGlvbnMucmFuZG9taXplO1xuICBDb1NFQ29uc3RhbnRzLkFOSU1BVEUgPSBGRExheW91dENvbnN0YW50cy5BTklNQVRFID0gTGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBvcHRpb25zLmFuaW1hdGU7XG4gIENvU0VDb25zdGFudHMuVElMRSA9IG9wdGlvbnMudGlsZTtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDtcblxuICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSB0cnVlO1xuICBDb1NFQ29uc3RhbnRzLlBVUkVfSU5DUkVNRU5UQUwgPSAhb3B0aW9ucy5yYW5kb21pemU7XG4gIExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTID0gb3B0aW9ucy51bmlmb3JtTm9kZURpbWVuc2lvbnM7XG5cbiAgLy8gVGhpcyBwYXJ0IGlzIGZvciBkZWJ1Zy9kZW1vIHB1cnBvc2VcbiAgaWYgKG9wdGlvbnMuc3RlcCA9PSBcInRyYW5zZm9ybWVkXCIpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HID0gdHJ1ZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLnN0ZXAgPT0gXCJlbmZvcmNlZFwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiY29zZVwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiYWxsXCIpIHtcbiAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSB0cnVlO2Vsc2UgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQgfHwgb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IHRydWU7XG4gIH1cblxuICB2YXIgY29zZUxheW91dCA9IG5ldyBDb1NFTGF5b3V0KCk7XG4gIHZhciBnbSA9IGNvc2VMYXlvdXQubmV3R3JhcGhNYW5hZ2VyKCk7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuTGlzdChnbS5hZGRSb290KCksIGF1eC5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpLCBjb3NlTGF5b3V0LCBvcHRpb25zKTtcbiAgcHJvY2Vzc0VkZ2VzKGNvc2VMYXlvdXQsIGdtLCBlZGdlcyk7XG4gIHByb2Nlc3NDb25zdHJhaW50cyhjb3NlTGF5b3V0LCBvcHRpb25zKTtcblxuICBjb3NlTGF5b3V0LnJ1bkxheW91dCgpO1xuXG4gIHJldHVybiBpZFRvTE5vZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgY29zZUxheW91dDogY29zZUxheW91dCB9O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjEyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZmNvc2UgbGF5b3V0IGFsZ29yaXRobVxuKi9cblxudmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjU4KTtcbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjU3KSxcbiAgICBzcGVjdHJhbExheW91dCA9IF9yZXF1aXJlLnNwZWN0cmFsTGF5b3V0O1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTYpLFxuICAgIGNvc2VMYXlvdXQgPSBfcmVxdWlyZTIuY29zZUxheW91dDtcblxudmFyIGRlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG5cbiAgLy8gJ2RyYWZ0JywgJ2RlZmF1bHQnIG9yICdwcm9vZicgXG4gIC8vIC0gJ2RyYWZ0JyBvbmx5IGFwcGxpZXMgc3BlY3RyYWwgbGF5b3V0IFxuICAvLyAtICdkZWZhdWx0JyBpbXByb3ZlcyB0aGUgcXVhbGl0eSB3aXRoIHN1YnNlcXVlbnQgQ29TRSBsYXlvdXQgKGZhc3QgY29vbGluZyByYXRlKVxuICAvLyAtICdwcm9vZicgaW1wcm92ZXMgdGhlIHF1YWxpdHkgd2l0aCBzdWJzZXF1ZW50IENvU0UgbGF5b3V0IChzbG93IGNvb2xpbmcgcmF0ZSkgXG4gIHF1YWxpdHk6IFwiZGVmYXVsdFwiLFxuICAvLyBVc2UgcmFuZG9tIG5vZGUgcG9zaXRpb25zIGF0IGJlZ2lubmluZyBvZiBsYXlvdXRcbiAgLy8gaWYgdGhpcyBpcyBzZXQgdG8gZmFsc2UsIHRoZW4gcXVhbGl0eSBvcHRpb24gbXVzdCBiZSBcInByb29mXCJcbiAgcmFuZG9taXplOiB0cnVlLFxuICAvLyBXaGV0aGVyIG9yIG5vdCB0byBhbmltYXRlIHRoZSBsYXlvdXRcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgLy8gRHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zLCBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwLFxuICAvLyBFYXNpbmcgb2YgYW5pbWF0aW9uLCBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBGaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSByZXBvc2l0aW9uZWQgbm9kZXNcbiAgZml0OiB0cnVlLFxuICAvLyBQYWRkaW5nIGFyb3VuZCBsYXlvdXRcbiAgcGFkZGluZzogMzAsXG4gIC8vIFdoZXRoZXIgdG8gaW5jbHVkZSBsYWJlbHMgaW4gbm9kZSBkaW1lbnNpb25zLiBWYWxpZCBpbiBcInByb29mXCIgcXVhbGl0eVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBXaGV0aGVyIG9yIG5vdCBzaW1wbGUgbm9kZXMgKG5vbi1jb21wb3VuZCBub2RlcykgYXJlIG9mIHVuaWZvcm0gZGltZW5zaW9uc1xuICB1bmlmb3JtTm9kZURpbWVuc2lvbnM6IGZhbHNlLFxuICAvLyBXaGV0aGVyIHRvIHBhY2sgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgLSB2YWxpZCBvbmx5IGlmIHJhbmRvbWl6ZTogdHJ1ZVxuICBwYWNrQ29tcG9uZW50czogdHJ1ZSxcbiAgLy8gTGF5b3V0IHN0ZXAgLSBhbGwsIHRyYW5zZm9ybWVkLCBlbmZvcmNlZCwgY29zZSAtIGZvciBkZWJ1ZyBwdXJwb3NlIG9ubHlcbiAgc3RlcDogXCJhbGxcIixcblxuICAvKiBzcGVjdHJhbCBsYXlvdXQgb3B0aW9ucyAqL1xuXG4gIC8vIEZhbHNlIGZvciByYW5kb20sIHRydWUgZm9yIGdyZWVkeVxuICBzYW1wbGluZ1R5cGU6IHRydWUsXG4gIC8vIFNhbXBsZSBzaXplIHRvIGNvbnN0cnVjdCBkaXN0YW5jZSBtYXRyaXhcbiAgc2FtcGxlU2l6ZTogMjUsXG4gIC8vIFNlcGFyYXRpb24gYW1vdW50IGJldHdlZW4gbm9kZXNcbiAgbm9kZVNlcGFyYXRpb246IDc1LFxuICAvLyBQb3dlciBpdGVyYXRpb24gdG9sZXJhbmNlXG4gIHBpVG9sOiAwLjAwMDAwMDEsXG5cbiAgLyogQ29TRSBsYXlvdXQgb3B0aW9ucyAqL1xuXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIDQ1MDA7XG4gIH0sXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IGZ1bmN0aW9uIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgcmV0dXJuIDUwO1xuICB9LFxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHk6IGZ1bmN0aW9uIGVkZ2VFbGFzdGljaXR5KGVkZ2UpIHtcbiAgICByZXR1cm4gMC40NTtcbiAgfSxcbiAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICBuZXN0aW5nRmFjdG9yOiAwLjEsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICBncmF2aXR5OiAwLjI1LFxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgbnVtSXRlcjogMjUwMCxcbiAgLy8gRm9yIGVuYWJsaW5nIHRpbGluZ1xuICB0aWxlOiB0cnVlLFxuICAvLyBUaGUgZnVuY3Rpb24gdGhhdCBzcGVjaWZpZXMgdGhlIGNyaXRlcmlhIGZvciBjb21wYXJpbmcgbm9kZXMgd2hpbGUgc29ydGluZyB0aGVtIGR1cmluZyB0aWxpbmcgb3BlcmF0aW9uLlxuICAvLyBUYWtlcyB0aGUgbm9kZSBpZCBhcyBhIHBhcmFtZXRlciBhbmQgdGhlIGRlZmF1bHQgdGlsaW5nIG9wZXJhdGlvbiBpcyBwZXJmb21lZCB3aGVuIHRoaXMgb3B0aW9uIGlzIG5vdCBzZXQuXG4gIHRpbGluZ0NvbXBhcmVCeTogdW5kZWZpbmVkLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIHZlcnRpY2FsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nVmVydGljYWw6IDEwLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIGhvcml6b250YWwgc3BhY2UgdG8gcHV0IGJldHdlZW4gdGhlIHplcm8gZGVncmVlIG1lbWJlcnMgZHVyaW5nIHRoZSB0aWxpbmcgb3BlcmF0aW9uKGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24pXG4gIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsOiAxMCxcbiAgLy8gR3Jhdml0eSByYW5nZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eVJhbmdlQ29tcG91bmQ6IDEuNSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eUNvbXBvdW5kOiAxLjAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KVxuICBncmF2aXR5UmFuZ2U6IDMuOCxcbiAgLy8gSW5pdGlhbCBjb29saW5nIGZhY3RvciBmb3IgaW5jcmVtZW50YWwgbGF5b3V0ICBcbiAgaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw6IDAuMyxcblxuICAvKiBjb25zdHJhaW50IG9wdGlvbnMgKi9cblxuICAvLyBGaXggcmVxdWlyZWQgbm9kZXMgdG8gcHJlZGVmaW5lZCBwb3NpdGlvbnNcbiAgLy8gW3tub2RlSWQ6ICduMScsIHBvc2l0aW9uOiB7eDogMTAwLCB5OiAyMDB9LCB7Li4ufV1cbiAgZml4ZWROb2RlQ29uc3RyYWludDogdW5kZWZpbmVkLFxuICAvLyBBbGlnbiByZXF1aXJlZCBub2RlcyBpbiB2ZXJ0aWNhbC9ob3Jpem9udGFsIGRpcmVjdGlvblxuICAvLyB7dmVydGljYWw6IFtbJ24xJywgJ24yJyldLCBbJ24zJywgJ240J11dLCBob3Jpem9udGFsOiBbJ24yJywgJ240J119XG4gIGFsaWdubWVudENvbnN0cmFpbnQ6IHVuZGVmaW5lZCxcbiAgLy8gUGxhY2UgdHdvIG5vZGVzIHJlbGF0aXZlbHkgaW4gdmVydGljYWwvaG9yaXpvbnRhbCBkaXJlY3Rpb24gXG4gIC8vIFt7dG9wOiAnbjEnLCBib3R0b206ICduMicsIGdhcDogMTAwfSwge2xlZnQ6ICduMycsIHJpZ2h0OiAnbjQnLCBnYXA6IDc1fV1cbiAgcmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50OiB1bmRlZmluZWQsXG5cbiAgLyogbGF5b3V0IGV2ZW50IGNhbGxiYWNrcyAqL1xuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9IC8vIG9uIGxheW91dHN0b3Bcbn0pO1xuXG52YXIgTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXlvdXQpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGF5b3V0LCBbe1xuICAgIGtleTogJ3J1bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG5cbiAgICAgIHZhciBzcGVjdHJhbFJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHhDb29yZHMgPSB2b2lkIDA7XG4gICAgICB2YXIgeUNvb3JkcyA9IHZvaWQgMDtcbiAgICAgIHZhciBjb3NlUmVzdWx0ID0gW107XG4gICAgICB2YXIgY29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICAgIHZhciBjb21wb25lbnRDZW50ZXJzID0gW107XG5cbiAgICAgIC8vIGJhc2ljIHZhbGlkaXR5IGNoZWNrIGZvciBjb25zdHJhaW50IGlucHV0cyBcbiAgICAgIGlmIChvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCkgfHwgb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aCA9PSAwKSkge1xuICAgICAgICBvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwubGVuZ3RoID09IDApKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsLmxlbmd0aCA9PSAwKSkge1xuICAgICAgICAgIG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHx8IG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50Lmxlbmd0aCA9PSAwKSkge1xuICAgICAgICBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYW55IGNvbnN0cmFpbnQgZXhpc3RzLCBzZXQgc29tZSBvcHRpb25zXG4gICAgICB2YXIgY29uc3RyYWludEV4aXN0ID0gb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50IHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludCB8fCBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDtcbiAgICAgIGlmIChjb25zdHJhaW50RXhpc3QpIHtcbiAgICAgICAgLy8gY29uc3RyYWludHMgd29yayB3aXRoIHRoZXNlIG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucy50aWxlID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMucGFja0NvbXBvbmVudHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVjaWRlIGNvbXBvbmVudCBwYWNraW5nIGlzIGVuYWJsZWQgb3Igbm90XG4gICAgICB2YXIgbGF5VXRpbCA9IHZvaWQgMDtcbiAgICAgIHZhciBwYWNraW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKGN5LmxheW91dFV0aWxpdGllcyAmJiBvcHRpb25zLnBhY2tDb21wb25lbnRzKSB7XG4gICAgICAgIGxheVV0aWwgPSBjeS5sYXlvdXRVdGlsaXRpZXMoXCJnZXRcIik7XG4gICAgICAgIGlmICghbGF5VXRpbCkgbGF5VXRpbCA9IGN5LmxheW91dFV0aWxpdGllcygpO1xuICAgICAgICBwYWNraW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVzLm5vZGVzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBpZiBwYWNraW5nIGlzIG5vdCBlbmFibGVkLCBwZXJmb3JtIGxheW91dCBvbiB0aGUgd2hvbGUgZ3JhcGhcbiAgICAgICAgaWYgKCFwYWNraW5nRW5hYmxlZCkge1xuICAgICAgICAgIC8vIHN0b3JlIGNvbXBvbmVudCBjZW50ZXJcbiAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBvcHRpb25zLmVsZXMuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnB1c2goeyB4OiBib3VuZGluZ0JveC54MSArIGJvdW5kaW5nQm94LncgLyAyLCB5OiBib3VuZGluZ0JveC55MSArIGJvdW5kaW5nQm94LmggLyAyIH0pO1xuICAgICAgICAgIC8vIGFwcGx5IHNwZWN0cmFsIGxheW91dFxuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpO1xuICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQucHVzaChyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhcHBseSBjb3NlIGxheW91dCBhcyBwb3N0cHJvY2Vzc2luZ1xuICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgICAgY29zZVJlc3VsdC5wdXNoKGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHRbMF0pKTtcbiAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzWzBdLCBjb3NlUmVzdWx0WzBdLCBvcHRpb25zKTsgLy8gcmVsb2NhdGUgY2VudGVyIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzWzBdLCBzcGVjdHJhbFJlc3VsdFswXSwgb3B0aW9ucyk7IC8vIHJlbG9jYXRlIGNlbnRlciB0byBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwYWNraW5nIGlzIGVuYWJsZWRcbiAgICAgICAgICB2YXIgdG9wTW9zdE5vZGVzID0gYXV4LmdldFRvcE1vc3ROb2RlcyhvcHRpb25zLmVsZXMubm9kZXMoKSk7XG4gICAgICAgICAgY29tcG9uZW50cyA9IGF1eC5jb25uZWN0Q29tcG9uZW50cyhjeSwgb3B0aW9ucy5lbGVzLCB0b3BNb3N0Tm9kZXMpO1xuICAgICAgICAgIC8vIHN0b3JlIGNvbXBvbmVudCBjZW50ZXJzXG4gICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IGNvbXBvbmVudC5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgY29tcG9uZW50Q2VudGVycy5wdXNoKHsgeDogYm91bmRpbmdCb3gueDEgKyBib3VuZGluZ0JveC53IC8gMiwgeTogYm91bmRpbmdCb3gueTEgKyBib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vc2VuZCBlYWNoIGNvbXBvbmVudCB0byBzcGVjdHJhbCBsYXlvdXQgaWYgcmFuZG9taXplZFxuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5lbGVzID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5wdXNoKHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgICAgdmFyIHRvQmVUaWxlZE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGlsZSkge1xuICAgICAgICAgICAgICAvLyBiZWhhdmUgbm9kZXMgdG8gYmUgdGlsZWQgYXMgb25lIGNvbXBvbmVudFxuICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIHZhciBfeENvb3JkcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgX3lDb29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgdmFyIHRlbXBTcGVjdHJhbFJlc3VsdCA9IHsgbm9kZUluZGV4ZXM6IG5vZGVJbmRleGVzLCB4Q29vcmRzOiBfeENvb3JkcywgeUNvb3JkczogX3lDb29yZHMgfTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ZXNUb0JlRGVsZXRlZCA9IFtdO1xuICAgICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmVkZ2VzKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9CZVRpbGVkTm9kZXMubWVyZ2UoY29tcG9uZW50Lm5vZGVzKClbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC5ub2RlSW5kZXhlcy5zZXQoY29tcG9uZW50Lm5vZGVzKClbaV0uaWQoKSwgY291bnQrKyk7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcFNwZWN0cmFsUmVzdWx0LnhDb29yZHMucHVzaChjb21wb25lbnQubm9kZXMoKVswXS5wb3NpdGlvbigpLngpO1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC55Q29vcmRzLnB1c2goY29tcG9uZW50Lm5vZGVzKClbMF0ucG9zaXRpb24oKS55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpbmRleGVzVG9CZURlbGV0ZWQucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHRvQmVUaWxlZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2JvdW5kaW5nQm94ID0gdG9CZVRpbGVkTm9kZXMuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnB1c2goeyB4OiBfYm91bmRpbmdCb3gueDEgKyBfYm91bmRpbmdCb3gudyAvIDIsIHk6IF9ib3VuZGluZ0JveC55MSArIF9ib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2godG9CZVRpbGVkTm9kZXMpO1xuICAgICAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LnB1c2godGVtcFNwZWN0cmFsUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXhlc1RvQmVEZWxldGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQuc3BsaWNlKGluZGV4ZXNUb0JlRGVsZXRlZFtpXSwgMSk7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAvLyBzZW5kIGVhY2ggY29tcG9uZW50IHRvIGNvc2UgbGF5b3V0XG4gICAgICAgICAgICAgIG9wdGlvbnMuZWxlcyA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgY29zZVJlc3VsdC5wdXNoKGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdKSk7XG4gICAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzW2luZGV4XSwgY29zZVJlc3VsdFtpbmRleF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgYXV4LnJlbG9jYXRlQ29tcG9uZW50KGNvbXBvbmVudENlbnRlcnNbaW5kZXhdLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHBhY2tpbmdcbiAgICAgICAgICB2YXIgY29tcG9uZW50c0V2YWx1YXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgc3ViZ3JhcGhzID0gW107XG4gICAgICAgICAgICB2YXIgaGlkZGVuRWxlcyA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZS5jc3MoJ2Rpc3BsYXknKSA9PSAnbm9uZSc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4ZXMgPSBzcGVjdHJhbFJlc3VsdFtpbmRleF0ubm9kZUluZGV4ZXM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm5vZGVzKCkubm90KGhpZGRlbkVsZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViZ3JhcGggPSB7fTtcbiAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHN1YmdyYXBoLm5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQubm9kZXMoKS5ub3QoaGlkZGVuRWxlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2Rlcy5wdXNoKHsgeDogc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHNbbm9kZUluZGV4XSAtIG5vZGUuYm91bmRpbmdib3goKS53IC8gMiwgeTogc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHNbbm9kZUluZGV4XSAtIG5vZGUuYm91bmRpbmdib3goKS5oIC8gMiwgd2lkdGg6IG5vZGUuYm91bmRpbmdib3goKS53LCBoZWlnaHQ6IG5vZGUuYm91bmRpbmdib3goKS5oIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveChub2RlLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2Rlcy5wdXNoKHsgeDogcGFyZW50SW5mby50b3BMZWZ0WCwgeTogcGFyZW50SW5mby50b3BMZWZ0WSwgd2lkdGg6IHBhcmVudEluZm8ud2lkdGgsIGhlaWdodDogcGFyZW50SW5mby5oZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgubm9kZXMucHVzaCh7IHg6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0TGVmdCgpLCB5OiBjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldLmdldFRvcCgpLCB3aWR0aDogY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXS5nZXRXaWR0aCgpLCBoZWlnaHQ6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0SGVpZ2h0KCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jc3MoXCJkaXNwbGF5XCIpICE9IFwibm9uZVwiICYmIHRhcmdldC5jc3MoXCJkaXNwbGF5XCIpICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5vZGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChzb3VyY2UuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldE5vZGVJbmRleCA9IG5vZGVJbmRleGVzLmdldCh0YXJnZXQuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUNlbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRDZW50ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveChzb3VyY2UsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkcywgbm9kZUluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2VudGVyLnB1c2gocGFyZW50SW5mby50b3BMZWZ0WCArIHBhcmVudEluZm8ud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHBhcmVudEluZm8udG9wTGVmdFkgKyBwYXJlbnRJbmZvLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDZW50ZXIucHVzaChzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkc1tzb3VyY2VOb2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzW3NvdXJjZU5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcGFyZW50SW5mbyA9IGF1eC5jYWxjQm91bmRpbmdCb3godGFyZ2V0LCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKF9wYXJlbnRJbmZvLnRvcExlZnRYICsgX3BhcmVudEluZm8ud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKF9wYXJlbnRJbmZvLnRvcExlZnRZICsgX3BhcmVudEluZm8uaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzW3RhcmdldE5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyLnB1c2goc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHNbdGFyZ2V0Tm9kZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLmVkZ2VzLnB1c2goeyBzdGFydFg6IHNvdXJjZUNlbnRlclswXSwgc3RhcnRZOiBzb3VyY2VDZW50ZXJbMV0sIGVuZFg6IHRhcmdldENlbnRlclswXSwgZW5kWTogdGFyZ2V0Q2VudGVyWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0gJiYgY29zZVJlc3VsdFtpbmRleF1bdGFyZ2V0LmlkKCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcy5wdXNoKHsgc3RhcnRYOiBjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0uZ2V0Q2VudGVyWCgpLCBzdGFydFk6IGNvc2VSZXN1bHRbaW5kZXhdW3NvdXJjZS5pZCgpXS5nZXRDZW50ZXJZKCksIGVuZFg6IGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXS5nZXRDZW50ZXJYKCksIGVuZFk6IGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXS5nZXRDZW50ZXJZKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmdyYXBoLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHN1YmdyYXBocy5wdXNoKHN1YmdyYXBoKTtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNFdmFsdWF0ZWQuYWRkKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHNoaWZ0UmVzdWx0ID0gbGF5VXRpbC5wYWNrQ29tcG9uZW50cyhzdWJncmFwaHMsIG9wdGlvbnMucmFuZG9taXplKS5zaGlmdHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1hDb29yZHMgPSByZXN1bHQueENvb3Jkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgc2hpZnRSZXN1bHRbaW5kZXhdLmR4O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdZQ29vcmRzID0gcmVzdWx0LnlDb29yZHMubWFwKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geSArIHNoaWZ0UmVzdWx0W2luZGV4XS5keTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQueENvb3JkcyA9IG5ld1hDb29yZHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnlDb29yZHMgPSBuZXdZQ29vcmRzO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfY291bnQgPSAwO1xuICAgICAgICAgICAgICBjb21wb25lbnRzRXZhbHVhdGVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29zZVJlc3VsdFtpbmRleF0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBub2RlUmVjdGFuZ2xlID0gY29zZVJlc3VsdFtpbmRleF1baXRlbV07XG4gICAgICAgICAgICAgICAgICBub2RlUmVjdGFuZ2xlLnNldENlbnRlcihub2RlUmVjdGFuZ2xlLmdldENlbnRlclgoKSArIHNoaWZ0UmVzdWx0W19jb3VudF0uZHgsIG5vZGVSZWN0YW5nbGUuZ2V0Q2VudGVyWSgpICsgc2hpZnRSZXN1bHRbX2NvdW50XS5keSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX2NvdW50Kys7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnZXQgZWFjaCBlbGVtZW50J3MgY2FsY3VsYXRlZCBwb3NpdGlvblxuICAgICAgdmFyIGdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhlbGUsIGkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRlZmF1bHRcIiB8fCBvcHRpb25zLnF1YWxpdHkgPT0gXCJwcm9vZlwiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGVsZSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRoZUlkID0gZWxlLmRhdGEoJ2lkJyk7XG4gICAgICAgICAgY29zZVJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aGVJZCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgcG9zID0geyB4OiByZXN1bHRbdGhlSWRdLmdldFJlY3QoKS5nZXRDZW50ZXJYKCksIHk6IHJlc3VsdFt0aGVJZF0uZ2V0UmVjdCgpLmdldENlbnRlclkoKSB9O1xuICAgICAgICAgICAgICBub2RlID0gcmVzdWx0W3RoZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxhYmVsV2lkdGgpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgcG9zLnggKz0gbm9kZS5sYWJlbFdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueCAtPSBub2RlLmxhYmVsV2lkdGggLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueSArPSBub2RlLmxhYmVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJib3R0b21cIikge1xuICAgICAgICAgICAgICAgIHBvcy55IC09IG5vZGUubGFiZWxIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3MgPT0gdW5kZWZpbmVkKSBwb3MgPSB7IHg6IGVsZS5wb3NpdGlvbihcInhcIiksIHk6IGVsZS5wb3NpdGlvbihcInlcIikgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgICB5OiBwb3MueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3MgPSB2b2lkIDA7XG4gICAgICAgICAgc3BlY3RyYWxSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubm9kZUluZGV4ZXMuZ2V0KGVsZS5pZCgpKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3BvcyA9IHsgeDogcmVzdWx0LnhDb29yZHNbaW5kZXhdLCB5OiByZXN1bHQueUNvb3Jkc1tpbmRleF0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoX3BvcyA9PSB1bmRlZmluZWQpIF9wb3MgPSB7IHg6IGVsZS5wb3NpdGlvbihcInhcIiksIHk6IGVsZS5wb3NpdGlvbihcInlcIikgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogX3Bvcy54LFxuICAgICAgICAgICAgeTogX3Bvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gcXVhbGl0eSA9IFwiZHJhZnRcIiBhbmQgcmFuZG9taXplID0gZmFsc2UgYXJlIGNvbnRyYWRpY3RpdmUgc28gaW4gdGhhdCBjYXNlIHBvc2l0aW9ucyBkb24ndCBjaGFuZ2VcbiAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIiB8fCBvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAvLyB0cmFuc2ZlciBjYWxjdWxhdGVkIHBvc2l0aW9ucyB0byBub2RlcyAocG9zaXRpb25zIG9mIG9ubHkgc2ltcGxlIG5vZGVzIGFyZSBldmFsdWF0ZWQsIGNvbXBvdW5kcyBhcmUgcG9zaXRpb25lZCBhdXRvbWF0aWNhbGx5KVxuICAgICAgICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGF1eC5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbihjeSwgZWxlcyk7XG4gICAgICAgIHZhciBfaGlkZGVuRWxlcyA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmNzcygnZGlzcGxheScpID09ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuZWxlcyA9IGVsZXMubm90KF9oaWRkZW5FbGVzKTtcblxuICAgICAgICBlbGVzLm5vZGVzKCkubm90KFwiOnBhcmVudFwiKS5ub3QoX2hpZGRlbkVsZXMpLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGdldFBvc2l0aW9ucyk7XG5cbiAgICAgICAgaWYgKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICBlbGUucG9zaXRpb24oZ2V0UG9zaXRpb25zKGVsZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIklmIHJhbmRvbWl6ZSBvcHRpb24gaXMgc2V0IHRvIGZhbHNlLCB0aGVuIHF1YWxpdHkgb3B0aW9uIG11c3QgYmUgJ2RlZmF1bHQnIG9yICdwcm9vZicuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXlvdXQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3BlY3RyYWwgbGF5b3V0IHRoYXQgaXMgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIGZjb3NlIGxheW91dCBhbGdvcml0aG1cbiovXG5cbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG52YXIgTWF0cml4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuTWF0cml4O1xudmFyIFNWRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLlNWRDtcblxuLy8gbWFpbiBmdW5jdGlvbiB0aGF0IHNwZWN0cmFsIGxheW91dCBpcyBwcm9jZXNzZWRcbnZhciBzcGVjdHJhbExheW91dCA9IGZ1bmN0aW9uIHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpIHtcblxuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICB2YXIgcGFyZW50Tm9kZXMgPSBlbGVzLm5vZGVzKFwiOnBhcmVudFwiKTtcblxuICB2YXIgZHVtbXlOb2RlcyA9IG5ldyBNYXAoKTsgLy8gbWFwIHRvIGtlZXAgZHVtbXkgbm9kZXMgYW5kIHRoZWlyIG5laWdoYm9yc1xuICB2YXIgbm9kZUluZGV4ZXMgPSBuZXcgTWFwKCk7IC8vIG1hcCB0byBrZWVwIGluZGV4ZXMgdG8gbm9kZXNcbiAgdmFyIHBhcmVudENoaWxkTWFwID0gbmV3IE1hcCgpOyAvLyBtYXBwaW5nIGJ0dy4gY29tcG91bmQgYW5kIGl0cyByZXByZXNlbnRhdGl2ZSBub2RlIFxuICB2YXIgYWxsTm9kZXNOZWlnaGJvcmhvb2QgPSBbXTsgLy8gYXJyYXkgdG8ga2VlcCBuZWlnaGJvcmhvb2Qgb2YgYWxsIG5vZGVzXG4gIHZhciB4Q29vcmRzID0gW107XG4gIHZhciB5Q29vcmRzID0gW107XG5cbiAgdmFyIHNhbXBsZXNDb2x1bW4gPSBbXTsgLy8gc2FtcGxlZCB2ZXJ0aWNlc1xuICB2YXIgbWluRGlzdGFuY2VzQ29sdW1uID0gW107XG4gIHZhciBDID0gW107IC8vIGNvbHVtbiBzYW1wbGluZyBtYXRyaXhcbiAgdmFyIFBISSA9IFtdOyAvLyBpbnRlcnNlY3Rpb24gb2YgY29sdW1uIGFuZCByb3cgc2FtcGxpbmcgbWF0cmljZXMgXG4gIHZhciBJTlYgPSBbXTsgLy8gaW52ZXJzZSBvZiBQSEkgXG5cbiAgdmFyIGZpcnN0U2FtcGxlID0gdm9pZCAwOyAvLyB0aGUgZmlyc3Qgc2FtcGxlZCBub2RlXG4gIHZhciBub2RlU2l6ZSA9IHZvaWQgMDtcblxuICB2YXIgaW5maW5pdHkgPSAxMDAwMDAwMDA7XG4gIHZhciBzbWFsbCA9IDAuMDAwMDAwMDAxO1xuXG4gIHZhciBwaVRvbCA9IG9wdGlvbnMucGlUb2w7XG4gIHZhciBzYW1wbGluZ1R5cGUgPSBvcHRpb25zLnNhbXBsaW5nVHlwZTsgLy8gZmFsc2UgZm9yIHJhbmRvbSwgdHJ1ZSBmb3IgZ3JlZWR5XG4gIHZhciBub2RlU2VwYXJhdGlvbiA9IG9wdGlvbnMubm9kZVNlcGFyYXRpb247XG4gIHZhciBzYW1wbGVTaXplID0gdm9pZCAwO1xuXG4gIC8qKioqIFNwZWN0cmFsLXByZXByb2Nlc3NpbmcgZnVuY3Rpb25zICoqKiovXG5cbiAgLyoqKiogU3BlY3RyYWwgbGF5b3V0IGZ1bmN0aW9ucyAqKioqL1xuXG4gIC8vIGRldGVybWluZSB3aGljaCBjb2x1bW5zIHRvIGJlIHNhbXBsZWRcbiAgdmFyIHJhbmRvbVNhbXBsZUNSID0gZnVuY3Rpb24gcmFuZG9tU2FtcGxlQ1IoKSB7XG4gICAgdmFyIHNhbXBsZSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGNvdW50IDwgc2FtcGxlU2l6ZSkge1xuICAgICAgc2FtcGxlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZVNpemUpO1xuXG4gICAgICBmbGFnID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgaWYgKHNhbXBsZXNDb2x1bW5baV0gPT0gc2FtcGxlKSB7XG4gICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgIHNhbXBsZXNDb2x1bW5bY291bnRdID0gc2FtcGxlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHRha2VzIHRoZSBpbmRleCBvZiB0aGUgbm9kZShwaXZvdCkgdG8gaW5pdGlhdGUgQkZTIGFzIGEgcGFyYW1ldGVyXG4gIHZhciBCRlMgPSBmdW5jdGlvbiBCRlMocGl2b3QsIGluZGV4LCBzYW1wbGluZ01ldGhvZCkge1xuICAgIHZhciBwYXRoID0gW107IC8vIHRoZSBmcm9udCBvZiB0aGUgcGF0aFxuICAgIHZhciBmcm9udCA9IDA7IC8vIHRoZSBiYWNrIG9mIHRoZSBwYXRoXG4gICAgdmFyIGJhY2sgPSAwO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgdGVtcCA9IHZvaWQgMDtcbiAgICB2YXIgZGlzdGFuY2UgPSBbXTtcblxuICAgIHZhciBtYXhfZGlzdCA9IDA7IC8vIHRoZSBmdXJ0aGVzdCBub2RlIHRvIGJlIHJldHVybmVkXG4gICAgdmFyIG1heF9pbmQgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2l6ZTsgaSsrKSB7XG4gICAgICBkaXN0YW5jZVtpXSA9IGluZmluaXR5O1xuICAgIH1cblxuICAgIHBhdGhbYmFja10gPSBwaXZvdDtcbiAgICBkaXN0YW5jZVtwaXZvdF0gPSAwO1xuXG4gICAgd2hpbGUgKGJhY2sgPj0gZnJvbnQpIHtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2Zyb250KytdO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGFsbE5vZGVzTmVpZ2hib3Job29kW2N1cnJlbnRdO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5laWdoYm9ycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGVtcCA9IG5vZGVJbmRleGVzLmdldChuZWlnaGJvcnNbX2ldKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlW3RlbXBdID09IGluZmluaXR5KSB7XG4gICAgICAgICAgZGlzdGFuY2VbdGVtcF0gPSBkaXN0YW5jZVtjdXJyZW50XSArIDE7XG4gICAgICAgICAgcGF0aFsrK2JhY2tdID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ1tjdXJyZW50XVtpbmRleF0gPSBkaXN0YW5jZVtjdXJyZW50XSAqIG5vZGVTZXBhcmF0aW9uO1xuICAgIH1cblxuICAgIGlmIChzYW1wbGluZ01ldGhvZCkge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZVNpemU7IF9pMisrKSB7XG4gICAgICAgIGlmIChDW19pMl1baW5kZXhdIDwgbWluRGlzdGFuY2VzQ29sdW1uW19pMl0pIG1pbkRpc3RhbmNlc0NvbHVtbltfaTJdID0gQ1tfaTJdW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZVNpemU7IF9pMysrKSB7XG4gICAgICAgIGlmIChtaW5EaXN0YW5jZXNDb2x1bW5bX2kzXSA+IG1heF9kaXN0KSB7XG4gICAgICAgICAgbWF4X2Rpc3QgPSBtaW5EaXN0YW5jZXNDb2x1bW5bX2kzXTtcbiAgICAgICAgICBtYXhfaW5kID0gX2kzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhfaW5kO1xuICB9O1xuXG4gIC8vIGFwcGx5IEJGUyB0byBhbGwgbm9kZXMgb3Igc2VsZWN0ZWQgc2FtcGxlc1xuICB2YXIgYWxsQkZTID0gZnVuY3Rpb24gYWxsQkZTKHNhbXBsaW5nTWV0aG9kKSB7XG5cbiAgICB2YXIgc2FtcGxlID0gdm9pZCAwO1xuXG4gICAgaWYgKCFzYW1wbGluZ01ldGhvZCkge1xuICAgICAgcmFuZG9tU2FtcGxlQ1IoKTtcblxuICAgICAgLy8gY2FsbCBCRlNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlU2l6ZTsgaSsrKSB7XG4gICAgICAgIEJGUyhzYW1wbGVzQ29sdW1uW2ldLCBpLCBzYW1wbGluZ01ldGhvZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzYW1wbGUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2RlU2l6ZSk7XG4gICAgICBmaXJzdFNhbXBsZSA9IHNhbXBsZTtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZVNpemU7IF9pNCsrKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlc0NvbHVtbltfaTRdID0gaW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHNhbXBsZVNpemU7IF9pNSsrKSB7XG4gICAgICAgIHNhbXBsZXNDb2x1bW5bX2k1XSA9IHNhbXBsZTtcbiAgICAgICAgc2FtcGxlID0gQkZTKHNhbXBsZSwgX2k1LCBzYW1wbGluZ01ldGhvZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9ybSB0aGUgc3F1YXJlZCBkaXN0YW5jZXMgZm9yIENcbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBub2RlU2l6ZTsgX2k2KyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2FtcGxlU2l6ZTsgaisrKSB7XG4gICAgICAgIENbX2k2XVtqXSAqPSBDW19pNl1bal07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9ybSBQSElcbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBzYW1wbGVTaXplOyBfaTcrKykge1xuICAgICAgUEhJW19pN10gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBzYW1wbGVTaXplOyBfaTgrKykge1xuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHNhbXBsZVNpemU7IF9qKyspIHtcbiAgICAgICAgUEhJW19pOF1bX2pdID0gQ1tzYW1wbGVzQ29sdW1uW19qXV1bX2k4XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcGVyZm9ybSB0aGUgU1ZEIGFsZ29yaXRobSBhbmQgYXBwbHkgYSByZWd1bGFyaXphdGlvbiBzdGVwXG4gIHZhciBzYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUoKSB7XG5cbiAgICB2YXIgU1ZEUmVzdWx0ID0gU1ZELnN2ZChQSEkpO1xuXG4gICAgdmFyIGFfcSA9IFNWRFJlc3VsdC5TO1xuICAgIHZhciBhX3UgPSBTVkRSZXN1bHQuVTtcbiAgICB2YXIgYV92ID0gU1ZEUmVzdWx0LlY7XG5cbiAgICB2YXIgbWF4X3MgPSBhX3FbMF0gKiBhX3FbMF0gKiBhX3FbMF07XG5cbiAgICB2YXIgYV9TaWcgPSBbXTtcblxuICAgIC8vICByZWd1bGFyaXphdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlU2l6ZTsgaSsrKSB7XG4gICAgICBhX1NpZ1tpXSA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzYW1wbGVTaXplOyBqKyspIHtcbiAgICAgICAgYV9TaWdbaV1bal0gPSAwO1xuICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgYV9TaWdbaV1bal0gPSBhX3FbaV0gLyAoYV9xW2ldICogYV9xW2ldICsgbWF4X3MgLyAoYV9xW2ldICogYV9xW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBJTlYgPSBNYXRyaXgubXVsdE1hdChNYXRyaXgubXVsdE1hdChhX3YsIGFfU2lnKSwgTWF0cml4LnRyYW5zcG9zZShhX3UpKTtcbiAgfTtcblxuICAvLyBjYWxjdWxhdGUgZmluYWwgY29vcmRpbmF0ZXMgXG4gIHZhciBwb3dlckl0ZXJhdGlvbiA9IGZ1bmN0aW9uIHBvd2VySXRlcmF0aW9uKCkge1xuICAgIC8vIHR3byBsYXJnZXN0IGVpZ2VudmFsdWVzXG4gICAgdmFyIHRoZXRhMSA9IHZvaWQgMDtcbiAgICB2YXIgdGhldGEyID0gdm9pZCAwO1xuXG4gICAgLy8gaW5pdGlhbCBndWVzc2VzIGZvciBlaWdlbnZlY3RvcnNcbiAgICB2YXIgWTEgPSBbXTtcbiAgICB2YXIgWTIgPSBbXTtcblxuICAgIHZhciBWMSA9IFtdO1xuICAgIHZhciBWMiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2l6ZTsgaSsrKSB7XG4gICAgICBZMVtpXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICBZMltpXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgfVxuXG4gICAgWTEgPSBNYXRyaXgubm9ybWFsaXplKFkxKTtcbiAgICBZMiA9IE1hdHJpeC5ub3JtYWxpemUoWTIpO1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICAvLyB0byBrZWVwIHRyYWNrIG9mIHRoZSBpbXByb3ZlbWVudCByYXRpbyBpbiBwb3dlciBpdGVyYXRpb25cbiAgICB2YXIgY3VycmVudCA9IHNtYWxsO1xuICAgIHZhciBwcmV2aW91cyA9IHNtYWxsO1xuXG4gICAgdmFyIHRlbXAgPSB2b2lkIDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY291bnQrKztcblxuICAgICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgbm9kZVNpemU7IF9pOSsrKSB7XG4gICAgICAgIFYxW19pOV0gPSBZMVtfaTldO1xuICAgICAgfVxuXG4gICAgICBZMSA9IE1hdHJpeC5tdWx0R2FtbWEoTWF0cml4Lm11bHRMKE1hdHJpeC5tdWx0R2FtbWEoVjEpLCBDLCBJTlYpKTtcbiAgICAgIHRoZXRhMSA9IE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBZMSk7XG4gICAgICBZMSA9IE1hdHJpeC5ub3JtYWxpemUoWTEpO1xuXG4gICAgICBjdXJyZW50ID0gTWF0cml4LmRvdFByb2R1Y3QoVjEsIFkxKTtcblxuICAgICAgdGVtcCA9IE1hdGguYWJzKGN1cnJlbnQgLyBwcmV2aW91cyk7XG5cbiAgICAgIGlmICh0ZW1wIDw9IDEgKyBwaVRvbCAmJiB0ZW1wID49IDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IG5vZGVTaXplOyBfaTEwKyspIHtcbiAgICAgIFYxW19pMTBdID0gWTFbX2kxMF07XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZpb3VzID0gc21hbGw7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvdW50Kys7XG5cbiAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgbm9kZVNpemU7IF9pMTErKykge1xuICAgICAgICBWMltfaTExXSA9IFkyW19pMTFdO1xuICAgICAgfVxuXG4gICAgICBWMiA9IE1hdHJpeC5taW51c09wKFYyLCBNYXRyaXgubXVsdENvbnMoVjEsIE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBWMikpKTtcbiAgICAgIFkyID0gTWF0cml4Lm11bHRHYW1tYShNYXRyaXgubXVsdEwoTWF0cml4Lm11bHRHYW1tYShWMiksIEMsIElOVikpO1xuICAgICAgdGhldGEyID0gTWF0cml4LmRvdFByb2R1Y3QoVjIsIFkyKTtcbiAgICAgIFkyID0gTWF0cml4Lm5vcm1hbGl6ZShZMik7XG5cbiAgICAgIGN1cnJlbnQgPSBNYXRyaXguZG90UHJvZHVjdChWMiwgWTIpO1xuXG4gICAgICB0ZW1wID0gTWF0aC5hYnMoY3VycmVudCAvIHByZXZpb3VzKTtcblxuICAgICAgaWYgKHRlbXAgPD0gMSArIHBpVG9sICYmIHRlbXAgPj0gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbm9kZVNpemU7IF9pMTIrKykge1xuICAgICAgVjJbX2kxMl0gPSBZMltfaTEyXTtcbiAgICB9XG5cbiAgICAvLyB0aGV0YTEgbm93IGNvbnRhaW5zIGRvbWluYW50IGVpZ2VudmFsdWVcbiAgICAvLyB0aGV0YTIgbm93IGNvbnRhaW5zIHRoZSBzZWNvbmQtbGFyZ2VzdCBlaWdlbnZhbHVlXG4gICAgLy8gVjEgbm93IGNvbnRhaW5zIHRoZXRhMSdzIGVpZ2VudmVjdG9yXG4gICAgLy8gVjIgbm93IGNvbnRhaW5zIHRoZXRhMidzIGVpZ2VudmVjdG9yXG5cbiAgICAvL3BvcHVsYXRlIHRoZSB0d28gdmVjdG9yc1xuICAgIHhDb29yZHMgPSBNYXRyaXgubXVsdENvbnMoVjEsIE1hdGguc3FydChNYXRoLmFicyh0aGV0YTEpKSk7XG4gICAgeUNvb3JkcyA9IE1hdHJpeC5tdWx0Q29ucyhWMiwgTWF0aC5zcXJ0KE1hdGguYWJzKHRoZXRhMikpKTtcbiAgfTtcblxuICAvKioqKiBQcmVwYXJhdGlvbiBmb3Igc3BlY3RyYWwgbGF5b3V0IChQcmVwcm9jZXNzaW5nKSAqKioqL1xuXG4gIC8vIGNvbm5lY3QgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgKGZpcnN0IHRvcCBsZXZlbCwgdGhlbiBpbnNpZGUgb2YgZWFjaCBjb21wb3VuZCBub2RlKVxuICBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIGVsZXMsIGF1eC5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpLCBkdW1teU5vZGVzKTtcblxuICBwYXJlbnROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIGVsZXMsIGF1eC5nZXRUb3BNb3N0Tm9kZXMoZWxlLmRlc2NlbmRhbnRzKCkuaW50ZXJzZWN0aW9uKGVsZXMpKSwgZHVtbXlOb2Rlcyk7XG4gIH0pO1xuXG4gIC8vIGFzc2lnbiBpbmRleGVzIHRvIG5vZGVzIChmaXJzdCByZWFsLCB0aGVuIGR1bW15IG5vZGVzKVxuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFub2Rlc1tpXS5pc1BhcmVudCgpKSB7XG4gICAgICBub2RlSW5kZXhlcy5zZXQobm9kZXNbaV0uaWQoKSwgaW5kZXgrKyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZHVtbXlOb2Rlcy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIG5vZGVJbmRleGVzLnNldChrZXksIGluZGV4KyspO1xuICAgIH1cblxuICAgIC8vIGluc3RhbnRpYXRlIHRoZSBuZWlnaGJvcmhvb2QgbWF0cml4XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kxMyA9IDA7IF9pMTMgPCBub2RlSW5kZXhlcy5zaXplOyBfaTEzKyspIHtcbiAgICBhbGxOb2Rlc05laWdoYm9yaG9vZFtfaTEzXSA9IFtdO1xuICB9XG5cbiAgLy8gZm9ybSBhIHBhcmVudC1jaGlsZCBtYXAgdG8ga2VlcCByZXByZXNlbnRhdGl2ZSBub2RlIG9mIGVhY2ggY29tcG91bmQgbm9kZSAgXG4gIHBhcmVudE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZS5jaGlsZHJlbigpLmludGVyc2VjdGlvbihlbGVzKTtcblxuICAgIC8vICAgICAgbGV0IHJhbmRvbSA9IDA7XG4gICAgd2hpbGUgKGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKS5sZW5ndGggPT0gMCkge1xuICAgICAgLy8gICAgICAgIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoaWxkcmVuLm5vZGVzKCkubGVuZ3RoKTsgLy8gaWYgYWxsIGNoaWxkcmVuIGFyZSBjb21wb3VuZCB0aGVuIHByb2NlZWQgcmFuZG9tbHlcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ubm9kZXMoKVswXS5jaGlsZHJlbigpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICB9XG4gICAgLy8gIHNlbGVjdCB0aGUgcmVwcmVzZW50YXRpdmUgbm9kZSAtIHdlIGNhbiBhcHBseSBkaWZmZXJlbnQgbWV0aG9kcyBoZXJlXG4gICAgLy8gICAgICByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIikubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBtaW4gPSBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIilbMF0uY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpLmZvckVhY2goZnVuY3Rpb24gKGVsZTIsIGkpIHtcbiAgICAgIGlmIChlbGUyLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGVsZTIuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwYXJlbnRDaGlsZE1hcC5zZXQoZWxlLmlkKCksIGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKVtpbmRleF0uaWQoKSk7XG4gIH0pO1xuXG4gIC8vIGFkZCBuZWlnaGJvcmhvb2QgcmVsYXRpb25zIChmaXJzdCByZWFsLCB0aGVuIGR1bW15IG5vZGVzKVxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgZWxlSW5kZXggPSB2b2lkIDA7XG5cbiAgICBpZiAoZWxlLmlzUGFyZW50KCkpIGVsZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KHBhcmVudENoaWxkTWFwLmdldChlbGUuaWQoKSkpO2Vsc2UgZWxlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQoZWxlLmlkKCkpO1xuXG4gICAgZWxlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKGVsZXMuaW50ZXJzZWN0aW9uKGVsZS5lZGdlc1dpdGgobm9kZSkpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKG5vZGUuaXNQYXJlbnQoKSkgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2gocGFyZW50Q2hpbGRNYXAuZ2V0KG5vZGUuaWQoKSkpO2Vsc2UgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2gobm9kZS5pZCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2tleSkge1xuICAgIHZhciBlbGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChfa2V5KTtcbiAgICB2YXIgZGlzY29ubmVjdGVkSWQgPSB2b2lkIDA7XG4gICAgZHVtbXlOb2Rlcy5nZXQoX2tleSkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChjeS5nZXRFbGVtZW50QnlJZChpZCkuaXNQYXJlbnQoKSkgZGlzY29ubmVjdGVkSWQgPSBwYXJlbnRDaGlsZE1hcC5nZXQoaWQpO2Vsc2UgZGlzY29ubmVjdGVkSWQgPSBpZDtcblxuICAgICAgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2goZGlzY29ubmVjdGVkSWQpO1xuICAgICAgYWxsTm9kZXNOZWlnaGJvcmhvb2Rbbm9kZUluZGV4ZXMuZ2V0KGRpc2Nvbm5lY3RlZElkKV0ucHVzaChfa2V5KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZHVtbXlOb2Rlcy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgIHZhciBfa2V5ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICBfbG9vcChfa2V5KTtcbiAgICB9XG5cbiAgICAvLyBub2RlU2l6ZSBub3cgb25seSBjb25zaWRlcnMgdGhlIHNpemUgb2YgdHJhbnNmb3JtZWQgZ3JhcGhcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbm9kZVNpemUgPSBub2RlSW5kZXhlcy5zaXplO1xuXG4gIHZhciBzcGVjdHJhbFJlc3VsdCA9IHZvaWQgMDtcblxuICAvLyBJZiBudW1iZXIgb2Ygbm9kZXMgaW4gdHJhbnNmb3JtZWQgZ3JhcGggaXMgMSBvciAyLCBlaXRoZXIgU1ZEIG9yIHBvd2VySXRlcmF0aW9uIGNhdXNlcyBwcm9ibGVtXG4gIC8vIFNvIHNraXAgc3BlY3RyYWwgYW5kIGxheW91dCB0aGUgZ3JhcGggd2l0aCBjb3NlXG4gIGlmIChub2RlU2l6ZSA+IDIpIHtcbiAgICAvLyBpZiAjIG9mIG5vZGVzIGluIHRyYW5zZm9ybWVkIGdyYXBoIGlzIHNtYWxsZXIgdGhhbiBzYW1wbGUgc2l6ZSxcbiAgICAvLyB0aGVuIHVzZSAjIG9mIG5vZGVzIGFzIHNhbXBsZSBzaXplXG4gICAgc2FtcGxlU2l6ZSA9IG5vZGVTaXplIDwgb3B0aW9ucy5zYW1wbGVTaXplID8gbm9kZVNpemUgOiBvcHRpb25zLnNhbXBsZVNpemU7XG5cbiAgICAvLyBpbnN0YW50aWF0ZXMgdGhlIHBhcnRpYWwgbWF0cmljZXMgdGhhdCB3aWxsIGJlIHVzZWQgaW4gc3BlY3RyYWwgbGF5b3V0XG4gICAgZm9yICh2YXIgX2kxNCA9IDA7IF9pMTQgPCBub2RlU2l6ZTsgX2kxNCsrKSB7XG4gICAgICBDW19pMTRdID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIF9pMTUgPSAwOyBfaTE1IDwgc2FtcGxlU2l6ZTsgX2kxNSsrKSB7XG4gICAgICBJTlZbX2kxNV0gPSBbXTtcbiAgICB9XG5cbiAgICAvKioqKiBBcHBseSBzcGVjdHJhbCBsYXlvdXQgKioqKi9cblxuICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiIHx8IG9wdGlvbnMuc3RlcCA9PSBcImFsbFwiKSB7XG4gICAgICBhbGxCRlMoc2FtcGxpbmdUeXBlKTtcbiAgICAgIHNhbXBsZSgpO1xuICAgICAgcG93ZXJJdGVyYXRpb24oKTtcblxuICAgICAgc3BlY3RyYWxSZXN1bHQgPSB7IG5vZGVJbmRleGVzOiBub2RlSW5kZXhlcywgeENvb3JkczogeENvb3JkcywgeUNvb3JkczogeUNvb3JkcyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHhDb29yZHMucHVzaChjeS5nZXRFbGVtZW50QnlJZChrZXkpLnBvc2l0aW9uKFwieFwiKSk7XG4gICAgICAgIHlDb29yZHMucHVzaChjeS5nZXRFbGVtZW50QnlJZChrZXkpLnBvc2l0aW9uKFwieVwiKSk7XG4gICAgICB9KTtcbiAgICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWN0cmFsUmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvciA9IG5vZGVJbmRleGVzLmtleXMoKTtcbiAgICB2YXIgZmlyc3ROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB2YXIgZmlyc3ROb2RlUG9zID0gZmlyc3ROb2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIGZpcnN0Tm9kZVdpZHRoID0gZmlyc3ROb2RlLm91dGVyV2lkdGgoKTtcbiAgICB4Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLngpO1xuICAgIHlDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueSk7XG4gICAgaWYgKG5vZGVTaXplID09IDIpIHtcbiAgICAgIHZhciBzZWNvbmROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICAgIHZhciBzZWNvbmROb2RlV2lkdGggPSBzZWNvbmROb2RlLm91dGVyV2lkdGgoKTtcbiAgICAgIHhDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueCArIGZpcnN0Tm9kZVdpZHRoIC8gMiArIHNlY29uZE5vZGVXaWR0aCAvIDIgKyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCk7XG4gICAgICB5Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLnkpO1xuICAgIH1cblxuICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICByZXR1cm4gc3BlY3RyYWxSZXN1bHQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBzcGVjdHJhbExheW91dDogc3BlY3RyYWxMYXlvdXQgfTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU3OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBpbXBsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTIpO1xuXG4vLyByZWdpc3RlcnMgdGhlIGV4dGVuc2lvbiBvbiBhIGN5dG9zY2FwZSBsaWIgcmVmXG52YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihjeXRvc2NhcGUpIHtcbiAgaWYgKCFjeXRvc2NhcGUpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gY2FuJ3QgcmVnaXN0ZXIgaWYgY3l0b3NjYXBlIHVuc3BlY2lmaWVkXG5cbiAgY3l0b3NjYXBlKCdsYXlvdXQnLCAnZmNvc2UnLCBpbXBsKTsgLy8gcmVnaXN0ZXIgd2l0aCBjeXRvc2NhcGUuanNcbn07XG5cbmlmICh0eXBlb2YgY3l0b3NjYXBlICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBleHBvc2UgdG8gZ2xvYmFsIGN5dG9zY2FwZSAoaS5lLiB3aW5kb3cuY3l0b3NjYXBlKVxuICByZWdpc3RlcihjeXRvc2NhcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQwOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNDBfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzkpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/cytoscape-fcose/cytoscape-fcose.js\n");

/***/ }),

/***/ "./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(\"./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__551__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 45:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_630__) => {\n\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __nested_webpack_require_630__(551);\ncoseBase.CoSEConstants = __nested_webpack_require_630__(806);\ncoseBase.CoSEEdge = __nested_webpack_require_630__(767);\ncoseBase.CoSEGraph = __nested_webpack_require_630__(880);\ncoseBase.CoSEGraphManager = __nested_webpack_require_630__(578);\ncoseBase.CoSELayout = __nested_webpack_require_630__(765);\ncoseBase.CoSENode = __nested_webpack_require_630__(991);\ncoseBase.ConstraintHandler = __nested_webpack_require_630__(902);\n\nmodule.exports = coseBase;\n\n/***/ }),\n\n/***/ 806:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1167__) => {\n\n\n\nvar FDLayoutConstants = __nested_webpack_require_1167__(551).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\nCoSEConstants.ENFORCE_CONSTRAINTS = true;\nCoSEConstants.APPLY_LAYOUT = true;\nCoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n// This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n// an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\nCoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n\n/***/ 767:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2468__) => {\n\n\n\nvar FDLayoutEdge = __nested_webpack_require_2468__(551).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n\n/***/ 880:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2879__) => {\n\n\n\nvar LGraph = __nested_webpack_require_2879__(551).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n\n/***/ 578:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3264__) => {\n\n\n\nvar LGraphManager = __nested_webpack_require_3264__(551).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n\n/***/ 765:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3683__) => {\n\n\n\nvar FDLayout = __nested_webpack_require_3683__(551).FDLayout;\nvar CoSEGraphManager = __nested_webpack_require_3683__(578);\nvar CoSEGraph = __nested_webpack_require_3683__(880);\nvar CoSENode = __nested_webpack_require_3683__(991);\nvar CoSEEdge = __nested_webpack_require_3683__(767);\nvar CoSEConstants = __nested_webpack_require_3683__(806);\nvar ConstraintHandler = __nested_webpack_require_3683__(902);\nvar FDLayoutConstants = __nested_webpack_require_3683__(551).FDLayoutConstants;\nvar LayoutConstants = __nested_webpack_require_3683__(551).LayoutConstants;\nvar Point = __nested_webpack_require_3683__(551).Point;\nvar PointD = __nested_webpack_require_3683__(551).PointD;\nvar DimensionD = __nested_webpack_require_3683__(551).DimensionD;\nvar Layout = __nested_webpack_require_3683__(551).Layout;\nvar Integer = __nested_webpack_require_3683__(551).Integer;\nvar IGeometry = __nested_webpack_require_3683__(551).IGeometry;\nvar LGraph = __nested_webpack_require_3683__(551).LGraph;\nvar Transform = __nested_webpack_require_3683__(551).Transform;\nvar LinkedList = __nested_webpack_require_3683__(551).LinkedList;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n  this.constraints = {}; // keep layout constraints\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n  }\n};\n\n// This method is used to set CoSE related parameters used by spring embedder.\nCoSELayout.prototype.initSpringEmbedder = function () {\n  FDLayout.prototype.initSpringEmbedder.call(this);\n\n  // variables for cooling\n  this.coolingCycle = 0;\n  this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n  this.finalTemperature = 0.04;\n  this.coolingAdjuster = 1;\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    ConstraintHandler.handleConstraints(this);\n    this.initConstraintVariables();\n  }\n\n  this.initSpringEmbedder();\n  if (CoSEConstants.APPLY_LAYOUT) {\n    this.runSpringEmbedder();\n  }\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\n// overrides moveNodes method in FDLayout\nCoSELayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  // calculate displacement for each node \n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.calculateDisplacement();\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    this.updateDisplacements();\n  }\n\n  // move each node\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\n// constraint related methods: initConstraintVariables and updateDisplacements\n\n// initialize constraint related variables\nCoSELayout.prototype.initConstraintVariables = function () {\n  var self = this;\n  this.idToNodeMap = new Map();\n  this.fixedNodeSet = new Set();\n\n  var allNodes = this.graphManager.getAllNodes();\n\n  // fill idToNodeMap\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    this.idToNodeMap.set(node.id, node);\n  }\n\n  // calculate fixed node weight for given compound node\n  var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n    var nodes = compoundNode.getChild().getNodes();\n    var node;\n    var fixedNodeWeight = 0;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      if (node.getChild() == null) {\n        if (self.fixedNodeSet.has(node.id)) {\n          fixedNodeWeight += 100;\n        }\n      } else {\n        fixedNodeWeight += calculateCompoundWeight(node);\n      }\n    }\n    return fixedNodeWeight;\n  };\n\n  if (this.constraints.fixedNodeConstraint) {\n    // fill fixedNodeSet\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      self.fixedNodeSet.add(nodeData.nodeId);\n    });\n\n    // assign fixed node weights to compounds if they contain fixed nodes\n    var allNodes = this.graphManager.getAllNodes();\n    var node;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getChild() != null) {\n        var fixedNodeWeight = calculateCompoundWeight(node);\n        if (fixedNodeWeight > 0) {\n          node.fixedNodeWeight = fixedNodeWeight;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n    var nodeToDummyForVerticalAlignment = new Map();\n    var nodeToDummyForHorizontalAlignment = new Map();\n    this.dummyToNodeForVerticalAlignment = new Map();\n    this.dummyToNodeForHorizontalAlignment = new Map();\n    this.fixedNodesOnHorizontal = new Set();\n    this.fixedNodesOnVertical = new Set();\n\n    // fill maps and sets\n    this.fixedNodeSet.forEach(function (nodeId) {\n      self.fixedNodesOnHorizontal.add(nodeId);\n      self.fixedNodesOnVertical.add(nodeId);\n    });\n\n    if (this.constraints.alignmentConstraint) {\n      if (this.constraints.alignmentConstraint.vertical) {\n        var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n        for (var i = 0; i < verticalAlignment.length; i++) {\n          this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n          verticalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n      if (this.constraints.alignmentConstraint.horizontal) {\n        var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n        for (var i = 0; i < horizontalAlignment.length; i++) {\n          this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n          horizontalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnVertical.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n    }\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n\n      this.shuffle = function (array) {\n        var j, x, i;\n        for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n          j = Math.floor(Math.random() * (i + 1));\n          x = array[i];\n          array[i] = array[j];\n          array[j] = x;\n        }\n        return array;\n      };\n\n      this.nodesInRelativeHorizontal = [];\n      this.nodesInRelativeVertical = [];\n      this.nodeToRelativeConstraintMapHorizontal = new Map();\n      this.nodeToRelativeConstraintMapVertical = new Map();\n      this.nodeToTempPositionMapHorizontal = new Map();\n      this.nodeToTempPositionMapVertical = new Map();\n\n      // fill arrays and maps\n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n            self.nodesInRelativeHorizontal.push(nodeIdLeft);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n            }\n          }\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n            self.nodesInRelativeHorizontal.push(nodeIdRight);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n            }\n          }\n\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({ right: nodeIdRight, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({ left: nodeIdLeft, gap: constraint.gap });\n        } else {\n          var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n\n          if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n            self.nodesInRelativeVertical.push(nodeIdTop);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n            }\n          }\n          if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n            self.nodesInRelativeVertical.push(nodeIdBottom);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n            }\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({ bottom: nodeIdBottom, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({ top: nodeIdTop, gap: constraint.gap });\n        }\n      });\n    } else {\n      var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n      var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n      // construct subgraphs from relative placement constraints \n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n          if (subGraphOnHorizontal.has(left)) {\n            subGraphOnHorizontal.get(left).push(right);\n          } else {\n            subGraphOnHorizontal.set(left, [right]);\n          }\n          if (subGraphOnHorizontal.has(right)) {\n            subGraphOnHorizontal.get(right).push(left);\n          } else {\n            subGraphOnHorizontal.set(right, [left]);\n          }\n        } else {\n          var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n          if (subGraphOnVertical.has(top)) {\n            subGraphOnVertical.get(top).push(bottom);\n          } else {\n            subGraphOnVertical.set(top, [bottom]);\n          }\n          if (subGraphOnVertical.has(bottom)) {\n            subGraphOnVertical.get(bottom).push(top);\n          } else {\n            subGraphOnVertical.set(bottom, [top]);\n          }\n        }\n      });\n\n      // function to construct components from a given graph \n      // also returns an array that keeps whether each component contains fixed node\n      var constructComponents = function constructComponents(graph, fixedNodes) {\n        var components = [];\n        var isFixed = [];\n        var queue = new LinkedList();\n        var visited = new Set();\n        var count = 0;\n\n        graph.forEach(function (value, key) {\n          if (!visited.has(key)) {\n            components[count] = [];\n            isFixed[count] = false;\n            var currentNode = key;\n            queue.push(currentNode);\n            visited.add(currentNode);\n            components[count].push(currentNode);\n\n            while (queue.length != 0) {\n              currentNode = queue.shift();\n              if (fixedNodes.has(currentNode)) {\n                isFixed[count] = true;\n              }\n              var neighbors = graph.get(currentNode);\n              neighbors.forEach(function (neighbor) {\n                if (!visited.has(neighbor)) {\n                  queue.push(neighbor);\n                  visited.add(neighbor);\n                  components[count].push(neighbor);\n                }\n              });\n            }\n            count++;\n          }\n        });\n\n        return { components: components, isFixed: isFixed };\n      };\n\n      var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n      this.componentsOnHorizontal = resultOnHorizontal.components;\n      this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n      var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n      this.componentsOnVertical = resultOnVertical.components;\n      this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n    }\n  }\n};\n\n// updates node displacements based on constraints\nCoSELayout.prototype.updateDisplacements = function () {\n  var self = this;\n  if (this.constraints.fixedNodeConstraint) {\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n      fixedNode.displacementX = 0;\n      fixedNode.displacementY = 0;\n    });\n  }\n\n  if (this.constraints.alignmentConstraint) {\n    if (this.constraints.alignmentConstraint.vertical) {\n      var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n      for (var i = 0; i < allVerticalAlignments.length; i++) {\n        var totalDisplacementX = 0;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n            totalDisplacementX = 0;\n            break;\n          }\n          totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n        }\n        var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n        }\n      }\n    }\n    if (this.constraints.alignmentConstraint.horizontal) {\n      var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n      for (var i = 0; i < allHorizontalAlignments.length; i++) {\n        var totalDisplacementY = 0;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n            totalDisplacementY = 0;\n            break;\n          }\n          totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n        }\n        var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n      // shuffle array to randomize node processing order\n      if (this.totalIterations % 10 == 0) {\n        this.shuffle(this.nodesInRelativeHorizontal);\n        this.shuffle(this.nodesInRelativeVertical);\n      }\n\n      this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementX;\n          }\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n            if (constraint.right) {\n              var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementX = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementX = displacement;\n          }\n        }\n      });\n\n      this.nodesInRelativeVertical.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementY;\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n            if (constraint.bottom) {\n              var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementY = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementY = displacement;\n          }\n        }\n      });\n    } else {\n      for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n        var component = this.componentsOnHorizontal[i];\n        if (this.fixedComponentsOnHorizontal[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementX;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < this.componentsOnVertical.length; i++) {\n        var component = this.componentsOnVertical[i];\n        if (this.fixedComponentsOnVertical[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementY;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n    compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n    var labelMarginLeft = lCompoundNode.labelMarginLeft;\n    var labelMarginTop = lCompoundNode.labelMarginTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n    var labelMarginLeft = compoundNode.labelMarginLeft;\n    var labelMarginTop = compoundNode.labelMarginTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n  x += compoundHorizontalMargin + compoundLabelMarginLeft;\n  y += compoundVerticalMargin + compoundLabelMarginTop;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n    compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n  var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n\n  var horizontalRatio = this.getOrgRatio(horizontalOrg);\n  var verticalRatio = this.getOrgRatio(verticalOrg);\n  var bestOrg;\n\n  // the best ratio is the one that is closer to 1 since the ratios are already normalized\n  // and the best organization is the one that has the best ratio\n  if (verticalRatio < horizontalRatio) {\n    bestOrg = verticalOrg;\n  } else {\n    bestOrg = horizontalOrg;\n  }\n\n  return bestOrg;\n};\n\n// get the width/height ratio of the organization that is normalized so that it will not be less than 1\nCoSELayout.prototype.getOrgRatio = function (organization) {\n  // get dimensions and calculate the initial ratio\n  var width = organization.width;\n  var height = organization.height;\n  var ratio = width / height;\n\n  // if the initial ratio is less then 1 then inverse it\n  if (ratio < 1) {\n    ratio = 1 / ratio;\n  }\n\n  // return the normalized ratio\n  return ratio;\n};\n\n/*\n * Calculates the ideal width for the rows. This method assumes that\n * each node has the same sizes and calculates the ideal row width that\n * approximates a square shaped complex accordingly. However, since nodes would\n * have different sizes some rows would have different sizes and the resulting\n * shape would not be an exact square.\n */\nCoSELayout.prototype.calcIdealRowWidth = function (members, favorHorizontalDim) {\n  // To approximate a square shaped complex we need to make complex width equal to complex height.\n  // To achieve this we need to solve the following equation system for hc:\n  // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n  // where x is the avarage width of the nodes, y is the avarage height of nodes\n  // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n  // hc and vc are the number of rows in horizontal and vertical dimensions\n  // n is number of members.\n\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n\n  // number of members\n  var membersSize = members.length;\n\n  // sum of the width of all members\n  var totalWidth = 0;\n\n  // sum of the height of all members\n  var totalHeight = 0;\n\n  var maxWidth = 0;\n\n  // traverse all members to calculate total width and total height and get the maximum members width\n  members.forEach(function (node) {\n    totalWidth += node.getWidth();\n    totalHeight += node.getHeight();\n\n    if (node.getWidth() > maxWidth) {\n      maxWidth = node.getWidth();\n    }\n  });\n\n  // average width of the members\n  var averageWidth = totalWidth / membersSize;\n\n  // average height of the members\n  var averageHeight = totalHeight / membersSize;\n\n  // solving the initial equation system for the hc yields the following second degree equation:\n  // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n\n  // the delta value to solve the equation above for hc\n  var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n\n  // solve the equation using delta value to calculate the horizontal count\n  // that represents the number of nodes in an ideal row\n  var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n  // round the calculated horizontal count up or down according to the favored dimension\n  var horizontalCount;\n\n  if (favorHorizontalDim) {\n    horizontalCount = Math.ceil(horizontalCountDouble);\n    // if horizontalCount count is not a float value then both of rounding to floor and ceil\n    // will yield the same values. Instead of repeating the same calculation try going up\n    // while favoring horizontal dimension in such cases\n    if (horizontalCount == horizontalCountDouble) {\n      horizontalCount++;\n    }\n  } else {\n    horizontalCount = Math.floor(horizontalCountDouble);\n  }\n\n  // ideal width to be calculated\n  var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n\n  // if max width is bigger than calculated ideal width reset ideal width to it\n  if (maxWidth > idealWidth) {\n    idealWidth = maxWidth;\n  }\n\n  // add the left-right margins to the ideal row width\n  idealWidth += horizontalPadding * 2;\n\n  // return the ideal row width1\n  return idealWidth;\n};\n\nCoSELayout.prototype.tileNodesByFavoringDim = function (nodes, minWidth, favorHorizontalDim) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding,\n    centerX: 0,\n    centerY: 0\n  };\n\n  if (tilingCompareBy) {\n    organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n  }\n\n  var getNodeArea = function getNodeArea(n) {\n    return n.rect.width * n.rect.height;\n  };\n\n  var areaCompareFcn = function areaCompareFcn(n1, n2) {\n    return getNodeArea(n2) - getNodeArea(n1);\n  };\n\n  // Sort the nodes in descending order of their areas\n  nodes.sort(function (n1, n2) {\n    var cmpBy = areaCompareFcn;\n    if (organization.idealRowWidth) {\n      cmpBy = tilingCompareBy;\n      return cmpBy(n1.id, n2.id);\n    }\n    return cmpBy(n1, n2);\n  });\n\n  // Create the organization -> calculate compound center\n  var sumCenterX = 0;\n  var sumCenterY = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    sumCenterX += lNode.getCenterX();\n    sumCenterY += lNode.getCenterY();\n  }\n\n  organization.centerX = sumCenterX / nodes.length;\n  organization.centerY = sumCenterY / nodes.length;\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      var rowIndex = organization.rows.length - 1;\n      if (!organization.idealRowWidth) {\n        rowIndex = this.getShortestRowIndex(organization);\n      }\n      this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  // if there is an ideal row width specified use it instead of checking the aspect ratio\n  if (organization.idealRowWidth) {\n    var lastRowIndex = organization.rows.length - 1;\n    var lastRowWidth = organization.rowWidth[lastRowIndex];\n\n    // check and return if ideal row width will be exceed if the node is added to the row\n    return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n  }\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        if (CoSEConstants.PURE_INCREMENTAL) {\n          var otherEnd = node.getEdges()[0].getOtherEnd(node);\n          var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n        } else {\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        }\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n\n  if (CoSEConstants.PURE_INCREMENTAL) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n  } else {\n    var startGridX = nodeToConnect.startX;\n    var finishGridX = nodeToConnect.finishX;\n    var startGridY = nodeToConnect.startY;\n    var finishGridY = nodeToConnect.finishY;\n\n    var upNodeCount = 0;\n    var downNodeCount = 0;\n    var rightNodeCount = 0;\n    var leftNodeCount = 0;\n    var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n    if (startGridY > 0) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n      }\n    }\n    if (finishGridX < this.grid.length - 1) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n      }\n    }\n    if (finishGridY < this.grid[0].length - 1) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n      }\n    }\n    if (startGridX > 0) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n      }\n    }\n    var min = Integer.MAX_VALUE;\n    var minCount;\n    var minIndex;\n    for (var j = 0; j < controlRegions.length; j++) {\n      if (controlRegions[j] < min) {\n        min = controlRegions[j];\n        minCount = 1;\n        minIndex = j;\n      } else if (controlRegions[j] == min) {\n        minCount++;\n      }\n    }\n\n    if (minCount == 3 && min == 0) {\n      if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n        gridForPrunedNode = 1;\n      } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 0;\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 3;\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 2;\n      }\n    } else if (minCount == 2 && min == 0) {\n      var random = Math.floor(Math.random() * 2);\n      if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n        ;\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 1;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else {\n        if (random == 0) {\n          gridForPrunedNode = 2;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      }\n    } else if (minCount == 4 && min == 0) {\n      var random = Math.floor(Math.random() * 4);\n      gridForPrunedNode = random;\n    } else {\n      gridForPrunedNode = minIndex;\n    }\n\n    if (gridForPrunedNode == 0) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n    } else if (gridForPrunedNode == 1) {\n      prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    } else if (gridForPrunedNode == 2) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n    } else {\n      prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    }\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n\n/***/ 991:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_74190__) => {\n\n\n\nvar FDLayoutNode = __nested_webpack_require_74190__(551).FDLayoutNode;\nvar IMath = __nested_webpack_require_74190__(551).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.calculateDisplacement = function () {\n  var layout = this.graphManager.getLayout();\n  // this check is for compound nodes that contain fixed nodes\n  if (this.getChild() != null && this.fixedNodeWeight) {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n  } else {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n  }\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // non-empty compound node, propogate movement to children as well\n  if (this.child && this.child.getNodes().length > 0) {\n    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n  }\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n\n  // a simple node or an empty compound node, move it\n  if (this.child == null || this.child.getNodes().length == 0) {\n    this.moveBy(this.displacementX, this.displacementY);\n\n    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n  }\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n\n/***/ 902:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_77514__) => {\n\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar CoSEConstants = __nested_webpack_require_77514__(806);\nvar LinkedList = __nested_webpack_require_77514__(551).LinkedList;\nvar Matrix = __nested_webpack_require_77514__(551).Matrix;\nvar SVD = __nested_webpack_require_77514__(551).SVD;\n\nfunction ConstraintHandler() {}\n\nConstraintHandler.handleConstraints = function (layout) {\n  //  let layout = this.graphManager.getLayout();\n\n  // get constraints from layout\n  var constraints = {};\n  constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n  constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n  constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n\n  var idToNodeMap = new Map();\n  var nodeIndexes = new Map();\n  var xCoords = [];\n  var yCoords = [];\n\n  var allNodes = layout.getAllNodes();\n  var index = 0;\n  // fill index map and coordinates\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    if (node.getChild() == null) {\n      nodeIndexes.set(node.id, index++);\n      xCoords.push(node.getCenterX());\n      yCoords.push(node.getCenterY());\n      idToNodeMap.set(node.id, node);\n    }\n  }\n\n  // if there exists relative placement constraint without gap value, set it to default \n  if (constraints.relativePlacementConstraint) {\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (!constraint.gap && constraint.gap != 0) {\n        if (constraint.left) {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n        } else {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n        }\n      }\n    });\n  }\n\n  /* auxiliary functions */\n\n  // calculate difference between two position objects\n  var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n    return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };\n  };\n\n  // calculate average position of the nodes\n  var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n    var xPosSum = 0;\n    var yPosSum = 0;\n    nodeIdSet.forEach(function (nodeId) {\n      xPosSum += xCoords[nodeIndexes.get(nodeId)];\n      yPosSum += yCoords[nodeIndexes.get(nodeId)];\n    });\n\n    return { x: xPosSum / nodeIdSet.size, y: yPosSum / nodeIdSet.size };\n  };\n\n  // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n  // this function also takes the fixed nodes and alignment constraints into account\n  // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n  // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n  var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n\n    // find union of two sets\n    function setUnion(setA, setB) {\n      var union = new Set(setA);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var elem = _step.value;\n\n          union.add(elem);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return union;\n    }\n\n    // find indegree count for each node\n    var inDegrees = new Map();\n\n    graph.forEach(function (value, key) {\n      inDegrees.set(key, 0);\n    });\n    graph.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n      });\n    });\n\n    var positionMap = new Map(); // keeps the position for each node\n    var pastMap = new Map(); // keeps the predecessors(past) of a node\n    var queue = new LinkedList();\n    inDegrees.forEach(function (value, key) {\n      if (value == 0) {\n        queue.push(key);\n        if (!fixedNodes) {\n          if (direction == \"horizontal\") {\n            positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          } else {\n            positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          }\n        }\n      } else {\n        positionMap.set(key, Number.NEGATIVE_INFINITY);\n      }\n      if (fixedNodes) {\n        pastMap.set(key, new Set([key]));\n      }\n    });\n\n    // align sources of each component in enforcement phase\n    if (fixedNodes) {\n      componentSources.forEach(function (component) {\n        var fixedIds = [];\n        component.forEach(function (nodeId) {\n          if (fixedNodes.has(nodeId)) {\n            fixedIds.push(nodeId);\n          }\n        });\n        if (fixedIds.length > 0) {\n          var position = 0;\n          fixedIds.forEach(function (fixedId) {\n            if (direction == \"horizontal\") {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            } else {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            }\n          });\n          position = position / fixedIds.length;\n          component.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) {\n              positionMap.set(nodeId, position);\n            }\n          });\n        } else {\n          var _position = 0;\n          component.forEach(function (nodeId) {\n            if (direction == \"horizontal\") {\n              _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n          });\n          _position = _position / component.length;\n          component.forEach(function (nodeId) {\n            positionMap.set(nodeId, _position);\n          });\n        }\n      });\n    }\n\n    // calculate positions of the nodes\n\n    var _loop = function _loop() {\n      var currentNode = queue.shift();\n      var neighbors = graph.get(currentNode);\n      neighbors.forEach(function (neighbor) {\n        if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n          if (fixedNodes && fixedNodes.has(neighbor.id)) {\n            var fixedPosition = void 0;\n            if (direction == \"horizontal\") {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            } else {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            }\n            positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n            if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n              var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n              pastMap.get(currentNode).forEach(function (nodeId) {\n                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n              });\n            }\n          } else {\n            positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n          }\n        }\n        inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n        if (inDegrees.get(neighbor.id) == 0) {\n          queue.push(neighbor.id);\n        }\n        if (fixedNodes) {\n          pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n        }\n      });\n    };\n\n    while (queue.length != 0) {\n      _loop();\n    }\n\n    // readjust position of the nodes after enforcement\n    if (fixedNodes) {\n      // find indegree count for each node\n      var sinkNodes = new Set();\n\n      graph.forEach(function (value, key) {\n        if (value.length == 0) {\n          sinkNodes.add(key);\n        }\n      });\n\n      var _components = [];\n      pastMap.forEach(function (value, key) {\n        if (sinkNodes.has(key)) {\n          var isFixedComponent = false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var nodeId = _step2.value;\n\n              if (fixedNodes.has(nodeId)) {\n                isFixedComponent = true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          if (!isFixedComponent) {\n            var isExist = false;\n            var existAt = void 0;\n            _components.forEach(function (component, index) {\n              if (component.has([].concat(_toConsumableArray(value))[0])) {\n                isExist = true;\n                existAt = index;\n              }\n            });\n            if (!isExist) {\n              _components.push(new Set(value));\n            } else {\n              value.forEach(function (ele) {\n                _components[existAt].add(ele);\n              });\n            }\n          }\n        }\n      });\n\n      _components.forEach(function (component, index) {\n        var minBefore = Number.POSITIVE_INFINITY;\n        var minAfter = Number.POSITIVE_INFINITY;\n        var maxBefore = Number.NEGATIVE_INFINITY;\n        var maxAfter = Number.NEGATIVE_INFINITY;\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var nodeId = _step3.value;\n\n            var posBefore = void 0;\n            if (direction == \"horizontal\") {\n              posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n            var posAfter = positionMap.get(nodeId);\n            if (posBefore < minBefore) {\n              minBefore = posBefore;\n            }\n            if (posBefore > maxBefore) {\n              maxBefore = posBefore;\n            }\n            if (posAfter < minAfter) {\n              minAfter = posAfter;\n            }\n            if (posAfter > maxAfter) {\n              maxAfter = posAfter;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _nodeId = _step4.value;\n\n            positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n    }\n\n    return positionMap;\n  };\n\n  // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n  // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n  var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n    // variables to count votes\n    var reflectOnY = 0,\n        notReflectOnY = 0;\n    var reflectOnX = 0,\n        notReflectOnX = 0;\n\n    relativePlacementConstraints.forEach(function (constraint) {\n      if (constraint.left) {\n        xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n      } else {\n        yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n      }\n    });\n\n    if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n      for (var _i = 0; _i < nodeIndexes.size; _i++) {\n        xCoords[_i] = -1 * xCoords[_i];\n        yCoords[_i] = -1 * yCoords[_i];\n      }\n    } else if (reflectOnY > notReflectOnY) {\n      for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n        xCoords[_i2] = -1 * xCoords[_i2];\n      }\n    } else if (reflectOnX > notReflectOnX) {\n      for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n        yCoords[_i3] = -1 * yCoords[_i3];\n      }\n    }\n  };\n\n  // find weakly connected components in undirected graph\n  var findComponents = function findComponents(graph) {\n    // find weakly connected components in dag\n    var components = [];\n    var queue = new LinkedList();\n    var visited = new Set();\n    var count = 0;\n\n    graph.forEach(function (value, key) {\n      if (!visited.has(key)) {\n        components[count] = [];\n        var _currentNode = key;\n        queue.push(_currentNode);\n        visited.add(_currentNode);\n        components[count].push(_currentNode);\n\n        while (queue.length != 0) {\n          _currentNode = queue.shift();\n          var neighbors = graph.get(_currentNode);\n          neighbors.forEach(function (neighbor) {\n            if (!visited.has(neighbor.id)) {\n              queue.push(neighbor.id);\n              visited.add(neighbor.id);\n              components[count].push(neighbor.id);\n            }\n          });\n        }\n        count++;\n      }\n    });\n    return components;\n  };\n\n  // return undirected version of given dag\n  var dagToUndirected = function dagToUndirected(dag) {\n    var undirected = new Map();\n\n    dag.forEach(function (value, key) {\n      undirected.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        undirected.get(key).push(adjacent);\n        undirected.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return undirected;\n  };\n\n  // return reversed (directions inverted) version of given dag\n  var dagToReversed = function dagToReversed(dag) {\n    var reversed = new Map();\n\n    dag.forEach(function (value, key) {\n      reversed.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        reversed.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return reversed;\n  };\n\n  /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n  // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n  // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n  /* construct source and target configurations */\n\n  var targetMatrix = []; // A - target configuration\n  var sourceMatrix = []; // B - source configuration \n  var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n  var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n  var fixedNodes = new Set();\n  var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n  var dagUndirected = new Map(); // undirected version of the dag\n  var components = []; // weakly connected components\n\n  // fill fixedNodes collection to use later\n  if (constraints.fixedNodeConstraint) {\n    constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      fixedNodes.add(nodeData.nodeId);\n    });\n  }\n\n  // construct dag from relative placement constraints \n  if (constraints.relativePlacementConstraint) {\n    // construct both directed and undirected version of the dag\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (constraint.left) {\n        if (dag.has(constraint.left)) {\n          dag.get(constraint.left).push({ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" });\n        } else {\n          dag.set(constraint.left, [{ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" }]);\n        }\n        if (!dag.has(constraint.right)) {\n          dag.set(constraint.right, []);\n        }\n      } else {\n        if (dag.has(constraint.top)) {\n          dag.get(constraint.top).push({ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" });\n        } else {\n          dag.set(constraint.top, [{ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" }]);\n        }\n        if (!dag.has(constraint.bottom)) {\n          dag.set(constraint.bottom, []);\n        }\n      }\n    });\n\n    dagUndirected = dagToUndirected(dag);\n    components = findComponents(dagUndirected);\n  }\n\n  if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n    // first check fixed node constraint\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n        sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n      });\n      standardTransformation = true;\n    } else if (constraints.alignmentConstraint) {\n      (function () {\n        // then check alignment constraint\n        var count = 0;\n        if (constraints.alignmentConstraint.vertical) {\n          var verticalAlign = constraints.alignmentConstraint.vertical;\n\n          var _loop2 = function _loop2(_i4) {\n            var alignmentSet = new Set();\n            verticalAlign[_i4].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var xPos = void 0;\n            if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n            verticalAlign[_i4].forEach(function (nodeId) {\n              targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n            _loop2(_i4);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.alignmentConstraint.horizontal) {\n          var horizontalAlign = constraints.alignmentConstraint.horizontal;\n\n          var _loop3 = function _loop3(_i5) {\n            var alignmentSet = new Set();\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var yPos = void 0;\n            if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n            _loop3(_i5);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.relativePlacementConstraint) {\n          reflectionType = true;\n        }\n      })();\n    } else if (constraints.relativePlacementConstraint) {\n      // finally check relative placement constraint\n      // find largest component in dag\n      var largestComponentSize = 0;\n      var largestComponentIndex = 0;\n      for (var _i6 = 0; _i6 < components.length; _i6++) {\n        if (components[_i6].length > largestComponentSize) {\n          largestComponentSize = components[_i6].length;\n          largestComponentIndex = _i6;\n        }\n      }\n      // if largest component isn't dominant, then take the votes for reflection\n      if (largestComponentSize < dagUndirected.size / 2) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n        standardTransformation = false;\n        reflectionType = false;\n      } else {\n        // use largest component for transformation\n        // construct horizontal and vertical subgraphs in the largest component\n        var subGraphOnHorizontal = new Map();\n        var subGraphOnVertical = new Map();\n        var constraintsInlargestComponent = [];\n\n        components[largestComponentIndex].forEach(function (nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            if (adjacent.direction == \"horizontal\") {\n              if (subGraphOnHorizontal.has(nodeId)) {\n                subGraphOnHorizontal.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnHorizontal.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnHorizontal.has(adjacent.id)) {\n                subGraphOnHorizontal.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ left: nodeId, right: adjacent.id });\n            } else {\n              if (subGraphOnVertical.has(nodeId)) {\n                subGraphOnVertical.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnVertical.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnVertical.has(adjacent.id)) {\n                subGraphOnVertical.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ top: nodeId, bottom: adjacent.id });\n            }\n          });\n        });\n\n        applyReflectionForRelativePlacement(constraintsInlargestComponent);\n        reflectionType = false;\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n\n        // construct source and target configuration\n        components[largestComponentIndex].forEach(function (nodeId, i) {\n          sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n          targetMatrix[i] = [];\n          if (positionMapHorizontal.has(nodeId)) {\n            targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n          } else {\n            targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n          }\n          if (positionMapVertical.has(nodeId)) {\n            targetMatrix[i][1] = positionMapVertical.get(nodeId);\n          } else {\n            targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n          }\n        });\n\n        standardTransformation = true;\n      }\n    }\n\n    // if transformation is required, then calculate and apply transformation matrix\n    if (standardTransformation) {\n      /* calculate transformation matrix */\n      var transformationMatrix = void 0;\n      var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n      var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n\n      // centralize transpose matrices\n      for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n        targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n        sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n      }\n\n      // do actual calculation for transformation matrix\n      var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n      var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n      transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n\n      /* apply found transformation matrix to obtain final draft layout */\n      for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n        var temp1 = [xCoords[_i8], yCoords[_i8]];\n        var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n        var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n        xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n        yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n      }\n\n      // applied only both alignment and rel. placement constraints exist\n      if (reflectionType) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n      }\n    }\n  }\n\n  if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n    /****  enforce constraints on the transformed draft layout ****/\n\n    /* first enforce fixed node constraint */\n\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n      var translationAmount = { x: 0, y: 0 };\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        var posInTheory = { x: xCoords[nodeIndexes.get(nodeData.nodeId)], y: yCoords[nodeIndexes.get(nodeData.nodeId)] };\n        var posDesired = nodeData.position;\n        var posDiff = calculatePositionDiff(posDesired, posInTheory);\n        translationAmount.x += posDiff.x;\n        translationAmount.y += posDiff.y;\n      });\n      translationAmount.x /= constraints.fixedNodeConstraint.length;\n      translationAmount.y /= constraints.fixedNodeConstraint.length;\n\n      xCoords.forEach(function (value, i) {\n        xCoords[i] += translationAmount.x;\n      });\n\n      yCoords.forEach(function (value, i) {\n        yCoords[i] += translationAmount.y;\n      });\n\n      constraints.fixedNodeConstraint.forEach(function (nodeData) {\n        xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n        yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n      });\n    }\n\n    /* then enforce alignment constraint */\n\n    if (constraints.alignmentConstraint) {\n      if (constraints.alignmentConstraint.vertical) {\n        var xAlign = constraints.alignmentConstraint.vertical;\n\n        var _loop4 = function _loop4(_i9) {\n          var alignmentSet = new Set();\n          xAlign[_i9].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var xPos = void 0;\n          if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n          });\n        };\n\n        for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n          _loop4(_i9);\n        }\n      }\n      if (constraints.alignmentConstraint.horizontal) {\n        var yAlign = constraints.alignmentConstraint.horizontal;\n\n        var _loop5 = function _loop5(_i10) {\n          var alignmentSet = new Set();\n          yAlign[_i10].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var yPos = void 0;\n          if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n          });\n        };\n\n        for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n          _loop5(_i10);\n        }\n      }\n    }\n\n    /* finally enforce relative placement constraint */\n\n    if (constraints.relativePlacementConstraint) {\n      (function () {\n        var nodeToDummyForVerticalAlignment = new Map();\n        var nodeToDummyForHorizontalAlignment = new Map();\n        var dummyToNodeForVerticalAlignment = new Map();\n        var dummyToNodeForHorizontalAlignment = new Map();\n        var dummyPositionsForVerticalAlignment = new Map();\n        var dummyPositionsForHorizontalAlignment = new Map();\n        var fixedNodesOnHorizontal = new Set();\n        var fixedNodesOnVertical = new Set();\n\n        // fill maps and sets      \n        fixedNodes.forEach(function (nodeId) {\n          fixedNodesOnHorizontal.add(nodeId);\n          fixedNodesOnVertical.add(nodeId);\n        });\n\n        if (constraints.alignmentConstraint) {\n          if (constraints.alignmentConstraint.vertical) {\n            var verticalAlignment = constraints.alignmentConstraint.vertical;\n\n            var _loop6 = function _loop6(_i11) {\n              dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n              verticalAlignment[_i11].forEach(function (nodeId) {\n                nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                }\n              });\n              dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n            };\n\n            for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n              _loop6(_i11);\n            }\n          }\n          if (constraints.alignmentConstraint.horizontal) {\n            var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n\n            var _loop7 = function _loop7(_i12) {\n              dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n              horizontalAlignment[_i12].forEach(function (nodeId) {\n                nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnVertical.add(\"dummy\" + _i12);\n                }\n              });\n              dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n            };\n\n            for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n              _loop7(_i12);\n            }\n          }\n        }\n\n        // construct horizontal and vertical dags (subgraphs) from overall dag\n        var dagOnHorizontal = new Map();\n        var dagOnVertical = new Map();\n\n        var _loop8 = function _loop8(nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            var sourceId = void 0;\n            var targetNode = void 0;\n            if (adjacent[\"direction\"] == \"horizontal\") {\n              sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForVerticalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnHorizontal.has(sourceId)) {\n                dagOnHorizontal.get(sourceId).push(targetNode);\n              } else {\n                dagOnHorizontal.set(sourceId, [targetNode]);\n              }\n              if (!dagOnHorizontal.has(targetNode.id)) {\n                dagOnHorizontal.set(targetNode.id, []);\n              }\n            } else {\n              sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForHorizontalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnVertical.has(sourceId)) {\n                dagOnVertical.get(sourceId).push(targetNode);\n              } else {\n                dagOnVertical.set(sourceId, [targetNode]);\n              }\n              if (!dagOnVertical.has(targetNode.id)) {\n                dagOnVertical.set(targetNode.id, []);\n              }\n            }\n          });\n        };\n\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var nodeId = _step5.value;\n\n            _loop8(nodeId);\n          }\n\n          // find source nodes of each component in horizontal and vertical dags\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n        var undirectedOnVertical = dagToUndirected(dagOnVertical);\n        var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n        var componentsOnVertical = findComponents(undirectedOnVertical);\n        var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n        var reversedDagOnVertical = dagToReversed(dagOnVertical);\n        var componentSourcesOnHorizontal = [];\n        var componentSourcesOnVertical = [];\n\n        componentsOnHorizontal.forEach(function (component, index) {\n          componentSourcesOnHorizontal[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n              componentSourcesOnHorizontal[index].push(nodeId);\n            }\n          });\n        });\n\n        componentsOnVertical.forEach(function (component, index) {\n          componentSourcesOnVertical[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnVertical.get(nodeId).length == 0) {\n              componentSourcesOnVertical[index].push(nodeId);\n            }\n          });\n        });\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n        // update positions of the nodes based on relative placement constraints\n\n        var _loop9 = function _loop9(key) {\n          if (dummyToNodeForVerticalAlignment.get(key)) {\n            dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n              xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n            });\n          } else {\n            xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var key = _step6.value;\n\n            _loop9(key);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        var _loop10 = function _loop10(key) {\n          if (dummyToNodeForHorizontalAlignment.get(key)) {\n            dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n              yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n            });\n          } else {\n            yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var key = _step7.value;\n\n            _loop10(key);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      })();\n    }\n  }\n\n  // assign new coordinates to nodes after constraint handling\n  for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n    var _node = allNodes[_i13];\n    if (_node.getChild() == null) {\n      _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n    }\n  }\n};\n\nmodule.exports = ConstraintHandler;\n\n/***/ }),\n\n/***/ 551:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_117795__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_117795__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_117795__(45);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYWJiaXRtcS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1mY29zZS9ub2RlX21vZHVsZXMvY29zZS1iYXNlL2Nvc2UtYmFzZS5qcz8yMzBmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxheW91dC1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImxheW91dC1iYXNlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImNvc2VCYXNlXCJdID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImNvc2VCYXNlXCJdID0gZmFjdG9yeShyb290W1wibGF5b3V0QmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NTFfXykge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgY29zZUJhc2UgPSB7fTtcblxuY29zZUJhc2UubGF5b3V0QmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKTtcbmNvc2VCYXNlLkNvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNik7XG5jb3NlQmFzZS5Db1NFRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzY3KTtcbmNvc2VCYXNlLkNvU0VHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oODgwKTtcbmNvc2VCYXNlLkNvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3OCk7XG5jb3NlQmFzZS5Db1NFTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjUpO1xuY29zZUJhc2UuQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MSk7XG5jb3NlQmFzZS5Db25zdHJhaW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTAyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3NlQmFzZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dENvbnN0YW50cztcblxuZnVuY3Rpb24gQ29TRUNvbnN0YW50cygpIHt9XG5cbi8vQ29TRUNvbnN0YW50cyBpbmhlcml0cyBzdGF0aWMgcHJvcHMgaW4gRkRMYXlvdXRDb25zdGFudHNcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXRDb25zdGFudHMpIHtcbiAgQ29TRUNvbnN0YW50c1twcm9wXSA9IEZETGF5b3V0Q29uc3RhbnRzW3Byb3BdO1xufVxuXG5Db1NFQ29uc3RhbnRzLkRFRkFVTFRfVVNFX01VTFRJX0xFVkVMX1NDQUxJTkcgPSBmYWxzZTtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEg7XG5Db1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04gPSA2MDtcbkNvU0VDb25zdGFudHMuVElMRSA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMID0gMTA7XG5Db1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuUkVMQVhfTU9WRU1FTlRfT05fQ09OU1RSQUlOVFMgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IHRydWU7IC8vIHRoaXMgc2hvdWxkIGJlIHNldCB0byBmYWxzZSBpZiB0aGVyZSB3aWxsIGJlIGEgY29uc3RyYWludFxuLy8gVGhpcyBjb25zdGFudCBpcyBmb3IgZGlmZmVyZW50aWF0aW5nIHdoZXRoZXIgYWN0dWFsIGxheW91dCBhbGdvcml0aG0gdGhhdCB1c2VzIGNvc2UtYmFzZSB3YW50cyB0byBhcHBseSBvbmx5IGluY3JlbWVudGFsIGxheW91dCBvciBcbi8vIGFuIGluY3JlbWVudGFsIGxheW91dCBvbiB0b3Agb2YgYSByYW5kb21pemVkIGxheW91dC4gSWYgaXQgaXMgb25seSBpbmNyZW1lbnRhbCBsYXlvdXQsIHRoZW4gdGhpcyBjb25zdGFudCBzaG91bGQgYmUgdHJ1ZS5cbkNvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFQ29uc3RhbnRzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0RWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dEVkZ2U7XG5cbmZ1bmN0aW9uIENvU0VFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBGRExheW91dEVkZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdkVkZ2UpO1xufVxuXG5Db1NFRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0RWRnZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dEVkZ2UpIHtcbiAgQ29TRUVkZ2VbcHJvcF0gPSBGRExheW91dEVkZ2VbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUVkZ2U7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4ODA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxHcmFwaDtcblxuZnVuY3Rpb24gQ29TRUdyYXBoKHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCkge1xuICBMR3JhcGguY2FsbCh0aGlzLCBwYXJlbnQsIGdyYXBoTWdyLCB2R3JhcGgpO1xufVxuXG5Db1NFR3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGgucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoKSB7XG4gIENvU0VHcmFwaFtwcm9wXSA9IExHcmFwaFtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGg7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1Nzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MR3JhcGhNYW5hZ2VyO1xuXG5mdW5jdGlvbiBDb1NFR3JhcGhNYW5hZ2VyKGxheW91dCkge1xuICBMR3JhcGhNYW5hZ2VyLmNhbGwodGhpcywgbGF5b3V0KTtcbn1cblxuQ29TRUdyYXBoTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE1hbmFnZXIucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoTWFuYWdlcikge1xuICBDb1NFR3JhcGhNYW5hZ2VyW3Byb3BdID0gTEdyYXBoTWFuYWdlcltwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGhNYW5hZ2VyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0O1xudmFyIENvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3OCk7XG52YXIgQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODApO1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTEpO1xudmFyIENvU0VFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcpO1xudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNik7XG52YXIgQ29uc3RyYWludEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMik7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuRkRMYXlvdXRDb25zdGFudHM7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxheW91dENvbnN0YW50cztcbnZhciBQb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5Qb2ludDtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuUG9pbnREO1xudmFyIERpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuRGltZW5zaW9uRDtcbnZhciBMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGF5b3V0O1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuSW50ZWdlcjtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuSUdlb21ldHJ5O1xudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MR3JhcGg7XG52YXIgVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLlRyYW5zZm9ybTtcbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxpbmtlZExpc3Q7XG5cbmZ1bmN0aW9uIENvU0VMYXlvdXQoKSB7XG4gIEZETGF5b3V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy50b0JlVGlsZWQgPSB7fTsgLy8gTWVtb3JpemUgaWYgYSBub2RlIGlzIHRvIGJlIHRpbGVkIG9yIGlzIHRpbGVkXG4gIHRoaXMuY29uc3RyYWludHMgPSB7fTsgLy8ga2VlcCBsYXlvdXQgY29uc3RyYWludHNcbn1cblxuQ29TRUxheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXQpIHtcbiAgQ29TRUxheW91dFtwcm9wXSA9IEZETGF5b3V0W3Byb3BdO1xufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnbSA9IG5ldyBDb1NFR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuICByZXR1cm4gZ207XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaCA9IGZ1bmN0aW9uICh2R3JhcGgpIHtcbiAgcmV0dXJuIG5ldyBDb1NFR3JhcGgobnVsbCwgdGhpcy5ncmFwaE1hbmFnZXIsIHZHcmFwaCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XG4gIHJldHVybiBuZXcgQ29TRU5vZGUodGhpcy5ncmFwaE1hbmFnZXIsIHZOb2RlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0VkZ2UgPSBmdW5jdGlvbiAodkVkZ2UpIHtcbiAgcmV0dXJuIG5ldyBDb1NFRWRnZShudWxsLCBudWxsLCB2RWRnZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgRkRMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzLmNhbGwodGhpcywgYXJndW1lbnRzKTtcbiAgaWYgKCF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgaWYgKENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA8IDEwKSB7XG4gICAgICB0aGlzLmlkZWFsRWRnZUxlbmd0aCA9IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkZWFsRWRnZUxlbmd0aCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbiAgICB9XG5cbiAgICB0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24gPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OO1xuICAgIHRoaXMuZ3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIO1xuICAgIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEg7XG4gICAgdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuICAgIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuXG4gICAgLy8gdmFyaWFibGVzIGZvciB0cmVlIHJlZHVjdGlvbiBzdXBwb3J0XG4gICAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IFtdO1xuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0dyb3d0aEZpbmlzaGVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IENvU0UgcmVsYXRlZCBwYXJhbWV0ZXJzIHVzZWQgYnkgc3ByaW5nIGVtYmVkZGVyLlxuQ29TRUxheW91dC5wcm90b3R5cGUuaW5pdFNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuICBGRExheW91dC5wcm90b3R5cGUuaW5pdFNwcmluZ0VtYmVkZGVyLmNhbGwodGhpcyk7XG5cbiAgLy8gdmFyaWFibGVzIGZvciBjb29saW5nXG4gIHRoaXMuY29vbGluZ0N5Y2xlID0gMDtcbiAgdGhpcy5tYXhDb29saW5nQ3ljbGUgPSB0aGlzLm1heEl0ZXJhdGlvbnMgLyBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0Q7XG4gIHRoaXMuZmluYWxUZW1wZXJhdHVyZSA9IDAuMDQ7XG4gIHRoaXMuY29vbGluZ0FkanVzdGVyID0gMTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICBpZiAoY3JlYXRlQmVuZHNBc05lZWRlZCkge1xuICAgIHRoaXMuY3JlYXRlQmVuZHBvaW50cygpO1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgfVxuXG4gIHRoaXMubGV2ZWwgPSAwO1xuICByZXR1cm4gdGhpcy5jbGFzc2ljTGF5b3V0KCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGFzc2ljTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5vZGVzV2l0aEdyYXZpdHkgPSB0aGlzLmNhbGN1bGF0ZU5vZGVzVG9BcHBseUdyYXZpdGF0aW9uVG8oKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24odGhpcy5ub2Rlc1dpdGhHcmF2aXR5KTtcbiAgdGhpcy5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9ycygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjSW5jbHVzaW9uVHJlZURlcHRocygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgdGhpcy5jYWxjSWRlYWxFZGdlTGVuZ3RocygpO1xuXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHZhciBmb3Jlc3QgPSB0aGlzLmdldEZsYXRGb3Jlc3QoKTtcblxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgZmxhdCBhbmQgYSBmb3Jlc3RcbiAgICBpZiAoZm9yZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhZGlhbGx5KGZvcmVzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgbm90IGZsYXQgb3IgYSBmb3Jlc3RcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUmVkdWNlIHRoZSB0cmVlcyB3aGVuIGluY3JlbWVudGFsIG1vZGUgaXMgbm90IGVuYWJsZWQgYW5kIGdyYXBoIGlzIG5vdCBhIGZvcmVzdCBcbiAgICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG4gICAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gYWxsTm9kZXMuaGFzKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSgpO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMKSB7XG4gICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIGluIGluY3JlbWVudGFsIG1vZGUgaWYgb25seSB0aGlzIGNvbnN0YW50IGlzIHNldCB0byB0cnVlIFxuICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY29uc3RyYWludHMpLmxlbmd0aCA+IDApIHtcbiAgICBDb25zdHJhaW50SGFuZGxlci5oYW5kbGVDb25zdHJhaW50cyh0aGlzKTtcbiAgICB0aGlzLmluaXRDb25zdHJhaW50VmFyaWFibGVzKCk7XG4gIH1cblxuICB0aGlzLmluaXRTcHJpbmdFbWJlZGRlcigpO1xuICBpZiAoQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQpIHtcbiAgICB0aGlzLnJ1blNwcmluZ0VtYmVkZGVyKCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudG90YWxJdGVyYXRpb25zKys7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zID09PSB0aGlzLm1heEl0ZXJhdGlvbnMgJiYgIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EID09IDAgJiYgIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMuaXNDb252ZXJnZWQoKSkge1xuICAgICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb29saW5nQ3ljbGUrKztcblxuICAgIGlmICh0aGlzLmxheW91dFF1YWxpdHkgPT0gMCkge1xuICAgICAgLy8gcXVhbGl0eSAtIFwiZHJhZnRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAxKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkZWZhdWx0XCJcbiAgICAgIHRoaXMuY29vbGluZ0FkanVzdGVyID0gdGhpcy5jb29saW5nQ3ljbGUgLyAzO1xuICAgIH1cblxuICAgIC8vIGNvb2xpbmcgc2NoZWR1bGUgaXMgYmFzZWQgb24gaHR0cDovL3d3dy5idGx1a2UuY29tL3NpbWFuZjEuaHRtbCAtPiBjb29saW5nIHNjaGVkdWxlIDNcbiAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heCh0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yIC0gTWF0aC5wb3codGhpcy5jb29saW5nQ3ljbGUsIE1hdGgubG9nKDEwMCAqICh0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yIC0gdGhpcy5maW5hbFRlbXBlcmF0dXJlKSkgLyBNYXRoLmxvZyh0aGlzLm1heENvb2xpbmdDeWNsZSkpIC8gMTAwICogdGhpcy5jb29saW5nQWRqdXN0ZXIsIHRoaXMuZmluYWxUZW1wZXJhdHVyZSk7XG4gICAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBNYXRoLmNlaWwodGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kICogTWF0aC5zcXJ0KHRoaXMuY29vbGluZ0ZhY3RvcikpO1xuICB9XG4gIC8vIE9wZXJhdGlvbnMgd2hpbGUgdHJlZSBpcyBncm93aW5nIGFnYWluIFxuICBpZiAodGhpcy5pc1RyZWVHcm93aW5nKSB7XG4gICAgaWYgKHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zICUgMTAgPT0gMCkge1xuICAgICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgICAgIHRoaXMuZ3Jvd1RyZWUodGhpcy5wcnVuZWROb2Rlc0FsbCk7XG4gICAgICAgIC8vIFVwZGF0ZSBub2RlcyB0aGF0IGdyYXZpdHkgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5ub2Rlc1dpdGhHcmF2aXR5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbihpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgaWYgKENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCkgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCAvIDI7ZWxzZSB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNHcm93dGhGaW5pc2hlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zKys7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyBhZnRlciBncm93dGggaXMgZmluaXNoZWRcbiAgaWYgKHRoaXMuaXNHcm93dGhGaW5pc2hlZCkge1xuICAgIGlmICh0aGlzLmlzQ29udmVyZ2VkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cbiAgICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIC8gMiAqICgoMTAwIC0gdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMpIC8gMTAwKTtlbHNlIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgKiAoKDEwMCAtIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zKSAvIDEwMCk7XG4gICAgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIHZhciBncmlkVXBkYXRlQWxsb3dlZCA9ICF0aGlzLmlzVHJlZUdyb3dpbmcgJiYgIXRoaXMuaXNHcm93dGhGaW5pc2hlZDtcbiAgdmFyIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUgPSB0aGlzLmdyb3dUcmVlSXRlcmF0aW9ucyAlIDEwID09IDEgJiYgdGhpcy5pc1RyZWVHcm93aW5nIHx8IHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zICUgMTAgPT0gMSAmJiB0aGlzLmlzR3Jvd3RoRmluaXNoZWQ7XG5cbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudCA9IDA7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICB0aGlzLmNhbGNTcHJpbmdGb3JjZXMoKTtcbiAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2VzKGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKTtcbiAgdGhpcy5jYWxjR3Jhdml0YXRpb25hbEZvcmNlcygpO1xuICB0aGlzLm1vdmVOb2RlcygpO1xuICB0aGlzLmFuaW1hdGUoKTtcblxuICByZXR1cm4gZmFsc2U7IC8vIExheW91dCBpcyBub3QgZW5kZWQgeWV0IHJldHVybiBmYWxzZVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0UG9zaXRpb25zRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIHBEYXRhID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVjdCA9IGFsbE5vZGVzW2ldLnJlY3Q7XG4gICAgdmFyIGlkID0gYWxsTm9kZXNbaV0uaWQ7XG4gICAgcERhdGFbaWRdID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgeDogcmVjdC5nZXRDZW50ZXJYKCksXG4gICAgICB5OiByZWN0LmdldENlbnRlclkoKSxcbiAgICAgIHc6IHJlY3Qud2lkdGgsXG4gICAgICBoOiByZWN0LmhlaWdodFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcERhdGE7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5ydW5TcHJpbmdFbWJlZGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kID0gMjU7XG4gIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gdGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kO1xuICB2YXIgbGF5b3V0RW5kZWQgPSBmYWxzZTtcblxuICAvLyBJZiBhbWluYXRlIG9wdGlvbiBpcyAnZHVyaW5nJyBzaWduYWwgdGhhdCBsYXlvdXQgaXMgc3VwcG9zZWQgdG8gc3RhcnQgaXRlcmF0aW5nXG4gIGlmIChGRExheW91dENvbnN0YW50cy5BTklNQVRFID09PSAnZHVyaW5nJykge1xuICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RhcnRlZCcpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFtaW5hdGUgb3B0aW9uIGlzICdkdXJpbmcnIHRpY2soKSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiBpbmRleC5qc1xuICAgIHdoaWxlICghbGF5b3V0RW5kZWQpIHtcbiAgICAgIGxheW91dEVuZGVkID0gdGhpcy50aWNrKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gIH1cbn07XG5cbi8vIG92ZXJyaWRlcyBtb3ZlTm9kZXMgbWV0aG9kIGluIEZETGF5b3V0XG5Db1NFTGF5b3V0LnByb3RvdHlwZS5tb3ZlTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gIHZhciBub2RlO1xuXG4gIC8vIGNhbGN1bGF0ZSBkaXNwbGFjZW1lbnQgZm9yIGVhY2ggbm9kZSBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIG5vZGUuY2FsY3VsYXRlRGlzcGxhY2VtZW50KCk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXModGhpcy5jb25zdHJhaW50cykubGVuZ3RoID4gMCkge1xuICAgIHRoaXMudXBkYXRlRGlzcGxhY2VtZW50cygpO1xuICB9XG5cbiAgLy8gbW92ZSBlYWNoIG5vZGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIG5vZGUubW92ZSgpO1xuICB9XG59O1xuXG4vLyBjb25zdHJhaW50IHJlbGF0ZWQgbWV0aG9kczogaW5pdENvbnN0cmFpbnRWYXJpYWJsZXMgYW5kIHVwZGF0ZURpc3BsYWNlbWVudHNcblxuLy8gaW5pdGlhbGl6ZSBjb25zdHJhaW50IHJlbGF0ZWQgdmFyaWFibGVzXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0Q29uc3RyYWludFZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmlkVG9Ob2RlTWFwID0gbmV3IE1hcCgpO1xuICB0aGlzLmZpeGVkTm9kZVNldCA9IG5ldyBTZXQoKTtcblxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIC8vIGZpbGwgaWRUb05vZGVNYXBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgdGhpcy5pZFRvTm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgZml4ZWQgbm9kZSB3ZWlnaHQgZm9yIGdpdmVuIGNvbXBvdW5kIG5vZGVcbiAgdmFyIGNhbGN1bGF0ZUNvbXBvdW5kV2VpZ2h0ID0gZnVuY3Rpb24gY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQoY29tcG91bmROb2RlKSB7XG4gICAgdmFyIG5vZGVzID0gY29tcG91bmROb2RlLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgZml4ZWROb2RlV2VpZ2h0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgICAgaWYgKHNlbGYuZml4ZWROb2RlU2V0Lmhhcyhub2RlLmlkKSkge1xuICAgICAgICAgIGZpeGVkTm9kZVdlaWdodCArPSAxMDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpeGVkTm9kZVdlaWdodCArPSBjYWxjdWxhdGVDb21wb3VuZFdlaWdodChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpeGVkTm9kZVdlaWdodDtcbiAgfTtcblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgLy8gZmlsbCBmaXhlZE5vZGVTZXRcbiAgICB0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEpIHtcbiAgICAgIHNlbGYuZml4ZWROb2RlU2V0LmFkZChub2RlRGF0YS5ub2RlSWQpO1xuICAgIH0pO1xuXG4gICAgLy8gYXNzaWduIGZpeGVkIG5vZGUgd2VpZ2h0cyB0byBjb21wb3VuZHMgaWYgdGhleSBjb250YWluIGZpeGVkIG5vZGVzXG4gICAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZml4ZWROb2RlV2VpZ2h0ID0gY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQobm9kZSk7XG4gICAgICAgIGlmIChmaXhlZE5vZGVXZWlnaHQgPiAwKSB7XG4gICAgICAgICAgbm9kZS5maXhlZE5vZGVXZWlnaHQgPSBmaXhlZE5vZGVXZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICB2YXIgbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZpeGVkTm9kZXNPbkhvcml6b250YWwgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5maXhlZE5vZGVzT25WZXJ0aWNhbCA9IG5ldyBTZXQoKTtcblxuICAgIC8vIGZpbGwgbWFwcyBhbmQgc2V0c1xuICAgIHRoaXMuZml4ZWROb2RlU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmFkZChub2RlSWQpO1xuICAgICAgc2VsZi5maXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQobm9kZUlkKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ25tZW50ID0gdGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2FsQWxpZ25tZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBpLCBbXSk7XG4gICAgICAgICAgdmVydGljYWxBbGlnbm1lbnRbaV0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LnNldChub2RlSWQsIFwiZHVtbXlcIiArIGkpO1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChcImR1bW15XCIgKyBpKS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5maXhlZE5vZGVTZXQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmFkZChcImR1bW15XCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBob3Jpem9udGFsQWxpZ25tZW50ID0gdGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9yaXpvbnRhbEFsaWdubWVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBpLCBbXSk7XG4gICAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudFtpXS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQobm9kZUlkLCBcImR1bW15XCIgKyBpKTtcbiAgICAgICAgICAgIHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChcImR1bW15XCIgKyBpKS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5maXhlZE5vZGVTZXQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5maXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQoXCJkdW1teVwiICsgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQ29TRUNvbnN0YW50cy5SRUxBWF9NT1ZFTUVOVF9PTl9DT05TVFJBSU5UUykge1xuXG4gICAgICB0aGlzLnNodWZmbGUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGosIHgsIGk7XG4gICAgICAgIGZvciAoaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMiAqIGFycmF5Lmxlbmd0aCAvIDM7IGktLSkge1xuICAgICAgICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgICB4ID0gYXJyYXlbaV07XG4gICAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgICBhcnJheVtqXSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfTtcblxuICAgICAgdGhpcy5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsID0gW107XG4gICAgICB0aGlzLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsID0gW107XG4gICAgICB0aGlzLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbCA9IG5ldyBNYXAoKTtcblxuICAgICAgLy8gZmlsbCBhcnJheXMgYW5kIG1hcHNcbiAgICAgIHRoaXMuY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICAgIHZhciBub2RlSWRMZWZ0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5sZWZ0KSA/IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQubGVmdCkgOiBjb25zdHJhaW50LmxlZnQ7XG4gICAgICAgICAgdmFyIG5vZGVJZFJpZ2h0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5yaWdodCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnJpZ2h0KSA6IGNvbnN0cmFpbnQucmlnaHQ7XG5cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbC5pbmNsdWRlcyhub2RlSWRMZWZ0KSkge1xuICAgICAgICAgICAgc2VsZi5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsLnB1c2gobm9kZUlkTGVmdCk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuc2V0KG5vZGVJZExlZnQsIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKG5vZGVJZExlZnQpKSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkTGVmdCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWRMZWZ0KVswXSkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkTGVmdCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkTGVmdCkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxmLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwuaW5jbHVkZXMobm9kZUlkUmlnaHQpKSB7XG4gICAgICAgICAgICBzZWxmLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwucHVzaChub2RlSWRSaWdodCk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuc2V0KG5vZGVJZFJpZ2h0LCBbXSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhub2RlSWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWRSaWdodCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWRSaWdodClbMF0pLmdldENlbnRlclgoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuc2V0KG5vZGVJZFJpZ2h0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRSaWdodCkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuZ2V0KG5vZGVJZExlZnQpLnB1c2goeyByaWdodDogbm9kZUlkUmlnaHQsIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBIb3Jpem9udGFsLmdldChub2RlSWRSaWdodCkucHVzaCh7IGxlZnQ6IG5vZGVJZExlZnQsIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vZGVJZFRvcCA9IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC50b3ApID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnRvcCkgOiBjb25zdHJhaW50LnRvcDtcbiAgICAgICAgICB2YXIgbm9kZUlkQm90dG9tID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LmJvdHRvbSkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKSA6IGNvbnN0cmFpbnQuYm90dG9tO1xuXG4gICAgICAgICAgaWYgKCFzZWxmLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsLmluY2x1ZGVzKG5vZGVJZFRvcCkpIHtcbiAgICAgICAgICAgIHNlbGYubm9kZXNJblJlbGF0aXZlVmVydGljYWwucHVzaChub2RlSWRUb3ApO1xuICAgICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbC5zZXQobm9kZUlkVG9wLCBbXSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKG5vZGVJZFRvcCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkVG9wLCBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQobm9kZUlkVG9wKVswXSkuZ2V0Q2VudGVyWSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuc2V0KG5vZGVJZFRvcCwgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkVG9wKS5nZXRDZW50ZXJZKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlVmVydGljYWwuaW5jbHVkZXMobm9kZUlkQm90dG9tKSkge1xuICAgICAgICAgICAgc2VsZi5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5wdXNoKG5vZGVJZEJvdHRvbSk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsLnNldChub2RlSWRCb3R0b20sIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMobm9kZUlkQm90dG9tKSkge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWRCb3R0b20sIHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWRCb3R0b20pWzBdKS5nZXRDZW50ZXJZKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkQm90dG9tLCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRCb3R0b20pLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuZ2V0KG5vZGVJZFRvcCkucHVzaCh7IGJvdHRvbTogbm9kZUlkQm90dG9tLCBnYXA6IGNvbnN0cmFpbnQuZ2FwIH0pO1xuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuZ2V0KG5vZGVJZEJvdHRvbSkucHVzaCh7IHRvcDogbm9kZUlkVG9wLCBnYXA6IGNvbnN0cmFpbnQuZ2FwIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN1YkdyYXBoT25Ib3Jpem9udGFsID0gbmV3IE1hcCgpOyAvLyBzdWJncmFwaCBmcm9tIHZlcnRpY2FsIFJQIGNvbnN0cmFpbnRzXG4gICAgICB2YXIgc3ViR3JhcGhPblZlcnRpY2FsID0gbmV3IE1hcCgpOyAvLyBzdWJncmFwaCBmcm9tIHZlcnRpY2FsIFJQIGNvbnN0cmFpbnRzXG5cbiAgICAgIC8vIGNvbnN0cnVjdCBzdWJncmFwaHMgZnJvbSByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHMgXG4gICAgICB0aGlzLmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgIGlmIChjb25zdHJhaW50LmxlZnQpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQubGVmdCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb25zdHJhaW50LmxlZnQpIDogY29uc3RyYWludC5sZWZ0O1xuICAgICAgICAgIHZhciByaWdodCA9IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQucmlnaHQpID8gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC5yaWdodCkgOiBjb25zdHJhaW50LnJpZ2h0O1xuICAgICAgICAgIGlmIChzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMobGVmdCkpIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLmdldChsZWZ0KS5wdXNoKHJpZ2h0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuc2V0KGxlZnQsIFtyaWdodF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3ViR3JhcGhPbkhvcml6b250YWwuaGFzKHJpZ2h0KSkge1xuICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuZ2V0KHJpZ2h0KS5wdXNoKGxlZnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uSG9yaXpvbnRhbC5zZXQocmlnaHQsIFtsZWZ0XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0b3AgPSBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQudG9wKSA/IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC50b3ApIDogY29uc3RyYWludC50b3A7XG4gICAgICAgICAgdmFyIGJvdHRvbSA9IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5ib3R0b20pID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb25zdHJhaW50LmJvdHRvbSkgOiBjb25zdHJhaW50LmJvdHRvbTtcbiAgICAgICAgICBpZiAoc3ViR3JhcGhPblZlcnRpY2FsLmhhcyh0b3ApKSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuZ2V0KHRvcCkucHVzaChib3R0b20pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KHRvcCwgW2JvdHRvbV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3ViR3JhcGhPblZlcnRpY2FsLmhhcyhib3R0b20pKSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuZ2V0KGJvdHRvbSkucHVzaCh0b3ApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KGJvdHRvbSwgW3RvcF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGZ1bmN0aW9uIHRvIGNvbnN0cnVjdCBjb21wb25lbnRzIGZyb20gYSBnaXZlbiBncmFwaCBcbiAgICAgIC8vIGFsc28gcmV0dXJucyBhbiBhcnJheSB0aGF0IGtlZXBzIHdoZXRoZXIgZWFjaCBjb21wb25lbnQgY29udGFpbnMgZml4ZWQgbm9kZVxuICAgICAgdmFyIGNvbnN0cnVjdENvbXBvbmVudHMgPSBmdW5jdGlvbiBjb25zdHJ1Y3RDb21wb25lbnRzKGdyYXBoLCBmaXhlZE5vZGVzKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciBpc0ZpeGVkID0gW107XG4gICAgICAgIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHNbY291bnRdID0gW107XG4gICAgICAgICAgICBpc0ZpeGVkW2NvdW50XSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0ga2V5O1xuICAgICAgICAgICAgcXVldWUucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgaWYgKGZpeGVkTm9kZXMuaGFzKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIGlzRml4ZWRbY291bnRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGguZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgbmVpZ2hib3JzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhuZWlnaGJvcikpIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgdmlzaXRlZC5hZGQobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50c1tjb3VudF0ucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBjb21wb25lbnRzOiBjb21wb25lbnRzLCBpc0ZpeGVkOiBpc0ZpeGVkIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVzdWx0T25Ib3Jpem9udGFsID0gY29uc3RydWN0Q29tcG9uZW50cyhzdWJHcmFwaE9uSG9yaXpvbnRhbCwgc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsKTtcbiAgICAgIHRoaXMuY29tcG9uZW50c09uSG9yaXpvbnRhbCA9IHJlc3VsdE9uSG9yaXpvbnRhbC5jb21wb25lbnRzO1xuICAgICAgdGhpcy5maXhlZENvbXBvbmVudHNPbkhvcml6b250YWwgPSByZXN1bHRPbkhvcml6b250YWwuaXNGaXhlZDtcbiAgICAgIHZhciByZXN1bHRPblZlcnRpY2FsID0gY29uc3RydWN0Q29tcG9uZW50cyhzdWJHcmFwaE9uVmVydGljYWwsIHNlbGYuZml4ZWROb2Rlc09uVmVydGljYWwpO1xuICAgICAgdGhpcy5jb21wb25lbnRzT25WZXJ0aWNhbCA9IHJlc3VsdE9uVmVydGljYWwuY29tcG9uZW50cztcbiAgICAgIHRoaXMuZml4ZWRDb21wb25lbnRzT25WZXJ0aWNhbCA9IHJlc3VsdE9uVmVydGljYWwuaXNGaXhlZDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHVwZGF0ZXMgbm9kZSBkaXNwbGFjZW1lbnRzIGJhc2VkIG9uIGNvbnN0cmFpbnRzXG5Db1NFTGF5b3V0LnByb3RvdHlwZS51cGRhdGVEaXNwbGFjZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEpIHtcbiAgICAgIHZhciBmaXhlZE5vZGUgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlRGF0YS5ub2RlSWQpO1xuICAgICAgZml4ZWROb2RlLmRpc3BsYWNlbWVudFggPSAwO1xuICAgICAgZml4ZWROb2RlLmRpc3BsYWNlbWVudFkgPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgIHZhciBhbGxWZXJ0aWNhbEFsaWdubWVudHMgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFZlcnRpY2FsQWxpZ25tZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG90YWxEaXNwbGFjZW1lbnRYID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxWZXJ0aWNhbEFsaWdubWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5maXhlZE5vZGVTZXQuaGFzKGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXVtqXSkpIHtcbiAgICAgICAgICAgIHRvdGFsRGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRYICs9IHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXVtqXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXZlcmFnZURpc3BsYWNlbWVudFggPSB0b3RhbERpc3BsYWNlbWVudFggLyBhbGxWZXJ0aWNhbEFsaWdubWVudHNbaV0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXVtqXSkuZGlzcGxhY2VtZW50WCA9IGF2ZXJhZ2VEaXNwbGFjZW1lbnRYO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkge1xuICAgICAgdmFyIGFsbEhvcml6b250YWxBbGlnbm1lbnRzID0gdGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEhvcml6b250YWxBbGlnbm1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b3RhbERpc3BsYWNlbWVudFkgPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZml4ZWROb2RlU2V0LmhhcyhhbGxIb3Jpem9udGFsQWxpZ25tZW50c1tpXVtqXSkpIHtcbiAgICAgICAgICAgIHRvdGFsRGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRZICs9IHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50WSA9IHRvdGFsRGlzcGxhY2VtZW50WSAvIGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxIb3Jpem9udGFsQWxpZ25tZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRZID0gYXZlcmFnZURpc3BsYWNlbWVudFk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcblxuICAgIGlmIChDb1NFQ29uc3RhbnRzLlJFTEFYX01PVkVNRU5UX09OX0NPTlNUUkFJTlRTKSB7XG4gICAgICAvLyBzaHVmZmxlIGFycmF5IHRvIHJhbmRvbWl6ZSBub2RlIHByb2Nlc3Npbmcgb3JkZXJcbiAgICAgIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIDEwID09IDApIHtcbiAgICAgICAgdGhpcy5zaHVmZmxlKHRoaXMubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbCk7XG4gICAgICAgIHRoaXMuc2h1ZmZsZSh0aGlzLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICBpZiAoIXNlbGYuZml4ZWROb2Rlc09uSG9yaXpvbnRhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgIHZhciBkaXNwbGFjZW1lbnQgPSAwO1xuICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudCA9IHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQobm9kZUlkKVswXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRYO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGNvbnN0cmFpbnQucmlnaHQpIC0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLmdldChub2RlSWQpIC0gZGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgICBpZiAoZGlmZiA8IGNvbnN0cmFpbnQuZ2FwKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50IC09IGNvbnN0cmFpbnQuZ2FwIC0gZGlmZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCkgLSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGNvbnN0cmFpbnQubGVmdCkgKyBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgKz0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWQsIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkKSArIGRpc3BsYWNlbWVudCk7XG4gICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFggPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRYID0gZGlzcGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubm9kZXNJblJlbGF0aXZlVmVydGljYWwuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIGlmICghc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IDA7XG4gICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQobm9kZUlkKVswXSkuZGlzcGxhY2VtZW50WTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsLmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmJvdHRvbSkge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKSAtIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCkgLSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgLT0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCkgLSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLmdldChjb25zdHJhaW50LnRvcCkgKyBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgKz0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkLCBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLmdldChub2RlSWQpICsgZGlzcGxhY2VtZW50KTtcbiAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRZID0gZGlzcGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wb25lbnRzT25Ib3Jpem9udGFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNPbkhvcml6b250YWxbaV07XG4gICAgICAgIGlmICh0aGlzLmZpeGVkQ29tcG9uZW50c09uSG9yaXpvbnRhbFtpXSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhjb21wb25lbnRbal0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFggPSAwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdmFyIGFjdHVhbE5vZGVzID0gdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pO1xuICAgICAgICAgICAgICBzdW0gKz0gYWN0dWFsTm9kZXMubGVuZ3RoICogdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWN0dWFsTm9kZXNbMF0pLmRpc3BsYWNlbWVudFg7XG4gICAgICAgICAgICAgIGNvdW50ICs9IGFjdHVhbE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1bSArPSB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFg7XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50ID0gc3VtIC8gY291bnQ7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WCA9IGF2ZXJhZ2VEaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRYID0gYXZlcmFnZURpc3BsYWNlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvbmVudHNPblZlcnRpY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNPblZlcnRpY2FsW2ldO1xuICAgICAgICBpZiAodGhpcy5maXhlZENvbXBvbmVudHNPblZlcnRpY2FsW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSAwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB2YXIgYWN0dWFsTm9kZXMgPSB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKTtcbiAgICAgICAgICAgICAgc3VtICs9IGFjdHVhbE5vZGVzLmxlbmd0aCAqIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGFjdHVhbE5vZGVzWzBdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgICAgICBjb3VudCArPSBhY3R1YWxOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXZlcmFnZURpc3BsYWNlbWVudCA9IHN1bSAvIGNvdW50O1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbXBvbmVudFtqXSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRZID0gYXZlcmFnZURpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFkgPSBhdmVyYWdlRGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2FsY3VsYXRlTm9kZXNUb0FwcGx5R3Jhdml0YXRpb25UbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVMaXN0ID0gW107XG4gIHZhciBncmFwaDtcblxuICB2YXIgZ3JhcGhzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0R3JhcGhzKCk7XG4gIHZhciBzaXplID0gZ3JhcGhzLmxlbmd0aDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBncmFwaCA9IGdyYXBoc1tpXTtcblxuICAgIGdyYXBoLnVwZGF0ZUNvbm5lY3RlZCgpO1xuXG4gICAgaWYgKCFncmFwaC5pc0Nvbm5lY3RlZCkge1xuICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQoZ3JhcGguZ2V0Tm9kZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGVMaXN0O1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY3JlYXRlQmVuZHBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIGVkZ2VzID0gZWRnZXMuY29uY2F0KHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCkpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG5cbiAgICBpZiAoIXZpc2l0ZWQuaGFzKGVkZ2UpKSB7XG4gICAgICB2YXIgc291cmNlID0gZWRnZS5nZXRTb3VyY2UoKTtcbiAgICAgIHZhciB0YXJnZXQgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gICAgICBpZiAoc291cmNlID09IHRhcmdldCkge1xuICAgICAgICBlZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgdGhpcy5jcmVhdGVEdW1teU5vZGVzRm9yQmVuZHBvaW50cyhlZGdlKTtcbiAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWRnZUxpc3QgPSBbXTtcblxuICAgICAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdChzb3VyY2UuZ2V0RWRnZUxpc3RUb05vZGUodGFyZ2V0KSk7XG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHRhcmdldC5nZXRFZGdlTGlzdFRvTm9kZShzb3VyY2UpKTtcblxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGVkZ2VMaXN0WzBdKSkge1xuICAgICAgICAgIGlmIChlZGdlTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlZGdlTGlzdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICB2YXIgbXVsdGlFZGdlID0gZWRnZUxpc3Rba107XG4gICAgICAgICAgICAgIG11bHRpRWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKG11bHRpRWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkZ2VMaXN0LmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGVkZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWQuc2l6ZSA9PSBlZGdlcy5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucG9zaXRpb25Ob2Rlc1JhZGlhbGx5ID0gZnVuY3Rpb24gKGZvcmVzdCkge1xuICAvLyBXZSB0aWxlIHRoZSB0cmVlcyB0byBhIGdyaWQgcm93IGJ5IHJvdzsgZmlyc3QgdHJlZSBzdGFydHMgYXQgKDAsMClcbiAgdmFyIGN1cnJlbnRTdGFydGluZ1BvaW50ID0gbmV3IFBvaW50KDAsIDApO1xuICB2YXIgbnVtYmVyT2ZDb2x1bW5zID0gTWF0aC5jZWlsKE1hdGguc3FydChmb3Jlc3QubGVuZ3RoKSk7XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgY3VycmVudFkgPSAwO1xuICB2YXIgY3VycmVudFggPSAwO1xuICB2YXIgcG9pbnQgPSBuZXcgUG9pbnREKDAsIDApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgJSBudW1iZXJPZkNvbHVtbnMgPT0gMCkge1xuICAgICAgLy8gU3RhcnQgb2YgYSBuZXcgcm93LCBtYWtlIHRoZSB4IGNvb3JkaW5hdGUgMCwgaW5jcmVtZW50IHRoZVxuICAgICAgLy8geSBjb29yZGluYXRlIHdpdGggdGhlIG1heCBoZWlnaHQgb2YgdGhlIHByZXZpb3VzIHJvd1xuICAgICAgY3VycmVudFggPSAwO1xuICAgICAgY3VycmVudFkgPSBoZWlnaHQ7XG5cbiAgICAgIGlmIChpICE9IDApIHtcbiAgICAgICAgY3VycmVudFkgKz0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OO1xuICAgICAgfVxuXG4gICAgICBoZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIHZhciB0cmVlID0gZm9yZXN0W2ldO1xuXG4gICAgLy8gRmluZCB0aGUgY2VudGVyIG9mIHRoZSB0cmVlXG4gICAgdmFyIGNlbnRlck5vZGUgPSBMYXlvdXQuZmluZENlbnRlck9mVHJlZSh0cmVlKTtcblxuICAgIC8vIFNldCB0aGUgc3RhcmluZyBwb2ludCBvZiB0aGUgbmV4dCB0cmVlXG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueCA9IGN1cnJlbnRYO1xuICAgIGN1cnJlbnRTdGFydGluZ1BvaW50LnkgPSBjdXJyZW50WTtcblxuICAgIC8vIERvIGEgcmFkaWFsIGxheW91dCBzdGFydGluZyB3aXRoIHRoZSBjZW50ZXJcbiAgICBwb2ludCA9IENvU0VMYXlvdXQucmFkaWFsTGF5b3V0KHRyZWUsIGNlbnRlck5vZGUsIGN1cnJlbnRTdGFydGluZ1BvaW50KTtcblxuICAgIGlmIChwb2ludC55ID4gaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKHBvaW50LnkpO1xuICAgIH1cblxuICAgIGN1cnJlbnRYID0gTWF0aC5mbG9vcihwb2ludC54ICsgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OKTtcbiAgfVxuXG4gIHRoaXMudHJhbnNmb3JtKG5ldyBQb2ludEQoTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YIC0gcG9pbnQueCAvIDIsIExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSAtIHBvaW50LnkgLyAyKSk7XG59O1xuXG5Db1NFTGF5b3V0LnJhZGlhbExheW91dCA9IGZ1bmN0aW9uICh0cmVlLCBjZW50ZXJOb2RlLCBzdGFydGluZ1BvaW50KSB7XG4gIHZhciByYWRpYWxTZXAgPSBNYXRoLm1heCh0aGlzLm1heERpYWdvbmFsSW5UcmVlKHRyZWUpLCBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04pO1xuICBDb1NFTGF5b3V0LmJyYW5jaFJhZGlhbExheW91dChjZW50ZXJOb2RlLCBudWxsLCAwLCAzNTksIDAsIHJhZGlhbFNlcCk7XG4gIHZhciBib3VuZHMgPSBMR3JhcGguY2FsY3VsYXRlQm91bmRzKHRyZWUpO1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdYKGJvdW5kcy5nZXRNaW5YKCkpO1xuICB0cmFuc2Zvcm0uc2V0RGV2aWNlT3JnWShib3VuZHMuZ2V0TWluWSgpKTtcbiAgdHJhbnNmb3JtLnNldFdvcmxkT3JnWChzdGFydGluZ1BvaW50LngpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdZKHN0YXJ0aW5nUG9pbnQueSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIG5vZGUudHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gIH1cblxuICB2YXIgYm90dG9tUmlnaHQgPSBuZXcgUG9pbnREKGJvdW5kcy5nZXRNYXhYKCksIGJvdW5kcy5nZXRNYXhZKCkpO1xuXG4gIHJldHVybiB0cmFuc2Zvcm0uaW52ZXJzZVRyYW5zZm9ybVBvaW50KGJvdHRvbVJpZ2h0KTtcbn07XG5cbkNvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudE9mTm9kZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGRpc3RhbmNlLCByYWRpYWxTZXBhcmF0aW9uKSB7XG4gIC8vIEZpcnN0LCBwb3NpdGlvbiB0aGlzIG5vZGUgYnkgZmluZGluZyBpdHMgYW5nbGUuXG4gIHZhciBoYWxmSW50ZXJ2YWwgPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlICsgMSkgLyAyO1xuXG4gIGlmIChoYWxmSW50ZXJ2YWwgPCAwKSB7XG4gICAgaGFsZkludGVydmFsICs9IDE4MDtcbiAgfVxuXG4gIHZhciBub2RlQW5nbGUgPSAoaGFsZkludGVydmFsICsgc3RhcnRBbmdsZSkgJSAzNjA7XG4gIHZhciB0ZXRhID0gbm9kZUFuZ2xlICogSUdlb21ldHJ5LlRXT19QSSAvIDM2MDtcblxuICAvLyBNYWtlIHBvbGFyIHRvIGphdmEgY29yZGluYXRlIGNvbnZlcnNpb24uXG4gIHZhciBjb3NfdGV0YSA9IE1hdGguY29zKHRldGEpO1xuICB2YXIgeF8gPSBkaXN0YW5jZSAqIE1hdGguY29zKHRldGEpO1xuICB2YXIgeV8gPSBkaXN0YW5jZSAqIE1hdGguc2luKHRldGEpO1xuXG4gIG5vZGUuc2V0Q2VudGVyKHhfLCB5Xyk7XG5cbiAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpc1xuICAvLyBmdW5jdGlvbi5cbiAgdmFyIG5laWdoYm9yRWRnZXMgPSBbXTtcbiAgbmVpZ2hib3JFZGdlcyA9IG5laWdoYm9yRWRnZXMuY29uY2F0KG5vZGUuZ2V0RWRnZXMoKSk7XG4gIHZhciBjaGlsZENvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG5cbiAgaWYgKHBhcmVudE9mTm9kZSAhPSBudWxsKSB7XG4gICAgY2hpbGRDb3VudC0tO1xuICB9XG5cbiAgdmFyIGJyYW5jaENvdW50ID0gMDtcblxuICB2YXIgaW5jRWRnZXNDb3VudCA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuICB2YXIgc3RhcnRJbmRleDtcblxuICB2YXIgZWRnZXMgPSBub2RlLmdldEVkZ2VzQmV0d2VlbihwYXJlbnRPZk5vZGUpO1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBlZGdlcywgcHJ1bmUgdGhlbSB1bnRpbCB0aGVyZSByZW1haW5zIG9ubHkgb25lXG4gIC8vIGVkZ2UuXG4gIHdoaWxlIChlZGdlcy5sZW5ndGggPiAxKSB7XG4gICAgLy9uZWlnaGJvckVkZ2VzLnJlbW92ZShlZGdlcy5yZW1vdmUoMCkpO1xuICAgIHZhciB0ZW1wID0gZWRnZXNbMF07XG4gICAgZWRnZXMuc3BsaWNlKDAsIDEpO1xuICAgIHZhciBpbmRleCA9IG5laWdoYm9yRWRnZXMuaW5kZXhPZih0ZW1wKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgbmVpZ2hib3JFZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpbmNFZGdlc0NvdW50LS07XG4gICAgY2hpbGRDb3VudC0tO1xuICB9XG5cbiAgaWYgKHBhcmVudE9mTm9kZSAhPSBudWxsKSB7XG4gICAgLy9hc3NlcnQgZWRnZXMubGVuZ3RoID09IDE7XG4gICAgc3RhcnRJbmRleCA9IChuZWlnaGJvckVkZ2VzLmluZGV4T2YoZWRnZXNbMF0pICsgMSkgJSBpbmNFZGdlc0NvdW50O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0SW5kZXggPSAwO1xuICB9XG5cbiAgdmFyIHN0ZXBBbmdsZSA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyBjaGlsZENvdW50O1xuXG4gIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBicmFuY2hDb3VudCAhPSBjaGlsZENvdW50OyBpID0gKytpICUgaW5jRWRnZXNDb3VudCkge1xuICAgIHZhciBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2VzW2ldLmdldE90aGVyRW5kKG5vZGUpO1xuXG4gICAgLy8gRG9uJ3QgYmFjayB0cmF2ZXJzZSB0byByb290IG5vZGUgaW4gY3VycmVudCB0cmVlLlxuICAgIGlmIChjdXJyZW50TmVpZ2hib3IgPT0gcGFyZW50T2ZOb2RlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRTdGFydEFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBicmFuY2hDb3VudCAqIHN0ZXBBbmdsZSkgJSAzNjA7XG4gICAgdmFyIGNoaWxkRW5kQW5nbGUgPSAoY2hpbGRTdGFydEFuZ2xlICsgc3RlcEFuZ2xlKSAlIDM2MDtcblxuICAgIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGN1cnJlbnROZWlnaGJvciwgbm9kZSwgY2hpbGRTdGFydEFuZ2xlLCBjaGlsZEVuZEFuZ2xlLCBkaXN0YW5jZSArIHJhZGlhbFNlcGFyYXRpb24sIHJhZGlhbFNlcGFyYXRpb24pO1xuXG4gICAgYnJhbmNoQ291bnQrKztcbiAgfVxufTtcblxuQ29TRUxheW91dC5tYXhEaWFnb25hbEluVHJlZSA9IGZ1bmN0aW9uICh0cmVlKSB7XG4gIHZhciBtYXhEaWFnb25hbCA9IEludGVnZXIuTUlOX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gdHJlZVtpXTtcbiAgICB2YXIgZGlhZ29uYWwgPSBub2RlLmdldERpYWdvbmFsKCk7XG5cbiAgICBpZiAoZGlhZ29uYWwgPiBtYXhEaWFnb25hbCkge1xuICAgICAgbWF4RGlhZ29uYWwgPSBkaWFnb25hbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4RGlhZ29uYWw7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGZvcm11bGEgaXMgMiB4IChsZXZlbCArIDEpIHggaWRlYWxFZGdlTGVuZ3RoXG4gIHJldHVybiAyICogKHRoaXMubGV2ZWwgKyAxKSAqIHRoaXMuaWRlYWxFZGdlTGVuZ3RoO1xufTtcblxuLy8gVGlsaW5nIG1ldGhvZHNcblxuLy8gR3JvdXAgemVybyBkZWdyZWUgbWVtYmVycyB3aG9zZSBwYXJlbnRzIGFyZSBub3QgdG8gYmUgdGlsZWQsIGNyZWF0ZSBkdW1teSBwYXJlbnRzIHdoZXJlIG5lZWRlZCBhbmQgZmlsbCBtZW1iZXJHcm91cHMgYnkgdGhlaXIgZHVtbXAgcGFyZW50IGlkJ3NcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gYXJyYXkgb2YgW3BhcmVudF9pZCB4IG9uZURlZ3JlZU5vZGVfaWRdXG4gIHZhciB0ZW1wTWVtYmVyR3JvdXBzID0ge307IC8vIEEgdGVtcG9yYXJ5IG1hcCBvZiBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnNcbiAgdGhpcy5tZW1iZXJHcm91cHMgPSB7fTsgLy8gQSBtYXAgb2YgZHVtbXkgcGFyZW50IG5vZGUgYW5kIGl0cyB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZFxuICB0aGlzLmlkVG9EdW1teU5vZGUgPSB7fTsgLy8gQSBtYXAgb2YgaWQgdG8gZHVtbXkgbm9kZSBcblxuICB2YXIgemVyb0RlZ3JlZSA9IFtdOyAvLyBMaXN0IG9mIHplcm8gZGVncmVlIG5vZGVzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZFxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIC8vIEZpbGwgemVybyBkZWdyZWUgbGlzdFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAvLyBJZiBhIG5vZGUgaGFzIHplcm8gZGVncmVlIGFuZCBpdHMgcGFyZW50IGlzIG5vdCB0byBiZSB0aWxlZCBpZiBleGlzdHMgYWRkIHRoYXQgbm9kZSB0byB6ZXJvRGVncmVzIGxpc3RcbiAgICBpZiAodGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKG5vZGUpID09PSAwICYmIChwYXJlbnQuaWQgPT0gdW5kZWZpbmVkIHx8ICF0aGlzLmdldFRvQmVUaWxlZChwYXJlbnQpKSkge1xuICAgICAgemVyb0RlZ3JlZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG1hcCBvZiBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB6ZXJvRGVncmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB6ZXJvRGVncmVlW2ldOyAvLyBaZXJvIGRlZ3JlZSBub2RlIGl0c2VsZlxuICAgIHZhciBwX2lkID0gbm9kZS5nZXRQYXJlbnQoKS5pZDsgLy8gUGFyZW50IGlkXG5cbiAgICBpZiAodHlwZW9mIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPT09IFwidW5kZWZpbmVkXCIpIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPSBbXTtcblxuICAgIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmNvbmNhdChub2RlKTsgLy8gUHVzaCBub2RlIHRvIHRoZSBsaXN0IGJlbG9uZ3MgdG8gaXRzIHBhcmVudCBpbiB0ZW1wTWVtYmVyR3JvdXBzXG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYXQgbGVhc3QgdHdvIG5vZGVzIGF0IGEgbGV2ZWwsIGNyZWF0ZSBhIGR1bW15IGNvbXBvdW5kIGZvciB0aGVtXG4gIE9iamVjdC5rZXlzKHRlbXBNZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKHBfaWQpIHtcbiAgICBpZiAodGVtcE1lbWJlckdyb3Vwc1twX2lkXS5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgZHVtbXlDb21wb3VuZElkID0gXCJEdW1teUNvbXBvdW5kX1wiICsgcF9pZDsgLy8gVGhlIGlkIG9mIGR1bW15IGNvbXBvdW5kIHdoaWNoIHdpbGwgYmUgY3JlYXRlZCBzb29uXG4gICAgICBzZWxmLm1lbWJlckdyb3Vwc1tkdW1teUNvbXBvdW5kSWRdID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXTsgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIG1lbWJlckdyb3Vwc1xuXG4gICAgICB2YXIgcGFyZW50ID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXVswXS5nZXRQYXJlbnQoKTsgLy8gVGhlIHBhcmVudCBvZiB6ZXJvIGRlZ3JlZSBub2RlcyB3aWxsIGJlIHRoZSBwYXJlbnQgb2YgbmV3IGR1bW15IGNvbXBvdW5kXG5cbiAgICAgIC8vIENyZWF0ZSBhIGR1bW15IGNvbXBvdW5kIHdpdGggY2FsY3VsYXRlZCBpZFxuICAgICAgdmFyIGR1bW15Q29tcG91bmQgPSBuZXcgQ29TRU5vZGUoc2VsZi5ncmFwaE1hbmFnZXIpO1xuICAgICAgZHVtbXlDb21wb3VuZC5pZCA9IGR1bW15Q29tcG91bmRJZDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ0xlZnQgPSBwYXJlbnQucGFkZGluZ0xlZnQgfHwgMDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ1JpZ2h0ID0gcGFyZW50LnBhZGRpbmdSaWdodCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nQm90dG9tID0gcGFyZW50LnBhZGRpbmdCb3R0b20gfHwgMDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ1RvcCA9IHBhcmVudC5wYWRkaW5nVG9wIHx8IDA7XG5cbiAgICAgIHNlbGYuaWRUb0R1bW15Tm9kZVtkdW1teUNvbXBvdW5kSWRdID0gZHVtbXlDb21wb3VuZDtcblxuICAgICAgdmFyIGR1bW15UGFyZW50R3JhcGggPSBzZWxmLmdldEdyYXBoTWFuYWdlcigpLmFkZChzZWxmLm5ld0dyYXBoKCksIGR1bW15Q29tcG91bmQpO1xuICAgICAgdmFyIHBhcmVudEdyYXBoID0gcGFyZW50LmdldENoaWxkKCk7XG5cbiAgICAgIC8vIEFkZCBkdW1teSBjb21wb3VuZCB0byBwYXJlbnQgdGhlIGdyYXBoXG4gICAgICBwYXJlbnRHcmFwaC5hZGQoZHVtbXlDb21wb3VuZCk7XG5cbiAgICAgIC8vIEZvciBlYWNoIHplcm8gZGVncmVlIG5vZGUgaW4gdGhpcyBsZXZlbCByZW1vdmUgaXQgZnJvbSBpdHMgcGFyZW50IGdyYXBoIGFuZCBhZGQgaXQgdG8gdGhlIGdyYXBoIG9mIGR1bW15IHBhcmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXVtpXTtcblxuICAgICAgICBwYXJlbnRHcmFwaC5yZW1vdmUobm9kZSk7XG4gICAgICAgIGR1bW15UGFyZW50R3JhcGguYWRkKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhckNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoaWxkR3JhcGhNYXAgPSB7fTtcbiAgdmFyIGlkVG9Ob2RlID0ge307XG5cbiAgLy8gR2V0IGNvbXBvdW5kIG9yZGVyaW5nIGJ5IGZpbmRpbmcgdGhlIGlubmVyIG9uZSBmaXJzdFxuICB0aGlzLnBlcmZvcm1ERlNPbkNvbXBvdW5kcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wb3VuZE9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZFRvTm9kZVt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gdGhpcy5jb21wb3VuZE9yZGVyW2ldO1xuICAgIGNoaWxkR3JhcGhNYXBbdGhpcy5jb21wb3VuZE9yZGVyW2ldLmlkXSA9IFtdLmNvbmNhdCh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKS5nZXROb2RlcygpKTtcblxuICAgIC8vIFJlbW92ZSBjaGlsZHJlbiBvZiBjb21wb3VuZHNcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUodGhpcy5jb21wb3VuZE9yZGVyW2ldLmdldENoaWxkKCkpO1xuICAgIHRoaXMuY29tcG91bmRPcmRlcltpXS5jaGlsZCA9IG51bGw7XG4gIH1cblxuICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG5cbiAgLy8gVGlsZSB0aGUgcmVtb3ZlZCBjaGlsZHJlblxuICB0aGlzLnRpbGVDb21wb3VuZE1lbWJlcnMoY2hpbGRHcmFwaE1hcCwgaWRUb05vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2xlYXJaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGlsZWRaZXJvRGVncmVlUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjayA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKHRoaXMubWVtYmVyR3JvdXBzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBjb21wb3VuZE5vZGUgPSBzZWxmLmlkVG9EdW1teU5vZGVbaWRdOyAvLyBHZXQgdGhlIGR1bW15IGNvbXBvdW5kXG5cbiAgICB0aWxlZFplcm9EZWdyZWVQYWNrW2lkXSA9IHNlbGYudGlsZU5vZGVzKHNlbGYubWVtYmVyR3JvdXBzW2lkXSwgY29tcG91bmROb2RlLnBhZGRpbmdMZWZ0ICsgY29tcG91bmROb2RlLnBhZGRpbmdSaWdodCk7XG5cbiAgICAvLyBTZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGR1bW15IGNvbXBvdW5kIGFzIGNhbGN1bGF0ZWRcbiAgICBjb21wb3VuZE5vZGUucmVjdC53aWR0aCA9IHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLndpZHRoO1xuICAgIGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodCA9IHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmhlaWdodDtcbiAgICBjb21wb3VuZE5vZGUuc2V0Q2VudGVyKHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmNlbnRlclgsIHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmNlbnRlclkpO1xuXG4gICAgLy8gY29tcG91bmQgbGVmdCBhbmQgdG9wIG1hcmdpbmdzIGZvciBsYWJlbHNcbiAgICAvLyB3aGVuIG5vZGUgbGFiZWxzIGFyZSBpbmNsdWRlZCwgdGhlc2UgdmFsdWVzIG1heSBiZSBzZXQgdG8gZGlmZmVyZW50IHZhbHVlcyBiZWxvdyBhbmQgYXJlIHVzZWQgaW4gdGlsaW5nUG9zdExheW91dCxcbiAgICAvLyBvdGhlcndpc2UgdGhleSBzdGF5IGFzIHplcm9cbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5MZWZ0ID0gMDtcbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSAwO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyBhbmQgc2V0IGxhYmVsIG1hcmdpbnMgZm9yIGxlZnQgYW5kIHRvcFxuICAgIGlmIChDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjb21wb3VuZE5vZGUucmVjdC53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQ7XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImxlZnRcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gY29tcG91bmROb2RlLmxhYmVsV2lkdGg7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgoY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueSAtPSAoY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChoZWlnaHQgKyBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVDb21wb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbENvbXBvdW5kTm9kZSA9IHRoaXMuY29tcG91bmRPcmRlcltpXTtcbiAgICB2YXIgaWQgPSBsQ29tcG91bmROb2RlLmlkO1xuICAgIHZhciBob3Jpem9udGFsTWFyZ2luID0gbENvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG4gICAgdmFyIGxhYmVsTWFyZ2luTGVmdCA9IGxDb21wb3VuZE5vZGUubGFiZWxNYXJnaW5MZWZ0O1xuICAgIHZhciBsYWJlbE1hcmdpblRvcCA9IGxDb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3A7XG5cbiAgICB0aGlzLmFkanVzdExvY2F0aW9ucyh0aGlzLnRpbGVkTWVtYmVyUGFja1tpZF0sIGxDb21wb3VuZE5vZGUucmVjdC54LCBsQ29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4sIGxhYmVsTWFyZ2luTGVmdCwgbGFiZWxNYXJnaW5Ub3ApO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRpbGVkUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjaztcblxuICBPYmplY3Qua2V5cyh0aWxlZFBhY2spLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmQgYnkgaXRzIGlkXG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQ7XG4gICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gY29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG4gICAgdmFyIGxhYmVsTWFyZ2luTGVmdCA9IGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQ7XG4gICAgdmFyIGxhYmVsTWFyZ2luVG9wID0gY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgd3J0IGl0cyBjb21wb3VuZFxuICAgIHNlbGYuYWRqdXN0TG9jYXRpb25zKHRpbGVkUGFja1tpZF0sIGNvbXBvdW5kTm9kZS5yZWN0LngsIGNvbXBvdW5kTm9kZS5yZWN0LnksIGhvcml6b250YWxNYXJnaW4sIHZlcnRpY2FsTWFyZ2luLCBsYWJlbE1hcmdpbkxlZnQsIGxhYmVsTWFyZ2luVG9wKTtcbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRUb0JlVGlsZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgaWQgPSBub2RlLmlkO1xuICAvL2ZpcnN0bHkgY2hlY2sgdGhlIHByZXZpb3VzIHJlc3VsdHNcbiAgaWYgKHRoaXMudG9CZVRpbGVkW2lkXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CZVRpbGVkW2lkXTtcbiAgfVxuXG4gIC8vb25seSBjb21wb3VuZCBub2RlcyBhcmUgdG8gYmUgdGlsZWRcbiAgdmFyIGNoaWxkR3JhcGggPSBub2RlLmdldENoaWxkKCk7XG4gIGlmIChjaGlsZEdyYXBoID09IG51bGwpIHtcbiAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY2hpbGRyZW4gPSBjaGlsZEdyYXBoLmdldE5vZGVzKCk7IC8vIEdldCB0aGUgY2hpbGRyZW4gbm9kZXNcblxuICAvL2EgY29tcG91bmQgbm9kZSBpcyBub3QgdG8gYmUgdGlsZWQgaWYgYWxsIG9mIGl0cyBjb21wb3VuZCBjaGlsZHJlbiBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWUodGhlQ2hpbGQpID4gMCkge1xuICAgICAgdGhpcy50b0JlVGlsZWRbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy9wYXNzIHRoZSBjaGlsZHJlbiBub3QgaGF2aW5nIHRoZSBjb21wb3VuZCBzdHJ1Y3R1cmVcbiAgICBpZiAodGhlQ2hpbGQuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFt0aGVDaGlsZC5pZF0gPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRUb0JlVGlsZWQodGhlQ2hpbGQpKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdGhpcy50b0JlVGlsZWRbaWRdID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSBkZXBlbmRpbmcgb2YgaXRzIGVkZ2VzIGFuZCBpbmRlcGVuZGVudCBvZiBpdHMgY2hpbGRyZW5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldE5vZGVEZWdyZWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgaWQgPSBub2RlLmlkO1xuICB2YXIgZWRnZXMgPSBub2RlLmdldEVkZ2VzKCk7XG4gIHZhciBkZWdyZWUgPSAwO1xuXG4gIC8vIEZvciB0aGUgZWRnZXMgY29ubmVjdGVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIGlmIChlZGdlLmdldFNvdXJjZSgpLmlkICE9PSBlZGdlLmdldFRhcmdldCgpLmlkKSB7XG4gICAgICBkZWdyZWUgPSBkZWdyZWUgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuLy8gR2V0IGRlZ3JlZSBvZiBhIG5vZGUgd2l0aCBpdHMgY2hpbGRyZW5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgZGVncmVlID0gdGhpcy5nZXROb2RlRGVncmVlKG5vZGUpO1xuICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgZGVncmVlICs9IHRoaXMuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbihjaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGRlZ3JlZTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnBlcmZvcm1ERlNPbkNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb21wb3VuZE9yZGVyID0gW107XG4gIHRoaXMuZmlsbENvbXBleE9yZGVyQnlERlModGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCkpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuZmlsbENvbXBleE9yZGVyQnlERlMgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjaGlsZC5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZmlsbENvbXBleE9yZGVyQnlERlMoY2hpbGQuZ2V0Q2hpbGQoKS5nZXROb2RlcygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0VG9CZVRpbGVkKGNoaWxkKSkge1xuICAgICAgdGhpcy5jb21wb3VuZE9yZGVyLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIHBsYWNlcyBlYWNoIHplcm8gZGVncmVlIG1lbWJlciB3cnQgZ2l2ZW4gKHgseSkgY29vcmRpbmF0ZXMgKHRvcCBsZWZ0KS5cbiovXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5hZGp1c3RMb2NhdGlvbnMgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCB4LCB5LCBjb21wb3VuZEhvcml6b250YWxNYXJnaW4sIGNvbXBvdW5kVmVydGljYWxNYXJnaW4sIGNvbXBvdW5kTGFiZWxNYXJnaW5MZWZ0LCBjb21wb3VuZExhYmVsTWFyZ2luVG9wKSB7XG4gIHggKz0gY29tcG91bmRIb3Jpem9udGFsTWFyZ2luICsgY29tcG91bmRMYWJlbE1hcmdpbkxlZnQ7XG4gIHkgKz0gY29tcG91bmRWZXJ0aWNhbE1hcmdpbiArIGNvbXBvdW5kTGFiZWxNYXJnaW5Ub3A7XG5cbiAgdmFyIGxlZnQgPSB4O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcm93ID0gb3JnYW5pemF0aW9uLnJvd3NbaV07XG4gICAgeCA9IGxlZnQ7XG4gICAgdmFyIG1heEhlaWdodCA9IDA7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGxub2RlID0gcm93W2pdO1xuXG4gICAgICBsbm9kZS5yZWN0LnggPSB4OyAvLyArIGxub2RlLnJlY3Qud2lkdGggLyAyO1xuICAgICAgbG5vZGUucmVjdC55ID0geTsgLy8gKyBsbm9kZS5yZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgIHggKz0gbG5vZGUucmVjdC53aWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcblxuICAgICAgaWYgKGxub2RlLnJlY3QuaGVpZ2h0ID4gbWF4SGVpZ2h0KSBtYXhIZWlnaHQgPSBsbm9kZS5yZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICB5ICs9IG1heEhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVDb21wb3VuZE1lbWJlcnMgPSBmdW5jdGlvbiAoY2hpbGRHcmFwaE1hcCwgaWRUb05vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRpbGVkTWVtYmVyUGFjayA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKGNoaWxkR3JhcGhNYXApLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgLy8gR2V0IHRoZSBjb21wb3VuZCBub2RlXG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IGlkVG9Ob2RlW2lkXTtcblxuICAgIHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXSA9IHNlbGYudGlsZU5vZGVzKGNoaWxkR3JhcGhNYXBbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLndpZHRoO1xuICAgIGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodCA9IHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS5oZWlnaHQ7XG4gICAgY29tcG91bmROb2RlLnNldENlbnRlcihzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0uY2VudGVyWCwgc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLmNlbnRlclkpO1xuXG4gICAgLy8gY29tcG91bmQgbGVmdCBhbmQgdG9wIG1hcmdpbmdzIGZvciBsYWJlbHNcbiAgICAvLyB3aGVuIG5vZGUgbGFiZWxzIGFyZSBpbmNsdWRlZCwgdGhlc2UgdmFsdWVzIG1heSBiZSBzZXQgdG8gZGlmZmVyZW50IHZhbHVlcyBiZWxvdyBhbmQgYXJlIHVzZWQgaW4gdGlsaW5nUG9zdExheW91dCxcbiAgICAvLyBvdGhlcndpc2UgdGhleSBzdGF5IGFzIHplcm9cbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5MZWZ0ID0gMDtcbiAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSAwO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyBhbmQgc2V0IGxhYmVsIG1hcmdpbnMgZm9yIGxlZnQgYW5kIHRvcFxuICAgIGlmIChDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjb21wb3VuZE5vZGUucmVjdC53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQ7XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImxlZnRcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gY29tcG91bmROb2RlLmxhYmVsV2lkdGg7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnggLT0gKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgoY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldFdpZHRoKHdpZHRoICsgY29tcG91bmROb2RlLmxhYmVsV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiY2VudGVyXCIgJiYgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueSAtPSAoY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnNldEhlaWdodChoZWlnaHQgKyBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVOb2RlcyA9IGZ1bmN0aW9uIChub2RlcywgbWluV2lkdGgpIHtcbiAgdmFyIGhvcml6b250YWxPcmcgPSB0aGlzLnRpbGVOb2Rlc0J5RmF2b3JpbmdEaW0obm9kZXMsIG1pbldpZHRoLCB0cnVlKTtcbiAgdmFyIHZlcnRpY2FsT3JnID0gdGhpcy50aWxlTm9kZXNCeUZhdm9yaW5nRGltKG5vZGVzLCBtaW5XaWR0aCwgZmFsc2UpO1xuXG4gIHZhciBob3Jpem9udGFsUmF0aW8gPSB0aGlzLmdldE9yZ1JhdGlvKGhvcml6b250YWxPcmcpO1xuICB2YXIgdmVydGljYWxSYXRpbyA9IHRoaXMuZ2V0T3JnUmF0aW8odmVydGljYWxPcmcpO1xuICB2YXIgYmVzdE9yZztcblxuICAvLyB0aGUgYmVzdCByYXRpbyBpcyB0aGUgb25lIHRoYXQgaXMgY2xvc2VyIHRvIDEgc2luY2UgdGhlIHJhdGlvcyBhcmUgYWxyZWFkeSBub3JtYWxpemVkXG4gIC8vIGFuZCB0aGUgYmVzdCBvcmdhbml6YXRpb24gaXMgdGhlIG9uZSB0aGF0IGhhcyB0aGUgYmVzdCByYXRpb1xuICBpZiAodmVydGljYWxSYXRpbyA8IGhvcml6b250YWxSYXRpbykge1xuICAgIGJlc3RPcmcgPSB2ZXJ0aWNhbE9yZztcbiAgfSBlbHNlIHtcbiAgICBiZXN0T3JnID0gaG9yaXpvbnRhbE9yZztcbiAgfVxuXG4gIHJldHVybiBiZXN0T3JnO1xufTtcblxuLy8gZ2V0IHRoZSB3aWR0aC9oZWlnaHQgcmF0aW8gb2YgdGhlIG9yZ2FuaXphdGlvbiB0aGF0IGlzIG5vcm1hbGl6ZWQgc28gdGhhdCBpdCB3aWxsIG5vdCBiZSBsZXNzIHRoYW4gMVxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0T3JnUmF0aW8gPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIC8vIGdldCBkaW1lbnNpb25zIGFuZCBjYWxjdWxhdGUgdGhlIGluaXRpYWwgcmF0aW9cbiAgdmFyIHdpZHRoID0gb3JnYW5pemF0aW9uLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gb3JnYW5pemF0aW9uLmhlaWdodDtcbiAgdmFyIHJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG5cbiAgLy8gaWYgdGhlIGluaXRpYWwgcmF0aW8gaXMgbGVzcyB0aGVuIDEgdGhlbiBpbnZlcnNlIGl0XG4gIGlmIChyYXRpbyA8IDEpIHtcbiAgICByYXRpbyA9IDEgLyByYXRpbztcbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgbm9ybWFsaXplZCByYXRpb1xuICByZXR1cm4gcmF0aW87XG59O1xuXG4vKlxuICogQ2FsY3VsYXRlcyB0aGUgaWRlYWwgd2lkdGggZm9yIHRoZSByb3dzLiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoYXRcbiAqIGVhY2ggbm9kZSBoYXMgdGhlIHNhbWUgc2l6ZXMgYW5kIGNhbGN1bGF0ZXMgdGhlIGlkZWFsIHJvdyB3aWR0aCB0aGF0XG4gKiBhcHByb3hpbWF0ZXMgYSBzcXVhcmUgc2hhcGVkIGNvbXBsZXggYWNjb3JkaW5nbHkuIEhvd2V2ZXIsIHNpbmNlIG5vZGVzIHdvdWxkXG4gKiBoYXZlIGRpZmZlcmVudCBzaXplcyBzb21lIHJvd3Mgd291bGQgaGF2ZSBkaWZmZXJlbnQgc2l6ZXMgYW5kIHRoZSByZXN1bHRpbmdcbiAqIHNoYXBlIHdvdWxkIG5vdCBiZSBhbiBleGFjdCBzcXVhcmUuXG4gKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGNJZGVhbFJvd1dpZHRoID0gZnVuY3Rpb24gKG1lbWJlcnMsIGZhdm9ySG9yaXpvbnRhbERpbSkge1xuICAvLyBUbyBhcHByb3hpbWF0ZSBhIHNxdWFyZSBzaGFwZWQgY29tcGxleCB3ZSBuZWVkIHRvIG1ha2UgY29tcGxleCB3aWR0aCBlcXVhbCB0byBjb21wbGV4IGhlaWdodC5cbiAgLy8gVG8gYWNoaWV2ZSB0aGlzIHdlIG5lZWQgdG8gc29sdmUgdGhlIGZvbGxvd2luZyBlcXVhdGlvbiBzeXN0ZW0gZm9yIGhjOlxuICAvLyAoeCArIGJ4KSAqIGhjIC0gYnggPSAoeSArIGJ5KSAqIHZjIC0gYnksIGhjICogdmMgPSBuXG4gIC8vIHdoZXJlIHggaXMgdGhlIGF2YXJhZ2Ugd2lkdGggb2YgdGhlIG5vZGVzLCB5IGlzIHRoZSBhdmFyYWdlIGhlaWdodCBvZiBub2Rlc1xuICAvLyBieCBhbmQgYnkgYXJlIHRoZSBidWZmZXIgc2l6ZXMgaW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGltZW5zaW9ucyBhY2NvcmRpbmdseSxcbiAgLy8gaGMgYW5kIHZjIGFyZSB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGltZW5zaW9uc1xuICAvLyBuIGlzIG51bWJlciBvZiBtZW1iZXJzLlxuXG4gIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMO1xuICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUw7XG5cbiAgLy8gbnVtYmVyIG9mIG1lbWJlcnNcbiAgdmFyIG1lbWJlcnNTaXplID0gbWVtYmVycy5sZW5ndGg7XG5cbiAgLy8gc3VtIG9mIHRoZSB3aWR0aCBvZiBhbGwgbWVtYmVyc1xuICB2YXIgdG90YWxXaWR0aCA9IDA7XG5cbiAgLy8gc3VtIG9mIHRoZSBoZWlnaHQgb2YgYWxsIG1lbWJlcnNcbiAgdmFyIHRvdGFsSGVpZ2h0ID0gMDtcblxuICB2YXIgbWF4V2lkdGggPSAwO1xuXG4gIC8vIHRyYXZlcnNlIGFsbCBtZW1iZXJzIHRvIGNhbGN1bGF0ZSB0b3RhbCB3aWR0aCBhbmQgdG90YWwgaGVpZ2h0IGFuZCBnZXQgdGhlIG1heGltdW0gbWVtYmVycyB3aWR0aFxuICBtZW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB0b3RhbFdpZHRoICs9IG5vZGUuZ2V0V2lkdGgoKTtcbiAgICB0b3RhbEhlaWdodCArPSBub2RlLmdldEhlaWdodCgpO1xuXG4gICAgaWYgKG5vZGUuZ2V0V2lkdGgoKSA+IG1heFdpZHRoKSB7XG4gICAgICBtYXhXaWR0aCA9IG5vZGUuZ2V0V2lkdGgoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGF2ZXJhZ2Ugd2lkdGggb2YgdGhlIG1lbWJlcnNcbiAgdmFyIGF2ZXJhZ2VXaWR0aCA9IHRvdGFsV2lkdGggLyBtZW1iZXJzU2l6ZTtcblxuICAvLyBhdmVyYWdlIGhlaWdodCBvZiB0aGUgbWVtYmVyc1xuICB2YXIgYXZlcmFnZUhlaWdodCA9IHRvdGFsSGVpZ2h0IC8gbWVtYmVyc1NpemU7XG5cbiAgLy8gc29sdmluZyB0aGUgaW5pdGlhbCBlcXVhdGlvbiBzeXN0ZW0gZm9yIHRoZSBoYyB5aWVsZHMgdGhlIGZvbGxvd2luZyBzZWNvbmQgZGVncmVlIGVxdWF0aW9uOlxuICAvLyBoY14yICogKHgrYngpICsgaGMgKiAoYnkgLSBieCkgLSBuICogKHkgKyBieSkgPSAwXG5cbiAgLy8gdGhlIGRlbHRhIHZhbHVlIHRvIHNvbHZlIHRoZSBlcXVhdGlvbiBhYm92ZSBmb3IgaGNcbiAgdmFyIGRlbHRhID0gTWF0aC5wb3codmVydGljYWxQYWRkaW5nIC0gaG9yaXpvbnRhbFBhZGRpbmcsIDIpICsgNCAqIChhdmVyYWdlV2lkdGggKyBob3Jpem9udGFsUGFkZGluZykgKiAoYXZlcmFnZUhlaWdodCArIHZlcnRpY2FsUGFkZGluZykgKiBtZW1iZXJzU2l6ZTtcblxuICAvLyBzb2x2ZSB0aGUgZXF1YXRpb24gdXNpbmcgZGVsdGEgdmFsdWUgdG8gY2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGNvdW50XG4gIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIGFuIGlkZWFsIHJvd1xuICB2YXIgaG9yaXpvbnRhbENvdW50RG91YmxlID0gKGhvcml6b250YWxQYWRkaW5nIC0gdmVydGljYWxQYWRkaW5nICsgTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIChhdmVyYWdlV2lkdGggKyBob3Jpem9udGFsUGFkZGluZykpO1xuICAvLyByb3VuZCB0aGUgY2FsY3VsYXRlZCBob3Jpem9udGFsIGNvdW50IHVwIG9yIGRvd24gYWNjb3JkaW5nIHRvIHRoZSBmYXZvcmVkIGRpbWVuc2lvblxuICB2YXIgaG9yaXpvbnRhbENvdW50O1xuXG4gIGlmIChmYXZvckhvcml6b250YWxEaW0pIHtcbiAgICBob3Jpem9udGFsQ291bnQgPSBNYXRoLmNlaWwoaG9yaXpvbnRhbENvdW50RG91YmxlKTtcbiAgICAvLyBpZiBob3Jpem9udGFsQ291bnQgY291bnQgaXMgbm90IGEgZmxvYXQgdmFsdWUgdGhlbiBib3RoIG9mIHJvdW5kaW5nIHRvIGZsb29yIGFuZCBjZWlsXG4gICAgLy8gd2lsbCB5aWVsZCB0aGUgc2FtZSB2YWx1ZXMuIEluc3RlYWQgb2YgcmVwZWF0aW5nIHRoZSBzYW1lIGNhbGN1bGF0aW9uIHRyeSBnb2luZyB1cFxuICAgIC8vIHdoaWxlIGZhdm9yaW5nIGhvcml6b250YWwgZGltZW5zaW9uIGluIHN1Y2ggY2FzZXNcbiAgICBpZiAoaG9yaXpvbnRhbENvdW50ID09IGhvcml6b250YWxDb3VudERvdWJsZSkge1xuICAgICAgaG9yaXpvbnRhbENvdW50Kys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhvcml6b250YWxDb3VudCA9IE1hdGguZmxvb3IoaG9yaXpvbnRhbENvdW50RG91YmxlKTtcbiAgfVxuXG4gIC8vIGlkZWFsIHdpZHRoIHRvIGJlIGNhbGN1bGF0ZWRcbiAgdmFyIGlkZWFsV2lkdGggPSBob3Jpem9udGFsQ291bnQgKiAoYXZlcmFnZVdpZHRoICsgaG9yaXpvbnRhbFBhZGRpbmcpIC0gaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgLy8gaWYgbWF4IHdpZHRoIGlzIGJpZ2dlciB0aGFuIGNhbGN1bGF0ZWQgaWRlYWwgd2lkdGggcmVzZXQgaWRlYWwgd2lkdGggdG8gaXRcbiAgaWYgKG1heFdpZHRoID4gaWRlYWxXaWR0aCkge1xuICAgIGlkZWFsV2lkdGggPSBtYXhXaWR0aDtcbiAgfVxuXG4gIC8vIGFkZCB0aGUgbGVmdC1yaWdodCBtYXJnaW5zIHRvIHRoZSBpZGVhbCByb3cgd2lkdGhcbiAgaWRlYWxXaWR0aCArPSBob3Jpem9udGFsUGFkZGluZyAqIDI7XG5cbiAgLy8gcmV0dXJuIHRoZSBpZGVhbCByb3cgd2lkdGgxXG4gIHJldHVybiBpZGVhbFdpZHRoO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZU5vZGVzQnlGYXZvcmluZ0RpbSA9IGZ1bmN0aW9uIChub2RlcywgbWluV2lkdGgsIGZhdm9ySG9yaXpvbnRhbERpbSkge1xuICB2YXIgdmVydGljYWxQYWRkaW5nID0gQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTDtcbiAgdmFyIGhvcml6b250YWxQYWRkaW5nID0gQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19IT1JJWk9OVEFMO1xuICB2YXIgdGlsaW5nQ29tcGFyZUJ5ID0gQ29TRUNvbnN0YW50cy5USUxJTkdfQ09NUEFSRV9CWTtcbiAgdmFyIG9yZ2FuaXphdGlvbiA9IHtcbiAgICByb3dzOiBbXSxcbiAgICByb3dXaWR0aDogW10sXG4gICAgcm93SGVpZ2h0OiBbXSxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IG1pbldpZHRoLCAvLyBhc3N1bWUgbWluSGVpZ2h0IGVxdWFscyB0byBtaW5XaWR0aFxuICAgIHZlcnRpY2FsUGFkZGluZzogdmVydGljYWxQYWRkaW5nLFxuICAgIGhvcml6b250YWxQYWRkaW5nOiBob3Jpem9udGFsUGFkZGluZyxcbiAgICBjZW50ZXJYOiAwLFxuICAgIGNlbnRlclk6IDBcbiAgfTtcblxuICBpZiAodGlsaW5nQ29tcGFyZUJ5KSB7XG4gICAgb3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGggPSB0aGlzLmNhbGNJZGVhbFJvd1dpZHRoKG5vZGVzLCBmYXZvckhvcml6b250YWxEaW0pO1xuICB9XG5cbiAgdmFyIGdldE5vZGVBcmVhID0gZnVuY3Rpb24gZ2V0Tm9kZUFyZWEobikge1xuICAgIHJldHVybiBuLnJlY3Qud2lkdGggKiBuLnJlY3QuaGVpZ2h0O1xuICB9O1xuXG4gIHZhciBhcmVhQ29tcGFyZUZjbiA9IGZ1bmN0aW9uIGFyZWFDb21wYXJlRmNuKG4xLCBuMikge1xuICAgIHJldHVybiBnZXROb2RlQXJlYShuMikgLSBnZXROb2RlQXJlYShuMSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgbm9kZXMgaW4gZGVzY2VuZGluZyBvcmRlciBvZiB0aGVpciBhcmVhc1xuICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChuMSwgbjIpIHtcbiAgICB2YXIgY21wQnkgPSBhcmVhQ29tcGFyZUZjbjtcbiAgICBpZiAob3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGgpIHtcbiAgICAgIGNtcEJ5ID0gdGlsaW5nQ29tcGFyZUJ5O1xuICAgICAgcmV0dXJuIGNtcEJ5KG4xLmlkLCBuMi5pZCk7XG4gICAgfVxuICAgIHJldHVybiBjbXBCeShuMSwgbjIpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIG9yZ2FuaXphdGlvbiAtPiBjYWxjdWxhdGUgY29tcG91bmQgY2VudGVyXG4gIHZhciBzdW1DZW50ZXJYID0gMDtcbiAgdmFyIHN1bUNlbnRlclkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBzdW1DZW50ZXJYICs9IGxOb2RlLmdldENlbnRlclgoKTtcbiAgICBzdW1DZW50ZXJZICs9IGxOb2RlLmdldENlbnRlclkoKTtcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5jZW50ZXJYID0gc3VtQ2VudGVyWCAvIG5vZGVzLmxlbmd0aDtcbiAgb3JnYW5pemF0aW9uLmNlbnRlclkgPSBzdW1DZW50ZXJZIC8gbm9kZXMubGVuZ3RoO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JnYW5pemF0aW9uIC0+IHRpbGUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIDAsIG1pbldpZHRoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2FuQWRkSG9yaXpvbnRhbChvcmdhbml6YXRpb24sIGxOb2RlLnJlY3Qud2lkdGgsIGxOb2RlLnJlY3QuaGVpZ2h0KSkge1xuICAgICAgdmFyIHJvd0luZGV4ID0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoIC0gMTtcbiAgICAgIGlmICghb3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGgpIHtcbiAgICAgICAgcm93SW5kZXggPSB0aGlzLmdldFNob3J0ZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIHJvd0luZGV4LCBtaW5XaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aCwgbWluV2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMuc2hpZnRUb0xhc3RSb3cob3JnYW5pemF0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBvcmdhbml6YXRpb247XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbnNlcnROb2RlVG9Sb3cgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCBub2RlLCByb3dJbmRleCwgbWluV2lkdGgpIHtcbiAgdmFyIG1pbkNvbXBvdW5kU2l6ZSA9IG1pbldpZHRoO1xuXG4gIC8vIEFkZCBuZXcgcm93IGlmIG5lZWRlZFxuICBpZiAocm93SW5kZXggPT0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoKSB7XG4gICAgdmFyIHNlY29uZERpbWVuc2lvbiA9IFtdO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd3MucHVzaChzZWNvbmREaW1lbnNpb24pO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aC5wdXNoKG1pbkNvbXBvdW5kU2l6ZSk7XG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodC5wdXNoKDApO1xuICB9XG5cbiAgLy8gVXBkYXRlIHJvdyB3aWR0aFxuICB2YXIgdyA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gKyBub2RlLnJlY3Qud2lkdGg7XG5cbiAgaWYgKG9yZ2FuaXphdGlvbi5yb3dzW3Jvd0luZGV4XS5sZW5ndGggPiAwKSB7XG4gICAgdyArPSBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG4gIH1cblxuICBvcmdhbml6YXRpb24ucm93V2lkdGhbcm93SW5kZXhdID0gdztcbiAgLy8gVXBkYXRlIGNvbXBvdW5kIHdpZHRoXG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggPCB3KSB7XG4gICAgb3JnYW5pemF0aW9uLndpZHRoID0gdztcbiAgfVxuXG4gIC8vIFVwZGF0ZSBoZWlnaHRcbiAgdmFyIGggPSBub2RlLnJlY3QuaGVpZ2h0O1xuICBpZiAocm93SW5kZXggPiAwKSBoICs9IG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgdmFyIGV4dHJhSGVpZ2h0ID0gMDtcbiAgaWYgKGggPiBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSkge1xuICAgIGV4dHJhSGVpZ2h0ID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF07XG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF0gPSBoO1xuICAgIGV4dHJhSGVpZ2h0ID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF0gLSBleHRyYUhlaWdodDtcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5oZWlnaHQgKz0gZXh0cmFIZWlnaHQ7XG5cbiAgLy8gSW5zZXJ0IG5vZGVcbiAgb3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLnB1c2gobm9kZSk7XG59O1xuXG4vL1NjYW5zIHRoZSByb3dzIG9mIGFuIG9yZ2FuaXphdGlvbiBhbmQgcmV0dXJucyB0aGUgb25lIHdpdGggdGhlIG1pbiB3aWR0aFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0U2hvcnRlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvcmdhbml6YXRpb24ucm93V2lkdGhbaV0gPCBtaW4pIHtcbiAgICAgIHIgPSBpO1xuICAgICAgbWluID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWF4IHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRMb25nZXN0Um93SW5kZXggPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIHZhciByID0gLTE7XG4gIHZhciBtYXggPSBOdW1iZXIuTUlOX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoOyBpKyspIHtcblxuICAgIGlmIChvcmdhbml6YXRpb24ucm93V2lkdGhbaV0gPiBtYXgpIHtcbiAgICAgIHIgPSBpO1xuICAgICAgbWF4ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGFkZGluZyBleHRyYSB3aWR0aCB0byB0aGUgb3JnYW5pemF0aW9uIHZpb2xhdGVzXG4qIHRoZSBhc3BlY3QgcmF0aW8oMSkgb3Igbm90LlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbkFkZEhvcml6b250YWwgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCBleHRyYVdpZHRoLCBleHRyYUhlaWdodCkge1xuXG4gIC8vIGlmIHRoZXJlIGlzIGFuIGlkZWFsIHJvdyB3aWR0aCBzcGVjaWZpZWQgdXNlIGl0IGluc3RlYWQgb2YgY2hlY2tpbmcgdGhlIGFzcGVjdCByYXRpb1xuICBpZiAob3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGgpIHtcbiAgICB2YXIgbGFzdFJvd0luZGV4ID0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoIC0gMTtcbiAgICB2YXIgbGFzdFJvd1dpZHRoID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RSb3dJbmRleF07XG5cbiAgICAvLyBjaGVjayBhbmQgcmV0dXJuIGlmIGlkZWFsIHJvdyB3aWR0aCB3aWxsIGJlIGV4Y2VlZCBpZiB0aGUgbm9kZSBpcyBhZGRlZCB0byB0aGUgcm93XG4gICAgcmV0dXJuIGxhc3RSb3dXaWR0aCArIGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcgPD0gb3JnYW5pemF0aW9uLmlkZWFsUm93V2lkdGg7XG4gIH1cblxuICB2YXIgc3JpID0gdGhpcy5nZXRTaG9ydGVzdFJvd0luZGV4KG9yZ2FuaXphdGlvbik7XG5cbiAgaWYgKHNyaSA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbc3JpXTtcblxuICBpZiAobWluICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nICsgZXh0cmFXaWR0aCA8PSBvcmdhbml6YXRpb24ud2lkdGgpIHJldHVybiB0cnVlO1xuXG4gIHZhciBoRGlmZiA9IDA7XG5cbiAgLy8gQWRkaW5nIHRvIGFuIGV4aXN0aW5nIHJvd1xuICBpZiAob3JnYW5pemF0aW9uLnJvd0hlaWdodFtzcmldIDwgZXh0cmFIZWlnaHQpIHtcbiAgICBpZiAoc3JpID4gMCkgaERpZmYgPSBleHRyYUhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmcgLSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3NyaV07XG4gIH1cblxuICB2YXIgYWRkX3RvX3Jvd19yYXRpbztcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCAtIG1pbiA+PSBleHRyYVdpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nKSB7XG4gICAgYWRkX3RvX3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gKG1pbiArIGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcpO1xuICB9IGVsc2Uge1xuICAgIGFkZF90b19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIG9yZ2FuaXphdGlvbi53aWR0aDtcbiAgfVxuXG4gIC8vIEFkZGluZyBhIG5ldyByb3cgZm9yIHRoaXMgbm9kZVxuICBoRGlmZiA9IGV4dHJhSGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcbiAgdmFyIGFkZF9uZXdfcm93X3JhdGlvO1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIDwgZXh0cmFXaWR0aCkge1xuICAgIGFkZF9uZXdfcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBleHRyYVdpZHRoO1xuICB9IGVsc2Uge1xuICAgIGFkZF9uZXdfcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBvcmdhbml6YXRpb24ud2lkdGg7XG4gIH1cblxuICBpZiAoYWRkX25ld19yb3dfcmF0aW8gPCAxKSBhZGRfbmV3X3Jvd19yYXRpbyA9IDEgLyBhZGRfbmV3X3Jvd19yYXRpbztcblxuICBpZiAoYWRkX3RvX3Jvd19yYXRpbyA8IDEpIGFkZF90b19yb3dfcmF0aW8gPSAxIC8gYWRkX3RvX3Jvd19yYXRpbztcblxuICByZXR1cm4gYWRkX3RvX3Jvd19yYXRpbyA8IGFkZF9uZXdfcm93X3JhdGlvO1xufTtcblxuLy9JZiBtb3ZpbmcgdGhlIGxhc3Qgbm9kZSBmcm9tIHRoZSBsb25nZXN0IHJvdyBhbmQgYWRkaW5nIGl0IHRvIHRoZSBsYXN0XG4vL3JvdyBtYWtlcyB0aGUgYm91bmRpbmcgYm94IHNtYWxsZXIsIGRvIGl0LlxuQ29TRUxheW91dC5wcm90b3R5cGUuc2hpZnRUb0xhc3RSb3cgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIHZhciBsb25nZXN0ID0gdGhpcy5nZXRMb25nZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcbiAgdmFyIGxhc3QgPSBvcmdhbml6YXRpb24ucm93V2lkdGgubGVuZ3RoIC0gMTtcbiAgdmFyIHJvdyA9IG9yZ2FuaXphdGlvbi5yb3dzW2xvbmdlc3RdO1xuICB2YXIgbm9kZSA9IHJvd1tyb3cubGVuZ3RoIC0gMV07XG5cbiAgdmFyIGRpZmYgPSBub2RlLndpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nO1xuXG4gIC8vIENoZWNrIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBvbiB0aGUgbGFzdCByb3dcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCAtIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSA+IGRpZmYgJiYgbG9uZ2VzdCAhPSBsYXN0KSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvbmdlc3Qgcm93XG4gICAgcm93LnNwbGljZSgtMSwgMSk7XG5cbiAgICAvLyBQdXNoIGl0IHRvIHRoZSBsYXN0IHJvd1xuICAgIG9yZ2FuaXphdGlvbi5yb3dzW2xhc3RdLnB1c2gobm9kZSk7XG5cbiAgICBvcmdhbml6YXRpb24ucm93V2lkdGhbbG9uZ2VzdF0gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbG9uZ2VzdF0gLSBkaWZmO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSArIGRpZmY7XG4gICAgb3JnYW5pemF0aW9uLndpZHRoID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2luc3RhbmNlLmdldExvbmdlc3RSb3dJbmRleChvcmdhbml6YXRpb24pXTtcblxuICAgIC8vIFVwZGF0ZSBoZWlnaHRzIG9mIHRoZSBvcmdhbml6YXRpb25cbiAgICB2YXIgbWF4SGVpZ2h0ID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJvd1tpXS5oZWlnaHQgPiBtYXhIZWlnaHQpIG1heEhlaWdodCA9IHJvd1tpXS5oZWlnaHQ7XG4gICAgfVxuICAgIGlmIChsb25nZXN0ID4gMCkgbWF4SGVpZ2h0ICs9IG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgICB2YXIgcHJldlRvdGFsID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSArIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF07XG5cbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdID0gbWF4SGVpZ2h0O1xuICAgIGlmIChvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdIDwgbm9kZS5oZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nKSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdID0gbm9kZS5oZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuXG4gICAgdmFyIGZpbmFsVG90YWwgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdICsgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XTtcbiAgICBvcmdhbml6YXRpb24uaGVpZ2h0ICs9IGZpbmFsVG90YWwgLSBwcmV2VG90YWw7XG5cbiAgICB0aGlzLnNoaWZ0VG9MYXN0Um93KG9yZ2FuaXphdGlvbik7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGluZ1ByZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKENvU0VDb25zdGFudHMuVElMRSkge1xuICAgIC8vIEZpbmQgemVybyBkZWdyZWUgbm9kZXMgYW5kIGNyZWF0ZSBhIGNvbXBvdW5kIGZvciBlYWNoIGxldmVsXG4gICAgdGhpcy5ncm91cFplcm9EZWdyZWVNZW1iZXJzKCk7XG4gICAgLy8gVGlsZSBhbmQgY2xlYXIgY2hpbGRyZW4gb2YgZWFjaCBjb21wb3VuZFxuICAgIHRoaXMuY2xlYXJDb21wb3VuZHMoKTtcbiAgICAvLyBTZXBhcmF0ZWx5IHRpbGUgYW5kIGNsZWFyIHplcm8gZGVncmVlIG5vZGVzIGZvciBlYWNoIGxldmVsXG4gICAgdGhpcy5jbGVhclplcm9EZWdyZWVNZW1iZXJzKCk7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGluZ1Bvc3RMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChDb1NFQ29uc3RhbnRzLlRJTEUpIHtcbiAgICB0aGlzLnJlcG9wdWxhdGVaZXJvRGVncmVlTWVtYmVycygpO1xuICAgIHRoaXMucmVwb3B1bGF0ZUNvbXBvdW5kcygpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogVHJlZSBSZWR1Y3Rpb24gbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlZHVjZSB0cmVlcyBcbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlZHVjZVRyZWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHJ1bmVkTm9kZXNBbGwgPSBbXTtcbiAgdmFyIGNvbnRhaW5zTGVhZiA9IHRydWU7XG4gIHZhciBub2RlO1xuXG4gIHdoaWxlIChjb250YWluc0xlYWYpIHtcbiAgICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcFRlbXAgPSBbXTtcbiAgICBjb250YWluc0xlYWYgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldEVkZ2VzKCkubGVuZ3RoID09IDEgJiYgIW5vZGUuZ2V0RWRnZXMoKVswXS5pc0ludGVyR3JhcGggJiYgbm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgICAgaWYgKENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCkge1xuICAgICAgICAgIHZhciBvdGhlckVuZCA9IG5vZGUuZ2V0RWRnZXMoKVswXS5nZXRPdGhlckVuZChub2RlKTtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IG5ldyBEaW1lbnNpb25EKG5vZGUuZ2V0Q2VudGVyWCgpIC0gb3RoZXJFbmQuZ2V0Q2VudGVyWCgpLCBub2RlLmdldENlbnRlclkoKSAtIG90aGVyRW5kLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLnB1c2goW25vZGUsIG5vZGUuZ2V0RWRnZXMoKVswXSwgbm9kZS5nZXRPd25lcigpLCByZWxhdGl2ZVBvc2l0aW9uXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLnB1c2goW25vZGUsIG5vZGUuZ2V0RWRnZXMoKVswXSwgbm9kZS5nZXRPd25lcigpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbnNMZWFmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zTGVhZiA9PSB0cnVlKSB7XG4gICAgICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXAgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0uZ2V0RWRnZXMoKS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwLnB1c2gocHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdKTtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0uZ2V0T3duZXIoKS5yZW1vdmUocHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJ1bmVkTm9kZXNBbGwucHVzaChwcnVuZWROb2Rlc0luU3RlcCk7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbEVkZ2VzKCk7XG4gICAgfVxuICB9XG4gIHRoaXMucHJ1bmVkTm9kZXNBbGwgPSBwcnVuZWROb2Rlc0FsbDtcbn07XG5cbi8vIEdyb3cgdHJlZSBvbmUgc3RlcCBcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdyb3dUcmVlID0gZnVuY3Rpb24gKHBydW5lZE5vZGVzQWxsKSB7XG4gIHZhciBsZW5ndGhPZlBydW5lZE5vZGVzSW5TdGVwID0gcHJ1bmVkTm9kZXNBbGwubGVuZ3RoO1xuICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbFtsZW5ndGhPZlBydW5lZE5vZGVzSW5TdGVwIC0gMV07XG5cbiAgdmFyIG5vZGVEYXRhO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBydW5lZE5vZGVzSW5TdGVwLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZURhdGEgPSBwcnVuZWROb2Rlc0luU3RlcFtpXTtcblxuICAgIHRoaXMuZmluZFBsYWNlZm9yUHJ1bmVkTm9kZShub2RlRGF0YSk7XG5cbiAgICBub2RlRGF0YVsyXS5hZGQobm9kZURhdGFbMF0pO1xuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVsxXSwgbm9kZURhdGFbMV0uc291cmNlLCBub2RlRGF0YVsxXS50YXJnZXQpO1xuICB9XG5cbiAgcHJ1bmVkTm9kZXNBbGwuc3BsaWNlKHBydW5lZE5vZGVzQWxsLmxlbmd0aCAtIDEsIDEpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbn07XG5cbi8vIEZpbmQgYW4gYXBwcm9wcmlhdGUgcG9zaXRpb24gdG8gcmVwbGFjZSBwcnVuZWQgbm9kZSwgdGhpcyBtZXRob2QgY2FuIGJlIGltcHJvdmVkXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maW5kUGxhY2Vmb3JQcnVuZWROb2RlID0gZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG5cbiAgdmFyIGdyaWRGb3JQcnVuZWROb2RlO1xuICB2YXIgbm9kZVRvQ29ubmVjdDtcbiAgdmFyIHBydW5lZE5vZGUgPSBub2RlRGF0YVswXTtcbiAgaWYgKHBydW5lZE5vZGUgPT0gbm9kZURhdGFbMV0uc291cmNlKSB7XG4gICAgbm9kZVRvQ29ubmVjdCA9IG5vZGVEYXRhWzFdLnRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0uc291cmNlO1xuICB9XG5cbiAgaWYgKENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCkge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpICsgbm9kZURhdGFbM10uZ2V0V2lkdGgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgKyBub2RlRGF0YVszXS5nZXRIZWlnaHQoKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0YXJ0R3JpZFggPSBub2RlVG9Db25uZWN0LnN0YXJ0WDtcbiAgICB2YXIgZmluaXNoR3JpZFggPSBub2RlVG9Db25uZWN0LmZpbmlzaFg7XG4gICAgdmFyIHN0YXJ0R3JpZFkgPSBub2RlVG9Db25uZWN0LnN0YXJ0WTtcbiAgICB2YXIgZmluaXNoR3JpZFkgPSBub2RlVG9Db25uZWN0LmZpbmlzaFk7XG5cbiAgICB2YXIgdXBOb2RlQ291bnQgPSAwO1xuICAgIHZhciBkb3duTm9kZUNvdW50ID0gMDtcbiAgICB2YXIgcmlnaHROb2RlQ291bnQgPSAwO1xuICAgIHZhciBsZWZ0Tm9kZUNvdW50ID0gMDtcbiAgICB2YXIgY29udHJvbFJlZ2lvbnMgPSBbdXBOb2RlQ291bnQsIHJpZ2h0Tm9kZUNvdW50LCBkb3duTm9kZUNvdW50LCBsZWZ0Tm9kZUNvdW50XTtcblxuICAgIGlmIChzdGFydEdyaWRZID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFg7IGkgPD0gZmluaXNoR3JpZFg7IGkrKykge1xuICAgICAgICBjb250cm9sUmVnaW9uc1swXSArPSB0aGlzLmdyaWRbaV1bc3RhcnRHcmlkWSAtIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZXS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmluaXNoR3JpZFggPCB0aGlzLmdyaWQubGVuZ3RoIC0gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFk7IGkgPD0gZmluaXNoR3JpZFk7IGkrKykge1xuICAgICAgICBjb250cm9sUmVnaW9uc1sxXSArPSB0aGlzLmdyaWRbZmluaXNoR3JpZFggKyAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbZmluaXNoR3JpZFhdW2ldLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaW5pc2hHcmlkWSA8IHRoaXMuZ3JpZFswXS5sZW5ndGggLSAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWDsgaSA8PSBmaW5pc2hHcmlkWDsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzJdICs9IHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWSArIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWV0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0R3JpZFggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWTsgaSA8PSBmaW5pc2hHcmlkWTsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzNdICs9IHRoaXMuZ3JpZFtzdGFydEdyaWRYIC0gMV1baV0ubGVuZ3RoICsgdGhpcy5ncmlkW3N0YXJ0R3JpZFhdW2ldLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtaW4gPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWluQ291bnQ7XG4gICAgdmFyIG1pbkluZGV4O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29udHJvbFJlZ2lvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChjb250cm9sUmVnaW9uc1tqXSA8IG1pbikge1xuICAgICAgICBtaW4gPSBjb250cm9sUmVnaW9uc1tqXTtcbiAgICAgICAgbWluQ291bnQgPSAxO1xuICAgICAgICBtaW5JbmRleCA9IGo7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zW2pdID09IG1pbikge1xuICAgICAgICBtaW5Db3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW5Db3VudCA9PSAzICYmIG1pbiA9PSAwKSB7XG4gICAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWluQ291bnQgPT0gMiAmJiBtaW4gPT0gMCkge1xuICAgICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIpO1xuICAgICAgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCkge1xuICAgICAgICA7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1pbkNvdW50ID09IDQgJiYgbWluID09IDApIHtcbiAgICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KTtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gcmFuZG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IG1pbkluZGV4O1xuICAgIH1cblxuICAgIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAwKSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgLSBub2RlVG9Db25uZWN0LmdldEhlaWdodCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldEhlaWdodCgpIC8gMik7XG4gICAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAxKSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSArIG5vZGVUb0Nvbm5lY3QuZ2V0V2lkdGgoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRXaWR0aCgpIC8gMiwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkpO1xuICAgIH0gZWxzZSBpZiAoZ3JpZEZvclBydW5lZE5vZGUgPT0gMikge1xuICAgICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCksIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpICsgbm9kZVRvQ29ubmVjdC5nZXRIZWlnaHQoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRIZWlnaHQoKSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0V2lkdGgoKSAvIDIgLSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC0gcHJ1bmVkTm9kZS5nZXRXaWR0aCgpIC8gMiwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFTGF5b3V0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dE5vZGU7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuSU1hdGg7XG5cbmZ1bmN0aW9uIENvU0VOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIEZETGF5b3V0Tm9kZS5jYWxsKHRoaXMsIGdtLCBsb2MsIHNpemUsIHZOb2RlKTtcbn1cblxuQ29TRU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGRExheW91dE5vZGUucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXROb2RlKSB7XG4gIENvU0VOb2RlW3Byb3BdID0gRkRMYXlvdXROb2RlW3Byb3BdO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUuY2FsY3VsYXRlRGlzcGxhY2VtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGF5b3V0ID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0TGF5b3V0KCk7XG4gIC8vIHRoaXMgY2hlY2sgaXMgZm9yIGNvbXBvdW5kIG5vZGVzIHRoYXQgY29udGFpbiBmaXhlZCBub2Rlc1xuICBpZiAodGhpcy5nZXRDaGlsZCgpICE9IG51bGwgJiYgdGhpcy5maXhlZE5vZGVXZWlnaHQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFggKz0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVggKyB0aGlzLnJlcHVsc2lvbkZvcmNlWCArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVgpIC8gdGhpcy5maXhlZE5vZGVXZWlnaHQ7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRZICs9IGxheW91dC5jb29saW5nRmFjdG9yICogKHRoaXMuc3ByaW5nRm9yY2VZICsgdGhpcy5yZXB1bHNpb25Gb3JjZVkgKyB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZKSAvIHRoaXMuZml4ZWROb2RlV2VpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCArPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWCArIHRoaXMucmVwdWxzaW9uRm9yY2VYICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgKz0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVkgKyB0aGlzLnJlcHVsc2lvbkZvcmNlWSArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkpIC8gdGhpcy5ub09mQ2hpbGRyZW47XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRYKSA+IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFggPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50ICogSU1hdGguc2lnbih0aGlzLmRpc3BsYWNlbWVudFgpO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WSkgPiBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRZID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCAqIElNYXRoLnNpZ24odGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuXG4gIC8vIG5vbi1lbXB0eSBjb21wb3VuZCBub2RlLCBwcm9wb2dhdGUgbW92ZW1lbnQgdG8gY2hpbGRyZW4gYXMgd2VsbFxuICBpZiAodGhpcy5jaGlsZCAmJiB0aGlzLmNoaWxkLmdldE5vZGVzKCkubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbih0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuID0gZnVuY3Rpb24gKGRYLCBkWSkge1xuICB2YXIgbm9kZXMgPSB0aGlzLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgdmFyIG5vZGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRpc3BsYWNlbWVudFggKz0gZFg7XG4gICAgICBub2RlLmRpc3BsYWNlbWVudFkgKz0gZFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbihkWCwgZFkpO1xuICAgIH1cbiAgfVxufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcblxuICAvLyBhIHNpbXBsZSBub2RlIG9yIGFuIGVtcHR5IGNvbXBvdW5kIG5vZGUsIG1vdmUgaXRcbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCB8fCB0aGlzLmNoaWxkLmdldE5vZGVzKCkubGVuZ3RoID09IDApIHtcbiAgICB0aGlzLm1vdmVCeSh0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG5cbiAgICBsYXlvdXQudG90YWxEaXNwbGFjZW1lbnQgKz0gTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRYKSArIE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cblxuICB0aGlzLnNwcmluZ0ZvcmNlWCA9IDA7XG4gIHRoaXMuc3ByaW5nRm9yY2VZID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVggPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWSA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVggPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5zZXRQcmVkMSA9IGZ1bmN0aW9uIChwcmVkMSkge1xuICB0aGlzLnByZWQxID0gcHJlZDE7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0UHJlZDEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQyO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLm5leHQgPSBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByb2Nlc3NlZCA9IGZ1bmN0aW9uIChwcm9jZXNzZWQpIHtcbiAgdGhpcy5wcm9jZXNzZWQgPSBwcm9jZXNzZWQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuaXNQcm9jZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcm9jZXNzZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VOb2RlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTAyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBDb1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDYpO1xudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGlua2VkTGlzdDtcbnZhciBNYXRyaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTWF0cml4O1xudmFyIFNWRCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5TVkQ7XG5cbmZ1bmN0aW9uIENvbnN0cmFpbnRIYW5kbGVyKCkge31cblxuQ29uc3RyYWludEhhbmRsZXIuaGFuZGxlQ29uc3RyYWludHMgPSBmdW5jdGlvbiAobGF5b3V0KSB7XG4gIC8vICBsZXQgbGF5b3V0ID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0TGF5b3V0KCk7XG5cbiAgLy8gZ2V0IGNvbnN0cmFpbnRzIGZyb20gbGF5b3V0XG4gIHZhciBjb25zdHJhaW50cyA9IHt9O1xuICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50ID0gbGF5b3V0LmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQ7XG4gIGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQgPSBsYXlvdXQuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludDtcbiAgY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50ID0gbGF5b3V0LmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDtcblxuICB2YXIgaWRUb05vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBub2RlSW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgdmFyIHhDb29yZHMgPSBbXTtcbiAgdmFyIHlDb29yZHMgPSBbXTtcblxuICB2YXIgYWxsTm9kZXMgPSBsYXlvdXQuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgLy8gZmlsbCBpbmRleCBtYXAgYW5kIGNvb3JkaW5hdGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgbm9kZUluZGV4ZXMuc2V0KG5vZGUuaWQsIGluZGV4KyspO1xuICAgICAgeENvb3Jkcy5wdXNoKG5vZGUuZ2V0Q2VudGVyWCgpKTtcbiAgICAgIHlDb29yZHMucHVzaChub2RlLmdldENlbnRlclkoKSk7XG4gICAgICBpZFRvTm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgZXhpc3RzIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50IHdpdGhvdXQgZ2FwIHZhbHVlLCBzZXQgaXQgdG8gZGVmYXVsdCBcbiAgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICBpZiAoIWNvbnN0cmFpbnQuZ2FwICYmIGNvbnN0cmFpbnQuZ2FwICE9IDApIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICAgIGNvbnN0cmFpbnQuZ2FwID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgaWRUb05vZGVNYXAuZ2V0KGNvbnN0cmFpbnQubGVmdCkuZ2V0V2lkdGgoKSAvIDIgKyBpZFRvTm9kZU1hcC5nZXQoY29uc3RyYWludC5yaWdodCkuZ2V0V2lkdGgoKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3RyYWludC5nYXAgPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBpZFRvTm9kZU1hcC5nZXQoY29uc3RyYWludC50b3ApLmdldEhlaWdodCgpIC8gMiArIGlkVG9Ob2RlTWFwLmdldChjb25zdHJhaW50LmJvdHRvbSkuZ2V0SGVpZ2h0KCkgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiBhdXhpbGlhcnkgZnVuY3Rpb25zICovXG5cbiAgLy8gY2FsY3VsYXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gcG9zaXRpb24gb2JqZWN0c1xuICB2YXIgY2FsY3VsYXRlUG9zaXRpb25EaWZmID0gZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25EaWZmKHBvczEsIHBvczIpIHtcbiAgICByZXR1cm4geyB4OiBwb3MxLnggLSBwb3MyLngsIHk6IHBvczEueSAtIHBvczIueSB9O1xuICB9O1xuXG4gIC8vIGNhbGN1bGF0ZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBub2Rlc1xuICB2YXIgY2FsY3VsYXRlQXZnUG9zaXRpb24gPSBmdW5jdGlvbiBjYWxjdWxhdGVBdmdQb3NpdGlvbihub2RlSWRTZXQpIHtcbiAgICB2YXIgeFBvc1N1bSA9IDA7XG4gICAgdmFyIHlQb3NTdW0gPSAwO1xuICAgIG5vZGVJZFNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgIHhQb3NTdW0gKz0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV07XG4gICAgICB5UG9zU3VtICs9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgeDogeFBvc1N1bSAvIG5vZGVJZFNldC5zaXplLCB5OiB5UG9zU3VtIC8gbm9kZUlkU2V0LnNpemUgfTtcbiAgfTtcblxuICAvLyBmaW5kIGFuIGFwcHJvcHJpYXRlIHBvc2l0aW9uaW5nIGZvciB0aGUgbm9kZXMgaW4gYSBnaXZlbiBncmFwaCBhY2NvcmRpbmcgdG8gcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRzXG4gIC8vIHRoaXMgZnVuY3Rpb24gYWxzbyB0YWtlcyB0aGUgZml4ZWQgbm9kZXMgYW5kIGFsaWdubWVudCBjb25zdHJhaW50cyBpbnRvIGFjY291bnRcbiAgLy8gZ3JhcGg6IGRhZyB0byBiZSBldmFsdWF0ZWQsIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLCBcbiAgLy8gZml4ZWROb2Rlczogc2V0IG9mIGZpeGVkIG5vZGVzIHRvIGNvbnNpZGVyIGR1cmluZyBldmFsdWF0aW9uLCBkdW1teVBvc2l0aW9uczogYXBwcm9wcmlhdGUgY29vcmRpbmF0ZXMgb2YgdGhlIGR1bW15IG5vZGVzICBcbiAgdmFyIGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQgPSBmdW5jdGlvbiBmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGdyYXBoLCBkaXJlY3Rpb24sIGZpeGVkTm9kZXMsIGR1bW15UG9zaXRpb25zLCBjb21wb25lbnRTb3VyY2VzKSB7XG5cbiAgICAvLyBmaW5kIHVuaW9uIG9mIHR3byBzZXRzXG4gICAgZnVuY3Rpb24gc2V0VW5pb24oc2V0QSwgc2V0Qikge1xuICAgICAgdmFyIHVuaW9uID0gbmV3IFNldChzZXRBKTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBzZXRCW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBlbGVtID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB1bmlvbi5hZGQoZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5pb247XG4gICAgfVxuXG4gICAgLy8gZmluZCBpbmRlZ3JlZSBjb3VudCBmb3IgZWFjaCBub2RlXG4gICAgdmFyIGluRGVncmVlcyA9IG5ldyBNYXAoKTtcblxuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGluRGVncmVlcy5zZXQoa2V5LCAwKTtcbiAgICB9KTtcbiAgICBncmFwaC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICBpbkRlZ3JlZXMuc2V0KGFkamFjZW50LmlkLCBpbkRlZ3JlZXMuZ2V0KGFkamFjZW50LmlkKSArIDEpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgcG9zaXRpb25NYXAgPSBuZXcgTWFwKCk7IC8vIGtlZXBzIHRoZSBwb3NpdGlvbiBmb3IgZWFjaCBub2RlXG4gICAgdmFyIHBhc3RNYXAgPSBuZXcgTWFwKCk7IC8vIGtlZXBzIHRoZSBwcmVkZWNlc3NvcnMocGFzdCkgb2YgYSBub2RlXG4gICAgdmFyIHF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICBpbkRlZ3JlZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlID09IDApIHtcbiAgICAgICAgcXVldWUucHVzaChrZXkpO1xuICAgICAgICBpZiAoIWZpeGVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoa2V5LCBub2RlSW5kZXhlcy5oYXMoa2V5KSA/IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGtleSldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KGtleSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoa2V5LCBub2RlSW5kZXhlcy5oYXMoa2V5KSA/IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGtleSldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zaXRpb25NYXAuc2V0KGtleSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICAgIHBhc3RNYXAuc2V0KGtleSwgbmV3IFNldChba2V5XSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYWxpZ24gc291cmNlcyBvZiBlYWNoIGNvbXBvbmVudCBpbiBlbmZvcmNlbWVudCBwaGFzZVxuICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICBjb21wb25lbnRTb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgZml4ZWRJZHMgPSBbXTtcbiAgICAgICAgY29tcG9uZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICBmaXhlZElkcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpeGVkSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgICAgICAgIGZpeGVkSWRzLmZvckVhY2goZnVuY3Rpb24gKGZpeGVkSWQpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGZpeGVkSWQsIG5vZGVJbmRleGVzLmhhcyhmaXhlZElkKSA/IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGZpeGVkSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChmaXhlZElkKSk7XG4gICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uTWFwLmdldChmaXhlZElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChmaXhlZElkLCBub2RlSW5kZXhlcy5oYXMoZml4ZWRJZCkgPyB5Q29vcmRzW25vZGVJbmRleGVzLmdldChmaXhlZElkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQoZml4ZWRJZCkpO1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSBwb3NpdGlvbk1hcC5nZXQoZml4ZWRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAvIGZpeGVkSWRzLmxlbmd0aDtcbiAgICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBpZiAoIWZpeGVkTm9kZXMuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KG5vZGVJZCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfcG9zaXRpb24gPSAwO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgX3Bvc2l0aW9uICs9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9wb3NpdGlvbiArPSBub2RlSW5kZXhlcy5oYXMobm9kZUlkKSA/IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gX3Bvc2l0aW9uIC8gY29tcG9uZW50Lmxlbmd0aDtcbiAgICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobm9kZUlkLCBfcG9zaXRpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb25zIG9mIHRoZSBub2Rlc1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGdyYXBoLmdldChjdXJyZW50Tm9kZSk7XG4gICAgICBuZWlnaGJvcnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uTWFwLmdldChuZWlnaGJvci5pZCkgPCBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwKSB7XG4gICAgICAgICAgaWYgKGZpeGVkTm9kZXMgJiYgZml4ZWROb2Rlcy5oYXMobmVpZ2hib3IuaWQpKSB7XG4gICAgICAgICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgZml4ZWRQb3NpdGlvbiA9IG5vZGVJbmRleGVzLmhhcyhuZWlnaGJvci5pZCkgPyB4Q29vcmRzW25vZGVJbmRleGVzLmdldChuZWlnaGJvci5pZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpeGVkUG9zaXRpb24gPSBub2RlSW5kZXhlcy5oYXMobmVpZ2hib3IuaWQpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobmVpZ2hib3IuaWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChuZWlnaGJvci5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobmVpZ2hib3IuaWQsIGZpeGVkUG9zaXRpb24pOyAvLyBUT0RPOiBtYXkgZG8gdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICAgICAgaWYgKGZpeGVkUG9zaXRpb24gPCBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwKSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gcG9zaXRpb25NYXAuZ2V0KGN1cnJlbnROb2RlKSArIG5laWdoYm9yLmdhcCAtIGZpeGVkUG9zaXRpb247XG4gICAgICAgICAgICAgIHBhc3RNYXAuZ2V0KGN1cnJlbnROb2RlKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobm9kZUlkLCBwb3NpdGlvbk1hcC5nZXQobm9kZUlkKSAtIGRpZmYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KG5laWdoYm9yLmlkLCBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5EZWdyZWVzLnNldChuZWlnaGJvci5pZCwgaW5EZWdyZWVzLmdldChuZWlnaGJvci5pZCkgLSAxKTtcbiAgICAgICAgaWYgKGluRGVncmVlcy5nZXQobmVpZ2hib3IuaWQpID09IDApIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKG5laWdoYm9yLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZml4ZWROb2Rlcykge1xuICAgICAgICAgIHBhc3RNYXAuc2V0KG5laWdoYm9yLmlkLCBzZXRVbmlvbihwYXN0TWFwLmdldChjdXJyZW50Tm9kZSksIHBhc3RNYXAuZ2V0KG5laWdoYm9yLmlkKSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cblxuICAgIC8vIHJlYWRqdXN0IHBvc2l0aW9uIG9mIHRoZSBub2RlcyBhZnRlciBlbmZvcmNlbWVudFxuICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICAvLyBmaW5kIGluZGVncmVlIGNvdW50IGZvciBlYWNoIG5vZGVcbiAgICAgIHZhciBzaW5rTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgc2lua05vZGVzLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9jb21wb25lbnRzID0gW107XG4gICAgICBwYXN0TWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHNpbmtOb2Rlcy5oYXMoa2V5KSkge1xuICAgICAgICAgIHZhciBpc0ZpeGVkQ29tcG9uZW50ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGVJZCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIGlzRml4ZWRDb21wb25lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNGaXhlZENvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGlzRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBleGlzdEF0ID0gdm9pZCAwO1xuICAgICAgICAgICAgX2NvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmhhcyhbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHZhbHVlKSlbMF0pKSB7XG4gICAgICAgICAgICAgICAgaXNFeGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhpc3RBdCA9IGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaXNFeGlzdCkge1xuICAgICAgICAgICAgICBfY29tcG9uZW50cy5wdXNoKG5ldyBTZXQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICAgIF9jb21wb25lbnRzW2V4aXN0QXRdLmFkZChlbGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBtaW5CZWZvcmUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHZhciBtaW5BZnRlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIG1heEJlZm9yZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIG1heEFmdGVyID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBjb21wb25lbnRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBwb3NCZWZvcmUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgIHBvc0JlZm9yZSA9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvc0JlZm9yZSA9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3NBZnRlciA9IHBvc2l0aW9uTWFwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKHBvc0JlZm9yZSA8IG1pbkJlZm9yZSkge1xuICAgICAgICAgICAgICBtaW5CZWZvcmUgPSBwb3NCZWZvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zQmVmb3JlID4gbWF4QmVmb3JlKSB7XG4gICAgICAgICAgICAgIG1heEJlZm9yZSA9IHBvc0JlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NBZnRlciA8IG1pbkFmdGVyKSB7XG4gICAgICAgICAgICAgIG1pbkFmdGVyID0gcG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zQWZ0ZXIgPiBtYXhBZnRlcikge1xuICAgICAgICAgICAgICBtYXhBZnRlciA9IHBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmYgPSAobWluQmVmb3JlICsgbWF4QmVmb3JlKSAvIDIgLSAobWluQWZ0ZXIgKyBtYXhBZnRlcikgLyAyO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBjb21wb25lbnRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfbm9kZUlkID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoX25vZGVJZCwgcG9zaXRpb25NYXAuZ2V0KF9ub2RlSWQpICsgZGlmZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbk1hcDtcbiAgfTtcblxuICAvLyBmaW5kIHRyYW5zZm9ybWF0aW9uIGJhc2VkIG9uIHJlbC4gcGxhY2VtZW50IGNvbnN0cmFpbnRzIGlmIHRoZXJlIGFyZSBib3RoIGFsaWdubWVudCBhbmQgcmVsLiBwbGFjZW1lbnQgY29uc3RyYWludHNcbiAgLy8gb3IgaWYgdGhlcmUgYXJlIG9ubHkgcmVsLiBwbGFjZW1lbnQgY29udHJhaW50cyB3aGVyZSB0aGUgbGFyZ2VzdCBjb21wb25lbnQgaXNuJ3Qgc3VmZmljaWVudGx5IGxhcmdlXG4gIHZhciBhcHBseVJlZmxlY3Rpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudCA9IGZ1bmN0aW9uIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludHMpIHtcbiAgICAvLyB2YXJpYWJsZXMgdG8gY291bnQgdm90ZXNcbiAgICB2YXIgcmVmbGVjdE9uWSA9IDAsXG4gICAgICAgIG5vdFJlZmxlY3RPblkgPSAwO1xuICAgIHZhciByZWZsZWN0T25YID0gMCxcbiAgICAgICAgbm90UmVmbGVjdE9uWCA9IDA7XG5cbiAgICByZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChjb25zdHJhaW50LmxlZnQpIHtcbiAgICAgICAgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoY29uc3RyYWludC5sZWZ0KV0gLSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChjb25zdHJhaW50LnJpZ2h0KV0gPj0gMCA/IHJlZmxlY3RPblkrKyA6IG5vdFJlZmxlY3RPblkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGNvbnN0cmFpbnQudG9wKV0gLSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChjb25zdHJhaW50LmJvdHRvbSldID49IDAgPyByZWZsZWN0T25YKysgOiBub3RSZWZsZWN0T25YKys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocmVmbGVjdE9uWSA+IG5vdFJlZmxlY3RPblkgJiYgcmVmbGVjdE9uWCA+IG5vdFJlZmxlY3RPblgpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlSW5kZXhlcy5zaXplOyBfaSsrKSB7XG4gICAgICAgIHhDb29yZHNbX2ldID0gLTEgKiB4Q29vcmRzW19pXTtcbiAgICAgICAgeUNvb3Jkc1tfaV0gPSAtMSAqIHlDb29yZHNbX2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmbGVjdE9uWSA+IG5vdFJlZmxlY3RPblkpIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVJbmRleGVzLnNpemU7IF9pMisrKSB7XG4gICAgICAgIHhDb29yZHNbX2kyXSA9IC0xICogeENvb3Jkc1tfaTJdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmbGVjdE9uWCA+IG5vdFJlZmxlY3RPblgpIHtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVJbmRleGVzLnNpemU7IF9pMysrKSB7XG4gICAgICAgIHlDb29yZHNbX2kzXSA9IC0xICogeUNvb3Jkc1tfaTNdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBmaW5kIHdlYWtseSBjb25uZWN0ZWQgY29tcG9uZW50cyBpbiB1bmRpcmVjdGVkIGdyYXBoXG4gIHZhciBmaW5kQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRDb21wb25lbnRzKGdyYXBoKSB7XG4gICAgLy8gZmluZCB3ZWFrbHkgY29ubmVjdGVkIGNvbXBvbmVudHMgaW4gZGFnXG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICBncmFwaC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGtleSkpIHtcbiAgICAgICAgY29tcG9uZW50c1tjb3VudF0gPSBbXTtcbiAgICAgICAgdmFyIF9jdXJyZW50Tm9kZSA9IGtleTtcbiAgICAgICAgcXVldWUucHVzaChfY3VycmVudE5vZGUpO1xuICAgICAgICB2aXNpdGVkLmFkZChfY3VycmVudE5vZGUpO1xuICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKF9jdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgX2N1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGguZ2V0KF9jdXJyZW50Tm9kZSk7XG4gICAgICAgICAgbmVpZ2hib3JzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm9yKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG5laWdoYm9yLmlkKSkge1xuICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgICAgdmlzaXRlZC5hZGQobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9O1xuXG4gIC8vIHJldHVybiB1bmRpcmVjdGVkIHZlcnNpb24gb2YgZ2l2ZW4gZGFnXG4gIHZhciBkYWdUb1VuZGlyZWN0ZWQgPSBmdW5jdGlvbiBkYWdUb1VuZGlyZWN0ZWQoZGFnKSB7XG4gICAgdmFyIHVuZGlyZWN0ZWQgPSBuZXcgTWFwKCk7XG5cbiAgICBkYWcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdW5kaXJlY3RlZC5zZXQoa2V5LCBbXSk7XG4gICAgfSk7XG5cbiAgICBkYWcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoYWRqYWNlbnQpIHtcbiAgICAgICAgdW5kaXJlY3RlZC5nZXQoa2V5KS5wdXNoKGFkamFjZW50KTtcbiAgICAgICAgdW5kaXJlY3RlZC5nZXQoYWRqYWNlbnQuaWQpLnB1c2goeyBpZDoga2V5LCBnYXA6IGFkamFjZW50LmdhcCwgZGlyZWN0aW9uOiBhZGphY2VudC5kaXJlY3Rpb24gfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB1bmRpcmVjdGVkO1xuICB9O1xuXG4gIC8vIHJldHVybiByZXZlcnNlZCAoZGlyZWN0aW9ucyBpbnZlcnRlZCkgdmVyc2lvbiBvZiBnaXZlbiBkYWdcbiAgdmFyIGRhZ1RvUmV2ZXJzZWQgPSBmdW5jdGlvbiBkYWdUb1JldmVyc2VkKGRhZykge1xuICAgIHZhciByZXZlcnNlZCA9IG5ldyBNYXAoKTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICByZXZlcnNlZC5zZXQoa2V5LCBbXSk7XG4gICAgfSk7XG5cbiAgICBkYWcuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoYWRqYWNlbnQpIHtcbiAgICAgICAgcmV2ZXJzZWQuZ2V0KGFkamFjZW50LmlkKS5wdXNoKHsgaWQ6IGtleSwgZ2FwOiBhZGphY2VudC5nYXAsIGRpcmVjdGlvbjogYWRqYWNlbnQuZGlyZWN0aW9uIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV2ZXJzZWQ7XG4gIH07XG5cbiAgLyoqKiogIGFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBpbml0aWFsIGRyYWZ0IGxheW91dCB0byBiZXR0ZXIgYWxpZ24gd2l0aCBjb25zdHJhaW5lZCBub2RlcyAqKioqL1xuICAvLyBzb2x2ZSB0aGUgT3J0aG9nb25hbCBQcm9jcnVzdGVhbiBQcm9ibGVtIHRvIHJvdGF0ZSBhbmQvb3IgcmVmbGVjdCBpbml0aWFsIGRyYWZ0IGxheW91dFxuICAvLyBoZXJlIHdlIGZvbGxvdyB0aGUgc29sdXRpb24gaW4gQ2hhcHRlciAyMC4yIG9mIEJvcmcsIEkuICYgR3JvZW5lbiwgUC4gKDIwMDUpIE1vZGVybiBNdWx0aWRpbWVuc2lvbmFsIFNjYWxpbmc6IFRoZW9yeSBhbmQgQXBwbGljYXRpb25zIFxuXG4gIC8qIGNvbnN0cnVjdCBzb3VyY2UgYW5kIHRhcmdldCBjb25maWd1cmF0aW9ucyAqL1xuXG4gIHZhciB0YXJnZXRNYXRyaXggPSBbXTsgLy8gQSAtIHRhcmdldCBjb25maWd1cmF0aW9uXG4gIHZhciBzb3VyY2VNYXRyaXggPSBbXTsgLy8gQiAtIHNvdXJjZSBjb25maWd1cmF0aW9uIFxuICB2YXIgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlOyAvLyBmYWxzZSBmb3Igbm8gdHJhbnNmb3JtYXRpb24sIHRydWUgZm9yIHN0YW5kYXJ0IChQcm9jcnVzdGVzKSB0cmFuc2Zvcm1hdGlvbiAocm90YXRpb24gYW5kL29yIHJlZmxlY3Rpb24pXG4gIHZhciByZWZsZWN0aW9uVHlwZSA9IGZhbHNlOyAvLyBmYWxzZS90cnVlIGZvciByZWZsZWN0aW9uIGNoZWNrLCAncmVmbGVjdE9uWCcsICdyZWZsZWN0T25ZJyBvciAncmVmbGVjdE9uQm90aCcgZm9yIHJlZmxlY3Rpb24gdHlwZSBpZiBuZWNlc3NhcnlcbiAgdmFyIGZpeGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIHZhciBkYWcgPSBuZXcgTWFwKCk7IC8vIGFkamFjZW5jeSBsaXN0IHRvIGtlZXAgZGlyZWN0ZWQgYWN5Y2xpYyBncmFwaCAoZGFnKSB0aGF0IGNvbnNpc3RzIG9mIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50c1xuICB2YXIgZGFnVW5kaXJlY3RlZCA9IG5ldyBNYXAoKTsgLy8gdW5kaXJlY3RlZCB2ZXJzaW9uIG9mIHRoZSBkYWdcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTsgLy8gd2Vha2x5IGNvbm5lY3RlZCBjb21wb25lbnRzXG5cbiAgLy8gZmlsbCBmaXhlZE5vZGVzIGNvbGxlY3Rpb24gdG8gdXNlIGxhdGVyXG4gIGlmIChjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgZml4ZWROb2Rlcy5hZGQobm9kZURhdGEubm9kZUlkKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvbnN0cnVjdCBkYWcgZnJvbSByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHMgXG4gIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAvLyBjb25zdHJ1Y3QgYm90aCBkaXJlY3RlZCBhbmQgdW5kaXJlY3RlZCB2ZXJzaW9uIG9mIHRoZSBkYWdcbiAgICBjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICBpZiAoZGFnLmhhcyhjb25zdHJhaW50LmxlZnQpKSB7XG4gICAgICAgICAgZGFnLmdldChjb25zdHJhaW50LmxlZnQpLnB1c2goeyBpZDogY29uc3RyYWludC5yaWdodCwgZ2FwOiBjb25zdHJhaW50LmdhcCwgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYWcuc2V0KGNvbnN0cmFpbnQubGVmdCwgW3sgaWQ6IGNvbnN0cmFpbnQucmlnaHQsIGdhcDogY29uc3RyYWludC5nYXAsIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGFnLmhhcyhjb25zdHJhaW50LnJpZ2h0KSkge1xuICAgICAgICAgIGRhZy5zZXQoY29uc3RyYWludC5yaWdodCwgW10pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGFnLmhhcyhjb25zdHJhaW50LnRvcCkpIHtcbiAgICAgICAgICBkYWcuZ2V0KGNvbnN0cmFpbnQudG9wKS5wdXNoKHsgaWQ6IGNvbnN0cmFpbnQuYm90dG9tLCBnYXA6IGNvbnN0cmFpbnQuZ2FwLCBkaXJlY3Rpb246IFwidmVydGljYWxcIiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYWcuc2V0KGNvbnN0cmFpbnQudG9wLCBbeyBpZDogY29uc3RyYWludC5ib3R0b20sIGdhcDogY29uc3RyYWludC5nYXAsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiIH1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhZy5oYXMoY29uc3RyYWludC5ib3R0b20pKSB7XG4gICAgICAgICAgZGFnLnNldChjb25zdHJhaW50LmJvdHRvbSwgW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkYWdVbmRpcmVjdGVkID0gZGFnVG9VbmRpcmVjdGVkKGRhZyk7XG4gICAgY29tcG9uZW50cyA9IGZpbmRDb21wb25lbnRzKGRhZ1VuZGlyZWN0ZWQpO1xuICB9XG5cbiAgaWYgKENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcpIHtcbiAgICAvLyBmaXJzdCBjaGVjayBmaXhlZCBub2RlIGNvbnN0cmFpbnRcbiAgICBpZiAoY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludCAmJiBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEsIGkpIHtcbiAgICAgICAgdGFyZ2V0TWF0cml4W2ldID0gW25vZGVEYXRhLnBvc2l0aW9uLngsIG5vZGVEYXRhLnBvc2l0aW9uLnldO1xuICAgICAgICBzb3VyY2VNYXRyaXhbaV0gPSBbeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldXTtcbiAgICAgIH0pO1xuICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGVuIGNoZWNrIGFsaWdubWVudCBjb25zdHJhaW50XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB7XG4gICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsO1xuXG4gICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihfaTQpIHtcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduW19pNF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIGFsaWdubWVudFNldC5hZGQobm9kZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhbGlnbm1lbnRTZXQpKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpeGVkTm9kZXMuaGFzKHgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIHhQb3MgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnNpemUgPiAwKSB4UG9zID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaW50ZXJzZWN0aW9uLnZhbHVlcygpLm5leHQoKS52YWx1ZSldO2Vsc2UgeFBvcyA9IGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKGFsaWdubWVudFNldCkueDtcblxuICAgICAgICAgICAgdmVydGljYWxBbGlnbltfaTRdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICB0YXJnZXRNYXRyaXhbY291bnRdID0gW3hQb3MsIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldXTtcbiAgICAgICAgICAgICAgc291cmNlTWF0cml4W2NvdW50XSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV1dO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHZlcnRpY2FsQWxpZ24ubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgX2xvb3AyKF9pNCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YW5kYXJkVHJhbnNmb3JtYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsO1xuXG4gICAgICAgICAgdmFyIF9sb29wMyA9IGZ1bmN0aW9uIF9sb29wMyhfaTUpIHtcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ25bX2k1XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgeVBvcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHlQb3MgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB5UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS55O1xuXG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ25bX2k1XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2NvdW50XSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSwgeVBvc107XG4gICAgICAgICAgICAgIHNvdXJjZU1hdHJpeFtjb3VudF0gPSBbeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldXTtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBob3Jpem9udGFsQWxpZ24ubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICAgICAgX2xvb3AzKF9pNSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YW5kYXJkVHJhbnNmb3JtYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgICByZWZsZWN0aW9uVHlwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgIC8vIGZpbmFsbHkgY2hlY2sgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRcbiAgICAgIC8vIGZpbmQgbGFyZ2VzdCBjb21wb25lbnQgaW4gZGFnXG4gICAgICB2YXIgbGFyZ2VzdENvbXBvbmVudFNpemUgPSAwO1xuICAgICAgdmFyIGxhcmdlc3RDb21wb25lbnRJbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBjb21wb25lbnRzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbX2k2XS5sZW5ndGggPiBsYXJnZXN0Q29tcG9uZW50U2l6ZSkge1xuICAgICAgICAgIGxhcmdlc3RDb21wb25lbnRTaXplID0gY29tcG9uZW50c1tfaTZdLmxlbmd0aDtcbiAgICAgICAgICBsYXJnZXN0Q29tcG9uZW50SW5kZXggPSBfaTY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIGxhcmdlc3QgY29tcG9uZW50IGlzbid0IGRvbWluYW50LCB0aGVuIHRha2UgdGhlIHZvdGVzIGZvciByZWZsZWN0aW9uXG4gICAgICBpZiAobGFyZ2VzdENvbXBvbmVudFNpemUgPCBkYWdVbmRpcmVjdGVkLnNpemUgLyAyKSB7XG4gICAgICAgIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCk7XG4gICAgICAgIHN0YW5kYXJkVHJhbnNmb3JtYXRpb24gPSBmYWxzZTtcbiAgICAgICAgcmVmbGVjdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXJnZXN0IGNvbXBvbmVudCBmb3IgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgLy8gY29uc3RydWN0IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHN1YmdyYXBocyBpbiB0aGUgbGFyZ2VzdCBjb21wb25lbnRcbiAgICAgICAgdmFyIHN1YkdyYXBoT25Ib3Jpem9udGFsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgc3ViR3JhcGhPblZlcnRpY2FsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQgPSBbXTtcblxuICAgICAgICBjb21wb25lbnRzW2xhcmdlc3RDb21wb25lbnRJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgZGFnLmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKGFkamFjZW50KSB7XG4gICAgICAgICAgICBpZiAoYWRqYWNlbnQuZGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLmdldChub2RlSWQpLnB1c2goYWRqYWNlbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLnNldChub2RlSWQsIFthZGphY2VudF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc3ViR3JhcGhPbkhvcml6b250YWwuaGFzKGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLnNldChhZGphY2VudC5pZCwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzSW5sYXJnZXN0Q29tcG9uZW50LnB1c2goeyBsZWZ0OiBub2RlSWQsIHJpZ2h0OiBhZGphY2VudC5pZCB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzdWJHcmFwaE9uVmVydGljYWwuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuZ2V0KG5vZGVJZCkucHVzaChhZGphY2VudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPblZlcnRpY2FsLnNldChub2RlSWQsIFthZGphY2VudF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc3ViR3JhcGhPblZlcnRpY2FsLmhhcyhhZGphY2VudC5pZCkpIHtcbiAgICAgICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KGFkamFjZW50LmlkLCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQucHVzaCh7IHRvcDogbm9kZUlkLCBib3R0b206IGFkamFjZW50LmlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBhcHBseVJlZmxlY3Rpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChjb25zdHJhaW50c0lubGFyZ2VzdENvbXBvbmVudCk7XG4gICAgICAgIHJlZmxlY3Rpb25UeXBlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGFwcHJvcHJpYXRlIHBvc2l0aW9uaW5nIGZvciBzdWJncmFwaHNcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwSG9yaXpvbnRhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoc3ViR3JhcGhPbkhvcml6b250YWwsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwVmVydGljYWwgPSBmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KHN1YkdyYXBoT25WZXJ0aWNhbCwgXCJ2ZXJ0aWNhbFwiKTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3Qgc291cmNlIGFuZCB0YXJnZXQgY29uZmlndXJhdGlvblxuICAgICAgICBjb21wb25lbnRzW2xhcmdlc3RDb21wb25lbnRJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkLCBpKSB7XG4gICAgICAgICAgc291cmNlTWF0cml4W2ldID0gW3hDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXV07XG4gICAgICAgICAgdGFyZ2V0TWF0cml4W2ldID0gW107XG4gICAgICAgICAgaWYgKHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2ldWzBdID0gcG9zaXRpb25NYXBIb3Jpem9udGFsLmdldChub2RlSWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRNYXRyaXhbaV1bMF0gPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvc2l0aW9uTWFwVmVydGljYWwuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeFtpXVsxXSA9IHBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeFtpXVsxXSA9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdHJhbnNmb3JtYXRpb24gaXMgcmVxdWlyZWQsIHRoZW4gY2FsY3VsYXRlIGFuZCBhcHBseSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICBpZiAoc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgLyogY2FsY3VsYXRlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCAqL1xuICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRhcmdldE1hdHJpeFRyYW5zcG9zZSA9IE1hdHJpeC50cmFuc3Bvc2UodGFyZ2V0TWF0cml4KTsgLy8gQSdcbiAgICAgIHZhciBzb3VyY2VNYXRyaXhUcmFuc3Bvc2UgPSBNYXRyaXgudHJhbnNwb3NlKHNvdXJjZU1hdHJpeCk7IC8vIEInXG5cbiAgICAgIC8vIGNlbnRyYWxpemUgdHJhbnNwb3NlIG1hdHJpY2VzXG4gICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCB0YXJnZXRNYXRyaXhUcmFuc3Bvc2UubGVuZ3RoOyBfaTcrKykge1xuICAgICAgICB0YXJnZXRNYXRyaXhUcmFuc3Bvc2VbX2k3XSA9IE1hdHJpeC5tdWx0R2FtbWEodGFyZ2V0TWF0cml4VHJhbnNwb3NlW19pN10pO1xuICAgICAgICBzb3VyY2VNYXRyaXhUcmFuc3Bvc2VbX2k3XSA9IE1hdHJpeC5tdWx0R2FtbWEoc291cmNlTWF0cml4VHJhbnNwb3NlW19pN10pO1xuICAgICAgfVxuXG4gICAgICAvLyBkbyBhY3R1YWwgY2FsY3VsYXRpb24gZm9yIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAgdmFyIHRlbXBNYXRyaXggPSBNYXRyaXgubXVsdE1hdCh0YXJnZXRNYXRyaXhUcmFuc3Bvc2UsIE1hdHJpeC50cmFuc3Bvc2Uoc291cmNlTWF0cml4VHJhbnNwb3NlKSk7IC8vIHRlbXBNYXRyaXggPSBBJ0JcbiAgICAgIHZhciBTVkRSZXN1bHQgPSBTVkQuc3ZkKHRlbXBNYXRyaXgpOyAvLyBTVkQoQSdCKSA9IFVTVicsIHN2ZCBmdW5jdGlvbiByZXR1cm5zIFUsIFMgYW5kIFYgXG4gICAgICB0cmFuc2Zvcm1hdGlvbk1hdHJpeCA9IE1hdHJpeC5tdWx0TWF0KFNWRFJlc3VsdC5WLCBNYXRyaXgudHJhbnNwb3NlKFNWRFJlc3VsdC5VKSk7IC8vIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gVCA9IFZVJ1xuXG4gICAgICAvKiBhcHBseSBmb3VuZCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gb2J0YWluIGZpbmFsIGRyYWZ0IGxheW91dCAqL1xuICAgICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2k4KyspIHtcbiAgICAgICAgdmFyIHRlbXAxID0gW3hDb29yZHNbX2k4XSwgeUNvb3Jkc1tfaThdXTtcbiAgICAgICAgdmFyIHRlbXAyID0gW3RyYW5zZm9ybWF0aW9uTWF0cml4WzBdWzBdLCB0cmFuc2Zvcm1hdGlvbk1hdHJpeFsxXVswXV07XG4gICAgICAgIHZhciB0ZW1wMyA9IFt0cmFuc2Zvcm1hdGlvbk1hdHJpeFswXVsxXSwgdHJhbnNmb3JtYXRpb25NYXRyaXhbMV1bMV1dO1xuICAgICAgICB4Q29vcmRzW19pOF0gPSBNYXRyaXguZG90UHJvZHVjdCh0ZW1wMSwgdGVtcDIpO1xuICAgICAgICB5Q29vcmRzW19pOF0gPSBNYXRyaXguZG90UHJvZHVjdCh0ZW1wMSwgdGVtcDMpO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBsaWVkIG9ubHkgYm90aCBhbGlnbm1lbnQgYW5kIHJlbC4gcGxhY2VtZW50IGNvbnN0cmFpbnRzIGV4aXN0XG4gICAgICBpZiAocmVmbGVjdGlvblR5cGUpIHtcbiAgICAgICAgYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTKSB7XG4gICAgLyoqKiogIGVuZm9yY2UgY29uc3RyYWludHMgb24gdGhlIHRyYW5zZm9ybWVkIGRyYWZ0IGxheW91dCAqKioqL1xuXG4gICAgLyogZmlyc3QgZW5mb3JjZSBmaXhlZCBub2RlIGNvbnN0cmFpbnQgKi9cblxuICAgIGlmIChjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50ICYmIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHRyYW5zbGF0aW9uQW1vdW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVEYXRhLCBpKSB7XG4gICAgICAgIHZhciBwb3NJblRoZW9yeSA9IHsgeDogeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0sIHk6IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldIH07XG4gICAgICAgIHZhciBwb3NEZXNpcmVkID0gbm9kZURhdGEucG9zaXRpb247XG4gICAgICAgIHZhciBwb3NEaWZmID0gY2FsY3VsYXRlUG9zaXRpb25EaWZmKHBvc0Rlc2lyZWQsIHBvc0luVGhlb3J5KTtcbiAgICAgICAgdHJhbnNsYXRpb25BbW91bnQueCArPSBwb3NEaWZmLng7XG4gICAgICAgIHRyYW5zbGF0aW9uQW1vdW50LnkgKz0gcG9zRGlmZi55O1xuICAgICAgfSk7XG4gICAgICB0cmFuc2xhdGlvbkFtb3VudC54IC89IGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoO1xuICAgICAgdHJhbnNsYXRpb25BbW91bnQueSAvPSBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aDtcblxuICAgICAgeENvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICB4Q29vcmRzW2ldICs9IHRyYW5zbGF0aW9uQW1vdW50Lng7XG4gICAgICB9KTtcblxuICAgICAgeUNvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICB5Q29vcmRzW2ldICs9IHRyYW5zbGF0aW9uQW1vdW50Lnk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlRGF0YS5ub2RlSWQpXSA9IG5vZGVEYXRhLnBvc2l0aW9uLng7XG4gICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldID0gbm9kZURhdGEucG9zaXRpb24ueTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIHRoZW4gZW5mb3JjZSBhbGlnbm1lbnQgY29uc3RyYWludCAqL1xuXG4gICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB7XG4gICAgICAgIHZhciB4QWxpZ24gPSBjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsO1xuXG4gICAgICAgIHZhciBfbG9vcDQgPSBmdW5jdGlvbiBfbG9vcDQoX2k5KSB7XG4gICAgICAgICAgdmFyIGFsaWdubWVudFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB4QWxpZ25bX2k5XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudFNldC5hZGQobm9kZUlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpeGVkTm9kZXMuaGFzKHgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB2YXIgeFBvcyA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnNpemUgPiAwKSB4UG9zID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaW50ZXJzZWN0aW9uLnZhbHVlcygpLm5leHQoKS52YWx1ZSldO2Vsc2UgeFBvcyA9IGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKGFsaWdubWVudFNldCkueDtcblxuICAgICAgICAgIGFsaWdubWVudFNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSB4UG9zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IHhBbGlnbi5sZW5ndGg7IF9pOSsrKSB7XG4gICAgICAgICAgX2xvb3A0KF9pOSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgdmFyIHlBbGlnbiA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcblxuICAgICAgICB2YXIgX2xvb3A1ID0gZnVuY3Rpb24gX2xvb3A1KF9pMTApIHtcbiAgICAgICAgICB2YXIgYWxpZ25tZW50U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIHlBbGlnbltfaTEwXS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudFNldC5hZGQobm9kZUlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpeGVkTm9kZXMuaGFzKHgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB2YXIgeVBvcyA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnNpemUgPiAwKSB5UG9zID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaW50ZXJzZWN0aW9uLnZhbHVlcygpLm5leHQoKS52YWx1ZSldO2Vsc2UgeVBvcyA9IGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKGFsaWdubWVudFNldCkueTtcblxuICAgICAgICAgIGFsaWdubWVudFNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSB5UG9zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgeUFsaWduLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgICAgX2xvb3A1KF9pMTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogZmluYWxseSBlbmZvcmNlIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50ICovXG5cbiAgICBpZiAoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkdW1teVBvc2l0aW9uc0ZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZml4ZWROb2Rlc09uSG9yaXpvbnRhbCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIGZpeGVkTm9kZXNPblZlcnRpY2FsID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIGZpbGwgbWFwcyBhbmQgc2V0cyAgICAgIFxuICAgICAgICBmaXhlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIGZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKG5vZGVJZCk7XG4gICAgICAgICAgZml4ZWROb2Rlc09uVmVydGljYWwuYWRkKG5vZGVJZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEFsaWdubWVudCA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG5cbiAgICAgICAgICAgIHZhciBfbG9vcDYgPSBmdW5jdGlvbiBfbG9vcDYoX2kxMSkge1xuICAgICAgICAgICAgICBkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTExLCBbXSk7XG4gICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25tZW50W19pMTFdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KG5vZGVJZCwgXCJkdW1teVwiICsgX2kxMSk7XG4gICAgICAgICAgICAgICAgZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoXCJkdW1teVwiICsgX2kxMSkucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgICBmaXhlZE5vZGVzT25Ib3Jpem9udGFsLmFkZChcImR1bW15XCIgKyBfaTExKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBkdW1teVBvc2l0aW9uc0ZvclZlcnRpY2FsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTExLCB4Q29vcmRzW25vZGVJbmRleGVzLmdldCh2ZXJ0aWNhbEFsaWdubWVudFtfaTExXVswXSldKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgdmVydGljYWxBbGlnbm1lbnQubGVuZ3RoOyBfaTExKyspIHtcbiAgICAgICAgICAgICAgX2xvb3A2KF9pMTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbEFsaWdubWVudCA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcblxuICAgICAgICAgICAgdmFyIF9sb29wNyA9IGZ1bmN0aW9uIF9sb29wNyhfaTEyKSB7XG4gICAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQoXCJkdW1teVwiICsgX2kxMiwgW10pO1xuICAgICAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50W19pMTJdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQobm9kZUlkLCBcImR1bW15XCIgKyBfaTEyKTtcbiAgICAgICAgICAgICAgICBkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KFwiZHVtbXlcIiArIF9pMTIpLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgICAgZml4ZWROb2Rlc09uVmVydGljYWwuYWRkKFwiZHVtbXlcIiArIF9pMTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGR1bW15UG9zaXRpb25zRm9ySG9yaXpvbnRhbEFsaWdubWVudC5zZXQoXCJkdW1teVwiICsgX2kxMiwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoaG9yaXpvbnRhbEFsaWdubWVudFtfaTEyXVswXSldKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgaG9yaXpvbnRhbEFsaWdubWVudC5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgICAgICAgICBfbG9vcDcoX2kxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3RydWN0IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRhZ3MgKHN1YmdyYXBocykgZnJvbSBvdmVyYWxsIGRhZ1xuICAgICAgICB2YXIgZGFnT25Ib3Jpem9udGFsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZGFnT25WZXJ0aWNhbCA9IG5ldyBNYXAoKTtcblxuICAgICAgICB2YXIgX2xvb3A4ID0gZnVuY3Rpb24gX2xvb3A4KG5vZGVJZCkge1xuICAgICAgICAgIGRhZy5nZXQobm9kZUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoYWRqYWNlbnRbXCJkaXJlY3Rpb25cIl0gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgc291cmNlSWQgPSBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpID8gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQobm9kZUlkKSA6IG5vZGVJZDtcbiAgICAgICAgICAgICAgaWYgKG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSB7IGlkOiBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChhZGphY2VudC5pZCksIGdhcDogYWRqYWNlbnQuZ2FwLCBkaXJlY3Rpb246IGFkamFjZW50LmRpcmVjdGlvbiB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBhZGphY2VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGFnT25Ib3Jpem9udGFsLmhhcyhzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBkYWdPbkhvcml6b250YWwuZ2V0KHNvdXJjZUlkKS5wdXNoKHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhZ09uSG9yaXpvbnRhbC5zZXQoc291cmNlSWQsIFt0YXJnZXROb2RlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYWdPbkhvcml6b250YWwuaGFzKHRhcmdldE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgZGFnT25Ib3Jpem9udGFsLnNldCh0YXJnZXROb2RlLmlkLCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdXJjZUlkID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpIDogbm9kZUlkO1xuICAgICAgICAgICAgICBpZiAobm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChhZGphY2VudC5pZCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0geyBpZDogbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChhZGphY2VudC5pZCksIGdhcDogYWRqYWNlbnQuZ2FwLCBkaXJlY3Rpb246IGFkamFjZW50LmRpcmVjdGlvbiB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBhZGphY2VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGFnT25WZXJ0aWNhbC5oYXMoc291cmNlSWQpKSB7XG4gICAgICAgICAgICAgICAgZGFnT25WZXJ0aWNhbC5nZXQoc291cmNlSWQpLnB1c2godGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGFnT25WZXJ0aWNhbC5zZXQoc291cmNlSWQsIFt0YXJnZXROb2RlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYWdPblZlcnRpY2FsLmhhcyh0YXJnZXROb2RlLmlkKSkge1xuICAgICAgICAgICAgICAgIGRhZ09uVmVydGljYWwuc2V0KHRhcmdldE5vZGUuaWQsIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBkYWcua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUlkID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgICBfbG9vcDgobm9kZUlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmaW5kIHNvdXJjZSBub2RlcyBvZiBlYWNoIGNvbXBvbmVudCBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkYWdzXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmRpcmVjdGVkT25Ib3Jpem9udGFsID0gZGFnVG9VbmRpcmVjdGVkKGRhZ09uSG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciB1bmRpcmVjdGVkT25WZXJ0aWNhbCA9IGRhZ1RvVW5kaXJlY3RlZChkYWdPblZlcnRpY2FsKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHNPbkhvcml6b250YWwgPSBmaW5kQ29tcG9uZW50cyh1bmRpcmVjdGVkT25Ib3Jpem9udGFsKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHNPblZlcnRpY2FsID0gZmluZENvbXBvbmVudHModW5kaXJlY3RlZE9uVmVydGljYWwpO1xuICAgICAgICB2YXIgcmV2ZXJzZWREYWdPbkhvcml6b250YWwgPSBkYWdUb1JldmVyc2VkKGRhZ09uSG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciByZXZlcnNlZERhZ09uVmVydGljYWwgPSBkYWdUb1JldmVyc2VkKGRhZ09uVmVydGljYWwpO1xuICAgICAgICB2YXIgY29tcG9uZW50U291cmNlc09uSG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICB2YXIgY29tcG9uZW50U291cmNlc09uVmVydGljYWwgPSBbXTtcblxuICAgICAgICBjb21wb25lbnRzT25Ib3Jpem9udGFsLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICBjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsW2luZGV4XSA9IFtdO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlZERhZ09uSG9yaXpvbnRhbC5nZXQobm9kZUlkKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICBjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsW2luZGV4XS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudHNPblZlcnRpY2FsLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICBjb21wb25lbnRTb3VyY2VzT25WZXJ0aWNhbFtpbmRleF0gPSBbXTtcbiAgICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZWREYWdPblZlcnRpY2FsLmdldChub2RlSWQpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsW2luZGV4XS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhcHByb3ByaWF0ZSBwb3NpdGlvbmluZyBmb3Igc3ViZ3JhcGhzXG4gICAgICAgIHZhciBwb3NpdGlvbk1hcEhvcml6b250YWwgPSBmaW5kQXBwcm9wcmlhdGVQb3NpdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGRhZ09uSG9yaXpvbnRhbCwgXCJob3Jpem9udGFsXCIsIGZpeGVkTm9kZXNPbkhvcml6b250YWwsIGR1bW15UG9zaXRpb25zRm9yVmVydGljYWxBbGlnbm1lbnQsIGNvbXBvbmVudFNvdXJjZXNPbkhvcml6b250YWwpO1xuICAgICAgICB2YXIgcG9zaXRpb25NYXBWZXJ0aWNhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoZGFnT25WZXJ0aWNhbCwgXCJ2ZXJ0aWNhbFwiLCBmaXhlZE5vZGVzT25WZXJ0aWNhbCwgZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50LCBjb21wb25lbnRTb3VyY2VzT25WZXJ0aWNhbCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgYmFzZWQgb24gcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRzXG5cbiAgICAgICAgdmFyIF9sb29wOSA9IGZ1bmN0aW9uIF9sb29wOShrZXkpIHtcbiAgICAgICAgICBpZiAoZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoa2V5KSkge1xuICAgICAgICAgICAgZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSBwb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoa2V5KV0gPSBwb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjYgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSBwb3NpdGlvbk1hcEhvcml6b250YWwua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA2OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gKF9zdGVwNiA9IF9pdGVyYXRvcjYubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgICBfbG9vcDkoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I2ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ICYmIF9pdGVyYXRvcjYucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbG9vcDEwID0gZnVuY3Rpb24gX2xvb3AxMChrZXkpIHtcbiAgICAgICAgICBpZiAoZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChrZXkpKSB7XG4gICAgICAgICAgICBkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGtleSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldID0gcG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5Q29vcmRzW25vZGVJbmRleGVzLmdldChrZXkpXSA9IHBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjcgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBwb3NpdGlvbk1hcFZlcnRpY2FsLmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IChfc3RlcDcgPSBfaXRlcmF0b3I3Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9zdGVwNy52YWx1ZTtcblxuICAgICAgICAgICAgX2xvb3AxMChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjcgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc2lnbiBuZXcgY29vcmRpbmF0ZXMgdG8gbm9kZXMgYWZ0ZXIgY29uc3RyYWludCBoYW5kbGluZ1xuICBmb3IgKHZhciBfaTEzID0gMDsgX2kxMyA8IGFsbE5vZGVzLmxlbmd0aDsgX2kxMysrKSB7XG4gICAgdmFyIF9ub2RlID0gYWxsTm9kZXNbX2kxM107XG4gICAgaWYgKF9ub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgX25vZGUuc2V0Q2VudGVyKHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KF9ub2RlLmlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KF9ub2RlLmlkKV0pO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50SGFuZGxlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU1MTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNTUxX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js\n");

/***/ }),

/***/ "./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js":
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_543__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_543__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_543__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_543__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_543__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_543__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_543__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_543__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_543__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_543__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_543__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_543__(__nested_webpack_require_543__.s = 28);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_4947__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_4947__(2);\nvar IGeometry = __nested_webpack_require_4947__(8);\nvar IMath = __nested_webpack_require_4947__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_8167__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_8167__(2);\nvar Integer = __nested_webpack_require_8167__(10);\nvar RectangleD = __nested_webpack_require_8167__(13);\nvar LayoutConstants = __nested_webpack_require_8167__(0);\nvar RandomSeed = __nested_webpack_require_8167__(16);\nvar PointD = __nested_webpack_require_8167__(5);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth) {\n        if (this.labelPosHorizontal == \"left\") {\n          this.rect.x -= this.labelWidth;\n          this.setWidth(width + this.labelWidth);\n        } else if (this.labelPosHorizontal == \"center\" && this.labelWidth > width) {\n          this.rect.x -= (this.labelWidth - width) / 2;\n          this.setWidth(this.labelWidth);\n        } else if (this.labelPosHorizontal == \"right\") {\n          this.setWidth(width + this.labelWidth);\n        }\n      }\n\n      if (this.labelHeight) {\n        if (this.labelPosVertical == \"top\") {\n          this.rect.y -= this.labelHeight;\n          this.setHeight(height + this.labelHeight);\n        } else if (this.labelPosVertical == \"center\" && this.labelHeight > height) {\n          this.rect.y -= (this.labelHeight - height) / 2;\n          this.setHeight(this.labelHeight);\n        } else if (this.labelPosVertical == \"bottom\") {\n          this.setHeight(height + this.labelHeight);\n        }\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_17290__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __nested_webpack_require_17290__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_19670__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_19670__(2);\nvar Integer = __nested_webpack_require_19670__(10);\nvar LayoutConstants = __nested_webpack_require_19670__(0);\nvar LGraphManager = __nested_webpack_require_19670__(7);\nvar LNode = __nested_webpack_require_19670__(3);\nvar LEdge = __nested_webpack_require_19670__(1);\nvar RectangleD = __nested_webpack_require_19670__(13);\nvar Point = __nested_webpack_require_19670__(12);\nvar LinkedList = __nested_webpack_require_19670__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_29738__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __nested_webpack_require_29738__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __nested_webpack_require_29738__(6); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n  var edgesToRemove = [];\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      edgesToRemove.push(edge);\n    }\n  }\n\n  // Remove invalid edges from graph manager\n  for (var i = 0; i < edgesToRemove.length; i++) {\n    this.remove(edgesToRemove[i]);\n  }\n\n  // Invalid edges are cleared, so return false\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_41052__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __nested_webpack_require_41052__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n/**\n * This method checks and calculates the intersection of \n * a line segment and a circle.\n */\nIGeometry.findCircleLineIntersections = function (Ex, Ey, Lx, Ly, Cx, Cy, r) {\n\n  // E is the starting point of the ray,\n  // L is the end point of the ray,\n  // C is the center of sphere you're testing against\n  // r is the radius of that sphere\n\n  // Compute:\n  // d = L - E ( Direction vector of ray, from start to end )\n  // f = E - C ( Vector from center sphere to ray start )\n\n  // Then the intersection is found by..\n  // P = E + t * d\n  // This is a parametric equation:\n  // Px = Ex + tdx\n  // Py = Ey + tdy\n\n  // get a, b, c values\n  var a = (Lx - Ex) * (Lx - Ex) + (Ly - Ey) * (Ly - Ey);\n  var b = 2 * ((Ex - Cx) * (Lx - Ex) + (Ey - Cy) * (Ly - Ey));\n  var c = (Ex - Cx) * (Ex - Cx) + (Ey - Cy) * (Ey - Cy) - r * r;\n\n  // get discriminant\n  var disc = b * b - 4 * a * c;\n  if (disc >= 0) {\n    // insert into quadratic formula\n    var t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    var t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    var intersections = null;\n    if (t1 >= 0 && t1 <= 1) {\n      // t1 is the intersection, and it's closer than t2\n      // (since t1 uses -b - discriminant)\n      // Impale, Poke\n      return [t1];\n    }\n\n    // here t1 didn't intersect so we are either started\n    // inside the sphere or completely past it\n    if (t2 >= 0 && t2 <= 1) {\n      // ExitWound\n      return [t2];\n    }\n\n    return intersections;\n  } else return null;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_66321__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __nested_webpack_require_66321__(0);\nvar LGraphManager = __nested_webpack_require_66321__(7);\nvar LNode = __nested_webpack_require_66321__(3);\nvar LEdge = __nested_webpack_require_66321__(1);\nvar LGraph = __nested_webpack_require_66321__(6);\nvar PointD = __nested_webpack_require_66321__(5);\nvar Transform = __nested_webpack_require_66321__(17);\nvar Emitter = __nested_webpack_require_66321__(29);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __nested_webpack_require_84109__) {\n\n\"use strict\";\n\n\nvar PointD = __nested_webpack_require_84109__(5);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __nested_webpack_require_86996__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __nested_webpack_require_86996__(15);\nvar FDLayoutConstants = __nested_webpack_require_86996__(4);\nvar LayoutConstants = __nested_webpack_require_86996__(0);\nvar IGeometry = __nested_webpack_require_86996__(8);\nvar IMath = __nested_webpack_require_86996__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var originalIdealLength;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    originalIdealLength = edge.idealLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += originalIdealLength * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  // Reassign this attribute by using new constant value\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = edge.edgeElasticity * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      // Here we use half of the nodes' repulsion values for backward compatibility\n      repulsionForce = (nodeA.nodeRepulsion / 2 + nodeB.nodeRepulsion / 2) * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_103214__) {\n\n\"use strict\";\n\n\nvar LEdge = __nested_webpack_require_103214__(1);\nvar FDLayoutConstants = __nested_webpack_require_103214__(4);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n\n  // Ideal length and elasticity value for this edge\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.edgeElasticity = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_103820__) {\n\n\"use strict\";\n\n\nvar LNode = __nested_webpack_require_103820__(3);\nvar FDLayoutConstants = __nested_webpack_require_103820__(4);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n\n  // Repulsion value of this node\n  this.nodeRepulsion = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __nested_webpack_require_105759__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_105759__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __nested_webpack_require_106487__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_106487__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Some matrix (1d and 2d array) operations\nfunction Matrix() {}\n\n/**\n * matrix multiplication\n * array1, array2 and result are 2d arrays\n */\nMatrix.multMat = function (array1, array2) {\n  var result = [];\n\n  for (var i = 0; i < array1.length; i++) {\n    result[i] = [];\n    for (var j = 0; j < array2[0].length; j++) {\n      result[i][j] = 0;\n      for (var k = 0; k < array1[0].length; k++) {\n        result[i][j] += array1[i][k] * array2[k][j];\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * matrix transpose\n * array and result are 2d arrays\n */\nMatrix.transpose = function (array) {\n  var result = [];\n\n  for (var i = 0; i < array[0].length; i++) {\n    result[i] = [];\n    for (var j = 0; j < array.length; j++) {\n      result[i][j] = array[j][i];\n    }\n  }\n\n  return result;\n};\n\n/**\n * multiply array with constant\n * array and result are 1d arrays\n */\nMatrix.multCons = function (array, constant) {\n  var result = [];\n\n  for (var i = 0; i < array.length; i++) {\n    result[i] = array[i] * constant;\n  }\n\n  return result;\n};\n\n/**\n * substract two arrays\n * array1, array2 and result are 1d arrays\n */\nMatrix.minusOp = function (array1, array2) {\n  var result = [];\n\n  for (var i = 0; i < array1.length; i++) {\n    result[i] = array1[i] - array2[i];\n  }\n\n  return result;\n};\n\n/**\n * dot product of two arrays with same size\n * array1 and array2 are 1d arrays\n */\nMatrix.dotProduct = function (array1, array2) {\n  var product = 0;\n\n  for (var i = 0; i < array1.length; i++) {\n    product += array1[i] * array2[i];\n  }\n\n  return product;\n};\n\n/**\n * magnitude of an array\n * array is 1d array\n */\nMatrix.mag = function (array) {\n  return Math.sqrt(this.dotProduct(array, array));\n};\n\n/**\n * normalization of an array\n * array and result are 1d array\n */\nMatrix.normalize = function (array) {\n  var result = [];\n  var magnitude = this.mag(array);\n\n  for (var i = 0; i < array.length; i++) {\n    result[i] = array[i] / magnitude;\n  }\n\n  return result;\n};\n\n/**\n * multiply an array with centering matrix\n * array and result are 1d array\n */\nMatrix.multGamma = function (array) {\n  var result = [];\n  var sum = 0;\n\n  for (var i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n\n  sum *= -1 / array.length;\n\n  for (var _i = 0; _i < array.length; _i++) {\n    result[_i] = sum + array[_i];\n  }\n  return result;\n};\n\n/**\n * a special matrix multiplication\n * result = 0.5 * C * INV * C^T * array\n * array and result are 1d, C and INV are 2d arrays\n */\nMatrix.multL = function (array, C, INV) {\n  var result = [];\n  var temp1 = [];\n  var temp2 = [];\n\n  // multiply by C^T\n  for (var i = 0; i < C[0].length; i++) {\n    var sum = 0;\n    for (var j = 0; j < C.length; j++) {\n      sum += -0.5 * C[j][i] * array[j];\n    }\n    temp1[i] = sum;\n  }\n  // multiply the result by INV\n  for (var _i2 = 0; _i2 < INV.length; _i2++) {\n    var _sum = 0;\n    for (var _j = 0; _j < INV.length; _j++) {\n      _sum += INV[_i2][_j] * temp1[_j];\n    }\n    temp2[_i2] = _sum;\n  }\n  // multiply the result by C\n  for (var _i3 = 0; _i3 < C.length; _i3++) {\n    var _sum2 = 0;\n    for (var _j2 = 0; _j2 < C[0].length; _j2++) {\n      _sum2 += C[_i3][_j2] * temp2[_j2];\n    }\n    result[_i3] = _sum2;\n  }\n\n  return result;\n};\n\nmodule.exports = Matrix;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __nested_webpack_require_111039__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __nested_webpack_require_111039__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Singular Value Decomposition implementation\nfunction SVD() {};\n\n/* Below singular value decomposition (svd) code including hypot function is adopted from https://github.com/dragonfly-ai/JamaJS\n   Some changes are applied to make the code compatible with the fcose code and to make it independent from Jama.\n   Input matrix is changed to a 2D array instead of Jama matrix. Matrix dimensions are taken according to 2D array instead of using Jama functions.\n   An object that includes singular value components is created for return. \n   The types of input parameters of the hypot function are removed. \n   let is used instead of var for the variable initialization.\n*/\n/*\n                               Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nSVD.svd = function (A) {\n  this.U = null;\n  this.V = null;\n  this.s = null;\n  this.m = 0;\n  this.n = 0;\n  this.m = A.length;\n  this.n = A[0].length;\n  var nu = Math.min(this.m, this.n);\n  this.s = function (s) {\n    var a = [];\n    while (s-- > 0) {\n      a.push(0);\n    }return a;\n  }(Math.min(this.m + 1, this.n));\n  this.U = function (dims) {\n    var allocate = function allocate(dims) {\n      if (dims.length == 0) {\n        return 0;\n      } else {\n        var array = [];\n        for (var i = 0; i < dims[0]; i++) {\n          array.push(allocate(dims.slice(1)));\n        }\n        return array;\n      }\n    };\n    return allocate(dims);\n  }([this.m, nu]);\n  this.V = function (dims) {\n    var allocate = function allocate(dims) {\n      if (dims.length == 0) {\n        return 0;\n      } else {\n        var array = [];\n        for (var i = 0; i < dims[0]; i++) {\n          array.push(allocate(dims.slice(1)));\n        }\n        return array;\n      }\n    };\n    return allocate(dims);\n  }([this.n, this.n]);\n  var e = function (s) {\n    var a = [];\n    while (s-- > 0) {\n      a.push(0);\n    }return a;\n  }(this.n);\n  var work = function (s) {\n    var a = [];\n    while (s-- > 0) {\n      a.push(0);\n    }return a;\n  }(this.m);\n  var wantu = true;\n  var wantv = true;\n  var nct = Math.min(this.m - 1, this.n);\n  var nrt = Math.max(0, Math.min(this.n - 2, this.m));\n  for (var k = 0; k < Math.max(nct, nrt); k++) {\n    if (k < nct) {\n      this.s[k] = 0;\n      for (var i = k; i < this.m; i++) {\n        this.s[k] = SVD.hypot(this.s[k], A[i][k]);\n      }\n      ;\n      if (this.s[k] !== 0.0) {\n        if (A[k][k] < 0.0) {\n          this.s[k] = -this.s[k];\n        }\n        for (var _i = k; _i < this.m; _i++) {\n          A[_i][k] /= this.s[k];\n        }\n        ;\n        A[k][k] += 1.0;\n      }\n      this.s[k] = -this.s[k];\n    }\n    for (var j = k + 1; j < this.n; j++) {\n      if (function (lhs, rhs) {\n        return lhs && rhs;\n      }(k < nct, this.s[k] !== 0.0)) {\n        var t = 0;\n        for (var _i2 = k; _i2 < this.m; _i2++) {\n          t += A[_i2][k] * A[_i2][j];\n        }\n        ;\n        t = -t / A[k][k];\n        for (var _i3 = k; _i3 < this.m; _i3++) {\n          A[_i3][j] += t * A[_i3][k];\n        }\n        ;\n      }\n      e[j] = A[k][j];\n    }\n    ;\n    if (function (lhs, rhs) {\n      return lhs && rhs;\n    }(wantu, k < nct)) {\n      for (var _i4 = k; _i4 < this.m; _i4++) {\n        this.U[_i4][k] = A[_i4][k];\n      }\n      ;\n    }\n    if (k < nrt) {\n      e[k] = 0;\n      for (var _i5 = k + 1; _i5 < this.n; _i5++) {\n        e[k] = SVD.hypot(e[k], e[_i5]);\n      }\n      ;\n      if (e[k] !== 0.0) {\n        if (e[k + 1] < 0.0) {\n          e[k] = -e[k];\n        }\n        for (var _i6 = k + 1; _i6 < this.n; _i6++) {\n          e[_i6] /= e[k];\n        }\n        ;\n        e[k + 1] += 1.0;\n      }\n      e[k] = -e[k];\n      if (function (lhs, rhs) {\n        return lhs && rhs;\n      }(k + 1 < this.m, e[k] !== 0.0)) {\n        for (var _i7 = k + 1; _i7 < this.m; _i7++) {\n          work[_i7] = 0.0;\n        }\n        ;\n        for (var _j = k + 1; _j < this.n; _j++) {\n          for (var _i8 = k + 1; _i8 < this.m; _i8++) {\n            work[_i8] += e[_j] * A[_i8][_j];\n          }\n          ;\n        }\n        ;\n        for (var _j2 = k + 1; _j2 < this.n; _j2++) {\n          var _t = -e[_j2] / e[k + 1];\n          for (var _i9 = k + 1; _i9 < this.m; _i9++) {\n            A[_i9][_j2] += _t * work[_i9];\n          }\n          ;\n        }\n        ;\n      }\n      if (wantv) {\n        for (var _i10 = k + 1; _i10 < this.n; _i10++) {\n          this.V[_i10][k] = e[_i10];\n        };\n      }\n    }\n  };\n  var p = Math.min(this.n, this.m + 1);\n  if (nct < this.n) {\n    this.s[nct] = A[nct][nct];\n  }\n  if (this.m < p) {\n    this.s[p - 1] = 0.0;\n  }\n  if (nrt + 1 < p) {\n    e[nrt] = A[nrt][p - 1];\n  }\n  e[p - 1] = 0.0;\n  if (wantu) {\n    for (var _j3 = nct; _j3 < nu; _j3++) {\n      for (var _i11 = 0; _i11 < this.m; _i11++) {\n        this.U[_i11][_j3] = 0.0;\n      }\n      ;\n      this.U[_j3][_j3] = 1.0;\n    };\n    for (var _k = nct - 1; _k >= 0; _k--) {\n      if (this.s[_k] !== 0.0) {\n        for (var _j4 = _k + 1; _j4 < nu; _j4++) {\n          var _t2 = 0;\n          for (var _i12 = _k; _i12 < this.m; _i12++) {\n            _t2 += this.U[_i12][_k] * this.U[_i12][_j4];\n          };\n          _t2 = -_t2 / this.U[_k][_k];\n          for (var _i13 = _k; _i13 < this.m; _i13++) {\n            this.U[_i13][_j4] += _t2 * this.U[_i13][_k];\n          };\n        };\n        for (var _i14 = _k; _i14 < this.m; _i14++) {\n          this.U[_i14][_k] = -this.U[_i14][_k];\n        };\n        this.U[_k][_k] = 1.0 + this.U[_k][_k];\n        for (var _i15 = 0; _i15 < _k - 1; _i15++) {\n          this.U[_i15][_k] = 0.0;\n        };\n      } else {\n        for (var _i16 = 0; _i16 < this.m; _i16++) {\n          this.U[_i16][_k] = 0.0;\n        };\n        this.U[_k][_k] = 1.0;\n      }\n    };\n  }\n  if (wantv) {\n    for (var _k2 = this.n - 1; _k2 >= 0; _k2--) {\n      if (function (lhs, rhs) {\n        return lhs && rhs;\n      }(_k2 < nrt, e[_k2] !== 0.0)) {\n        for (var _j5 = _k2 + 1; _j5 < nu; _j5++) {\n          var _t3 = 0;\n          for (var _i17 = _k2 + 1; _i17 < this.n; _i17++) {\n            _t3 += this.V[_i17][_k2] * this.V[_i17][_j5];\n          };\n          _t3 = -_t3 / this.V[_k2 + 1][_k2];\n          for (var _i18 = _k2 + 1; _i18 < this.n; _i18++) {\n            this.V[_i18][_j5] += _t3 * this.V[_i18][_k2];\n          };\n        };\n      }\n      for (var _i19 = 0; _i19 < this.n; _i19++) {\n        this.V[_i19][_k2] = 0.0;\n      };\n      this.V[_k2][_k2] = 1.0;\n    };\n  }\n  var pp = p - 1;\n  var iter = 0;\n  var eps = Math.pow(2.0, -52.0);\n  var tiny = Math.pow(2.0, -966.0);\n  while (p > 0) {\n    var _k3 = void 0;\n    var kase = void 0;\n    for (_k3 = p - 2; _k3 >= -1; _k3--) {\n      if (_k3 === -1) {\n        break;\n      }\n      if (Math.abs(e[_k3]) <= tiny + eps * (Math.abs(this.s[_k3]) + Math.abs(this.s[_k3 + 1]))) {\n        e[_k3] = 0.0;\n        break;\n      }\n    };\n    if (_k3 === p - 2) {\n      kase = 4;\n    } else {\n      var ks = void 0;\n      for (ks = p - 1; ks >= _k3; ks--) {\n        if (ks === _k3) {\n          break;\n        }\n        var _t4 = (ks !== p ? Math.abs(e[ks]) : 0.0) + (ks !== _k3 + 1 ? Math.abs(e[ks - 1]) : 0.0);\n        if (Math.abs(this.s[ks]) <= tiny + eps * _t4) {\n          this.s[ks] = 0.0;\n          break;\n        }\n      };\n      if (ks === _k3) {\n        kase = 3;\n      } else if (ks === p - 1) {\n        kase = 1;\n      } else {\n        kase = 2;\n        _k3 = ks;\n      }\n    }\n    _k3++;\n    switch (kase) {\n      case 1:\n        {\n          var f = e[p - 2];\n          e[p - 2] = 0.0;\n          for (var _j6 = p - 2; _j6 >= _k3; _j6--) {\n            var _t5 = SVD.hypot(this.s[_j6], f);\n            var cs = this.s[_j6] / _t5;\n            var sn = f / _t5;\n            this.s[_j6] = _t5;\n            if (_j6 !== _k3) {\n              f = -sn * e[_j6 - 1];\n              e[_j6 - 1] = cs * e[_j6 - 1];\n            }\n            if (wantv) {\n              for (var _i20 = 0; _i20 < this.n; _i20++) {\n                _t5 = cs * this.V[_i20][_j6] + sn * this.V[_i20][p - 1];\n                this.V[_i20][p - 1] = -sn * this.V[_i20][_j6] + cs * this.V[_i20][p - 1];\n                this.V[_i20][_j6] = _t5;\n              };\n            }\n          };\n        };\n        break;\n      case 2:\n        {\n          var _f = e[_k3 - 1];\n          e[_k3 - 1] = 0.0;\n          for (var _j7 = _k3; _j7 < p; _j7++) {\n            var _t6 = SVD.hypot(this.s[_j7], _f);\n            var _cs = this.s[_j7] / _t6;\n            var _sn = _f / _t6;\n            this.s[_j7] = _t6;\n            _f = -_sn * e[_j7];\n            e[_j7] = _cs * e[_j7];\n            if (wantu) {\n              for (var _i21 = 0; _i21 < this.m; _i21++) {\n                _t6 = _cs * this.U[_i21][_j7] + _sn * this.U[_i21][_k3 - 1];\n                this.U[_i21][_k3 - 1] = -_sn * this.U[_i21][_j7] + _cs * this.U[_i21][_k3 - 1];\n                this.U[_i21][_j7] = _t6;\n              };\n            }\n          };\n        };\n        break;\n      case 3:\n        {\n          var scale = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[p - 1]), Math.abs(this.s[p - 2])), Math.abs(e[p - 2])), Math.abs(this.s[_k3])), Math.abs(e[_k3]));\n          var sp = this.s[p - 1] / scale;\n          var spm1 = this.s[p - 2] / scale;\n          var epm1 = e[p - 2] / scale;\n          var sk = this.s[_k3] / scale;\n          var ek = e[_k3] / scale;\n          var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n          var c = sp * epm1 * (sp * epm1);\n          var shift = 0.0;\n          if (function (lhs, rhs) {\n            return lhs || rhs;\n          }(b !== 0.0, c !== 0.0)) {\n            shift = Math.sqrt(b * b + c);\n            if (b < 0.0) {\n              shift = -shift;\n            }\n            shift = c / (b + shift);\n          }\n          var _f2 = (sk + sp) * (sk - sp) + shift;\n          var g = sk * ek;\n          for (var _j8 = _k3; _j8 < p - 1; _j8++) {\n            var _t7 = SVD.hypot(_f2, g);\n            var _cs2 = _f2 / _t7;\n            var _sn2 = g / _t7;\n            if (_j8 !== _k3) {\n              e[_j8 - 1] = _t7;\n            }\n            _f2 = _cs2 * this.s[_j8] + _sn2 * e[_j8];\n            e[_j8] = _cs2 * e[_j8] - _sn2 * this.s[_j8];\n            g = _sn2 * this.s[_j8 + 1];\n            this.s[_j8 + 1] = _cs2 * this.s[_j8 + 1];\n            if (wantv) {\n              for (var _i22 = 0; _i22 < this.n; _i22++) {\n                _t7 = _cs2 * this.V[_i22][_j8] + _sn2 * this.V[_i22][_j8 + 1];\n                this.V[_i22][_j8 + 1] = -_sn2 * this.V[_i22][_j8] + _cs2 * this.V[_i22][_j8 + 1];\n                this.V[_i22][_j8] = _t7;\n              };\n            }\n            _t7 = SVD.hypot(_f2, g);\n            _cs2 = _f2 / _t7;\n            _sn2 = g / _t7;\n            this.s[_j8] = _t7;\n            _f2 = _cs2 * e[_j8] + _sn2 * this.s[_j8 + 1];\n            this.s[_j8 + 1] = -_sn2 * e[_j8] + _cs2 * this.s[_j8 + 1];\n            g = _sn2 * e[_j8 + 1];\n            e[_j8 + 1] = _cs2 * e[_j8 + 1];\n            if (wantu && _j8 < this.m - 1) {\n              for (var _i23 = 0; _i23 < this.m; _i23++) {\n                _t7 = _cs2 * this.U[_i23][_j8] + _sn2 * this.U[_i23][_j8 + 1];\n                this.U[_i23][_j8 + 1] = -_sn2 * this.U[_i23][_j8] + _cs2 * this.U[_i23][_j8 + 1];\n                this.U[_i23][_j8] = _t7;\n              };\n            }\n          };\n          e[p - 2] = _f2;\n          iter = iter + 1;\n        };\n        break;\n      case 4:\n        {\n          if (this.s[_k3] <= 0.0) {\n            this.s[_k3] = this.s[_k3] < 0.0 ? -this.s[_k3] : 0.0;\n            if (wantv) {\n              for (var _i24 = 0; _i24 <= pp; _i24++) {\n                this.V[_i24][_k3] = -this.V[_i24][_k3];\n              };\n            }\n          }\n          while (_k3 < pp) {\n            if (this.s[_k3] >= this.s[_k3 + 1]) {\n              break;\n            }\n            var _t8 = this.s[_k3];\n            this.s[_k3] = this.s[_k3 + 1];\n            this.s[_k3 + 1] = _t8;\n            if (wantv && _k3 < this.n - 1) {\n              for (var _i25 = 0; _i25 < this.n; _i25++) {\n                _t8 = this.V[_i25][_k3 + 1];\n                this.V[_i25][_k3 + 1] = this.V[_i25][_k3];\n                this.V[_i25][_k3] = _t8;\n              };\n            }\n            if (wantu && _k3 < this.m - 1) {\n              for (var _i26 = 0; _i26 < this.m; _i26++) {\n                _t8 = this.U[_i26][_k3 + 1];\n                this.U[_i26][_k3 + 1] = this.U[_i26][_k3];\n                this.U[_i26][_k3] = _t8;\n              };\n            }\n            _k3++;\n          };\n          iter = 0;\n          p--;\n        };\n        break;\n    }\n  };\n  var result = { U: this.U, V: this.V, S: this.s };\n  return result;\n};\n\n// sqrt(a^2 + b^2) without under/overflow.\nSVD.hypot = function (a, b) {\n  var r = void 0;\n  if (Math.abs(a) > Math.abs(b)) {\n    r = b / a;\n    r = Math.abs(a) * Math.sqrt(1 + r * r);\n  } else if (b != 0) {\n    r = a / b;\n    r = Math.abs(b) * Math.sqrt(1 + r * r);\n  } else {\n    r = 0.0;\n  }\n  return r;\n};\n\nmodule.exports = SVD;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __nested_webpack_require_145732__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __nested_webpack_require_145732__(18);\nlayoutBase.FDLayoutConstants = __nested_webpack_require_145732__(4);\nlayoutBase.FDLayoutEdge = __nested_webpack_require_145732__(19);\nlayoutBase.FDLayoutNode = __nested_webpack_require_145732__(20);\nlayoutBase.DimensionD = __nested_webpack_require_145732__(21);\nlayoutBase.HashMap = __nested_webpack_require_145732__(22);\nlayoutBase.HashSet = __nested_webpack_require_145732__(23);\nlayoutBase.IGeometry = __nested_webpack_require_145732__(8);\nlayoutBase.IMath = __nested_webpack_require_145732__(9);\nlayoutBase.Integer = __nested_webpack_require_145732__(10);\nlayoutBase.Point = __nested_webpack_require_145732__(12);\nlayoutBase.PointD = __nested_webpack_require_145732__(5);\nlayoutBase.RandomSeed = __nested_webpack_require_145732__(16);\nlayoutBase.RectangleD = __nested_webpack_require_145732__(13);\nlayoutBase.Transform = __nested_webpack_require_145732__(17);\nlayoutBase.UniqueIDGeneretor = __nested_webpack_require_145732__(14);\nlayoutBase.Quicksort = __nested_webpack_require_145732__(25);\nlayoutBase.LinkedList = __nested_webpack_require_145732__(11);\nlayoutBase.LGraphObject = __nested_webpack_require_145732__(2);\nlayoutBase.LGraph = __nested_webpack_require_145732__(6);\nlayoutBase.LEdge = __nested_webpack_require_145732__(1);\nlayoutBase.LGraphManager = __nested_webpack_require_145732__(7);\nlayoutBase.LNode = __nested_webpack_require_145732__(3);\nlayoutBase.Layout = __nested_webpack_require_145732__(15);\nlayoutBase.LayoutConstants = __nested_webpack_require_145732__(0);\nlayoutBase.NeedlemanWunsch = __nested_webpack_require_145732__(27);\nlayoutBase.Matrix = __nested_webpack_require_145732__(24);\nlayoutBase.SVD = __nested_webpack_require_145732__(26);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9sYXlvdXQtYmFzZS9sYXlvdXQtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmFiYml0bXEtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUtZmNvc2Uvbm9kZV9tb2R1bGVzL2xheW91dC1iYXNlL2xheW91dC1iYXNlLmpzP2EzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibGF5b3V0QmFzZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJsYXlvdXRCYXNlXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjgpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBMYXlvdXRDb25zdGFudHMoKSB7fVxuXG4vKipcclxuICogTGF5b3V0IFF1YWxpdHk6IDA6ZHJhZnQsIDE6ZGVmYXVsdCwgMjpwcm9vZlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5RVUFMSVRZID0gMTtcblxuLyoqXHJcbiAqIERlZmF1bHQgcGFyYW1ldGVyc1xyXG4gKi9cbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUID0gdHJ1ZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EID0gNTA7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUyA9IGZhbHNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogR2VuZXJhbCBvdGhlciBjb25zdGFudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKlxyXG4gKiBNYXJnaW5zIG9mIGEgZ3JhcGggdG8gYmUgYXBwbGllZCBvbiBib3VkaW5nIHJlY3RhbmdsZSBvZiBpdHMgY29udGVudHMuIFdlXHJcbiAqIGFzc3VtZSBtYXJnaW5zIG9uIGFsbCBmb3VyIHNpZGVzIHRvIGJlIHVuaWZvcm0uXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBUEhfTUFSR0lOID0gMTU7XG5cbi8qXHJcbiAqIFdoZXRoZXIgdG8gY29uc2lkZXIgbGFiZWxzIGluIG5vZGUgZGltZW5zaW9ucyBvciBub3RcclxuICovXG5MYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gZmFsc2U7XG5cbi8qXHJcbiAqIERlZmF1bHQgZGltZW5zaW9uIG9mIGEgbm9uLWNvbXBvdW5kIG5vZGUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkUgPSA0MDtcblxuLypcclxuICogRGVmYXVsdCBkaW1lbnNpb24gb2YgYSBub24tY29tcG91bmQgbm9kZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfSEFMRl9TSVpFID0gTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkUgLyAyO1xuXG4vKlxyXG4gKiBFbXB0eSBjb21wb3VuZCBub2RlIHNpemUuIFdoZW4gYSBjb21wb3VuZCBub2RlIGlzIGVtcHR5LCBpdHMgYm90aFxyXG4gKiBkaW1lbnNpb25zIHNob3VsZCBiZSBvZiB0aGlzIHZhbHVlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5FTVBUWV9DT01QT1VORF9OT0RFX1NJWkUgPSA0MDtcblxuLypcclxuICogTWluaW11bSBsZW5ndGggdGhhdCBhbiBlZGdlIHNob3VsZCB0YWtlIGR1cmluZyBsYXlvdXRcclxuICovXG5MYXlvdXRDb25zdGFudHMuTUlOX0VER0VfTEVOR1RIID0gMTtcblxuLypcclxuICogV29ybGQgYm91bmRhcmllcyB0aGF0IGxheW91dCBvcGVyYXRlcyBvblxyXG4gKi9cbkxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSA9IDEwMDAwMDA7XG5cbi8qXHJcbiAqIFdvcmxkIGJvdW5kYXJpZXMgdGhhdCByYW5kb20gcG9zaXRpb25pbmcgY2FuIGJlIHBlcmZvcm1lZCB3aXRoXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlkgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkgLyAxMDAwO1xuXG4vKlxyXG4gKiBDb29yZGluYXRlcyBvZiB0aGUgd29ybGQgY2VudGVyXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YID0gMTIwMDtcbkxheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSA9IDkwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXRDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xudmFyIElNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuZnVuY3Rpb24gTEVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIExHcmFwaE9iamVjdC5jYWxsKHRoaXMsIHZFZGdlKTtcblxuICB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IGZhbHNlO1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZFZGdlO1xuICB0aGlzLmJlbmRwb2ludHMgPSBbXTtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5MRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE9iamVjdCkge1xuICBMRWRnZVtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTEVkZ2UucHJvdG90eXBlLmdldFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudGFyZ2V0O1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmlzSW50ZXJHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNJbnRlckdyYXBoO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0O1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldEJlbmRwb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmJlbmRwb2ludHM7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0TGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0U291cmNlSW5MY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZUluTGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFRhcmdldEluTGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50YXJnZXRJbkxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRPdGhlckVuZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLnNvdXJjZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIk5vZGUgaXMgbm90IGluY2lkZW50IHdpdGggdGhpcyBlZGdlXCI7XG4gIH1cbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRPdGhlckVuZEluR3JhcGggPSBmdW5jdGlvbiAobm9kZSwgZ3JhcGgpIHtcbiAgdmFyIG90aGVyRW5kID0gdGhpcy5nZXRPdGhlckVuZChub2RlKTtcbiAgdmFyIHJvb3QgPSBncmFwaC5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAob3RoZXJFbmQuZ2V0T3duZXIoKSA9PSBncmFwaCkge1xuICAgICAgcmV0dXJuIG90aGVyRW5kO1xuICAgIH1cblxuICAgIGlmIChvdGhlckVuZC5nZXRPd25lcigpID09IHJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG90aGVyRW5kID0gb3RoZXJFbmQuZ2V0T3duZXIoKS5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLnVwZGF0ZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNsaXBQb2ludENvb3JkaW5hdGVzID0gbmV3IEFycmF5KDQpO1xuXG4gIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbih0aGlzLnRhcmdldC5nZXRSZWN0KCksIHRoaXMuc291cmNlLmdldFJlY3QoKSwgY2xpcFBvaW50Q29vcmRpbmF0ZXMpO1xuXG4gIGlmICghdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQpIHtcbiAgICB0aGlzLmxlbmd0aFggPSBjbGlwUG9pbnRDb29yZGluYXRlc1swXSAtIGNsaXBQb2ludENvb3JkaW5hdGVzWzJdO1xuICAgIHRoaXMubGVuZ3RoWSA9IGNsaXBQb2ludENvb3JkaW5hdGVzWzFdIC0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbM107XG5cbiAgICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhYKSA8IDEuMCkge1xuICAgICAgdGhpcy5sZW5ndGhYID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFgpO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFkpIDwgMS4wKSB7XG4gICAgICB0aGlzLmxlbmd0aFkgPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWSk7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhYICogdGhpcy5sZW5ndGhYICsgdGhpcy5sZW5ndGhZICogdGhpcy5sZW5ndGhZKTtcbiAgfVxufTtcblxuTEVkZ2UucHJvdG90eXBlLnVwZGF0ZUxlbmd0aFNpbXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sZW5ndGhYID0gdGhpcy50YXJnZXQuZ2V0Q2VudGVyWCgpIC0gdGhpcy5zb3VyY2UuZ2V0Q2VudGVyWCgpO1xuICB0aGlzLmxlbmd0aFkgPSB0aGlzLnRhcmdldC5nZXRDZW50ZXJZKCkgLSB0aGlzLnNvdXJjZS5nZXRDZW50ZXJZKCk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWCkgPCAxLjApIHtcbiAgICB0aGlzLmxlbmd0aFggPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWCk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhZKSA8IDEuMCkge1xuICAgIHRoaXMubGVuZ3RoWSA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhZKTtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoWCAqIHRoaXMubGVuZ3RoWCArIHRoaXMubGVuZ3RoWSAqIHRoaXMubGVuZ3RoWSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gTEdyYXBoT2JqZWN0KHZHcmFwaE9iamVjdCkge1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZHcmFwaE9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMR3JhcGhPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgUmFuZG9tU2VlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbmZ1bmN0aW9uIExOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIC8vQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgMSA6IExOb2RlKExHcmFwaE1hbmFnZXIgZ20sIFBvaW50IGxvYywgRGltZW5zaW9uIHNpemUsIE9iamVjdCB2Tm9kZSlcbiAgaWYgKHNpemUgPT0gbnVsbCAmJiB2Tm9kZSA9PSBudWxsKSB7XG4gICAgdk5vZGUgPSBsb2M7XG4gIH1cblxuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2Tm9kZSk7XG5cbiAgLy9BbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciAyIDogTE5vZGUoTGF5b3V0IGxheW91dCwgT2JqZWN0IHZOb2RlKVxuICBpZiAoZ20uZ3JhcGhNYW5hZ2VyICE9IG51bGwpIGdtID0gZ20uZ3JhcGhNYW5hZ2VyO1xuXG4gIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IEludGVnZXIuTUlOX1ZBTFVFO1xuICB0aGlzLmluY2x1c2lvblRyZWVEZXB0aCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZOb2RlO1xuICB0aGlzLmVkZ2VzID0gW107XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG5cbiAgaWYgKHNpemUgIT0gbnVsbCAmJiBsb2MgIT0gbnVsbCkgdGhpcy5yZWN0ID0gbmV3IFJlY3RhbmdsZUQobG9jLngsIGxvYy55LCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7ZWxzZSB0aGlzLnJlY3QgPSBuZXcgUmVjdGFuZ2xlRCgpO1xufVxuXG5MTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTE5vZGVbcHJvcF0gPSBMR3JhcGhPYmplY3RbcHJvcF07XG59XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWRnZXM7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE93bmVyID0gZnVuY3Rpb24gKCkge1xuICAvLyAgaWYgKHRoaXMub3duZXIgIT0gbnVsbCkge1xuICAvLyAgICBpZiAoISh0aGlzLm93bmVyID09IG51bGwgfHwgdGhpcy5vd25lci5nZXROb2RlcygpLmluZGV4T2YodGhpcykgPiAtMSkpIHtcbiAgLy8gICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgLy8gICAgfVxuICAvLyAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LndpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHRoaXMucmVjdC53aWR0aCA9IHdpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICB0aGlzLnJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlclggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aCAvIDIsIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodCAvIDIpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLnJlY3QueCwgdGhpcy5yZWN0LnkpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RGlhZ29uYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5yZWN0LndpZHRoICogdGhpcy5yZWN0LndpZHRoICsgdGhpcy5yZWN0LmhlaWdodCAqIHRoaXMucmVjdC5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGhhbGYgdGhlIGRpYWdvbmFsIGxlbmd0aCBvZiB0aGlzIG5vZGUuXG4gKi9cbkxOb2RlLnByb3RvdHlwZS5nZXRIYWxmVGhlRGlhZ29uYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5yZWN0LmhlaWdodCAqIHRoaXMucmVjdC5oZWlnaHQgKyB0aGlzLnJlY3Qud2lkdGggKiB0aGlzLnJlY3Qud2lkdGgpIC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRSZWN0ID0gZnVuY3Rpb24gKHVwcGVyTGVmdCwgZGltZW5zaW9uKSB7XG4gIHRoaXMucmVjdC54ID0gdXBwZXJMZWZ0Lng7XG4gIHRoaXMucmVjdC55ID0gdXBwZXJMZWZ0Lnk7XG4gIHRoaXMucmVjdC53aWR0aCA9IGRpbWVuc2lvbi53aWR0aDtcbiAgdGhpcy5yZWN0LmhlaWdodCA9IGRpbWVuc2lvbi5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGN4LCBjeSkge1xuICB0aGlzLnJlY3QueCA9IGN4IC0gdGhpcy5yZWN0LndpZHRoIC8gMjtcbiAgdGhpcy5yZWN0LnkgPSBjeSAtIHRoaXMucmVjdC5oZWlnaHQgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdGhpcy5yZWN0LnggPSB4O1xuICB0aGlzLnJlY3QueSA9IHk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUubW92ZUJ5ID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICB0aGlzLnJlY3QueCArPSBkeDtcbiAgdGhpcy5yZWN0LnkgKz0gZHk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZUxpc3RUb05vZGUgPSBmdW5jdGlvbiAodG8pIHtcbiAgdmFyIGVkZ2VMaXN0ID0gW107XG4gIHZhciBlZGdlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgPT0gdG8pIHtcbiAgICAgIGlmIChlZGdlLnNvdXJjZSAhPSBzZWxmKSB0aHJvdyBcIkluY29ycmVjdCBlZGdlIHNvdXJjZSFcIjtcblxuICAgICAgZWRnZUxpc3QucHVzaChlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlc0JldHdlZW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgdmFyIGVkZ2VMaXN0ID0gW107XG4gIHZhciBlZGdlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZSA9PSBzZWxmIHx8IGVkZ2UudGFyZ2V0ID09IHNlbGYpKSB0aHJvdyBcIkluY29ycmVjdCBlZGdlIHNvdXJjZSBhbmQvb3IgdGFyZ2V0XCI7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgPT0gb3RoZXIgfHwgZWRnZS5zb3VyY2UgPT0gb3RoZXIpIHtcbiAgICAgIGVkZ2VMaXN0LnB1c2goZWRnZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWRnZUxpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5laWdoYm9ycyA9IG5ldyBTZXQoKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKGVkZ2Uuc291cmNlID09IHNlbGYpIHtcbiAgICAgIG5laWdoYm9ycy5hZGQoZWRnZS50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWRnZS50YXJnZXQgIT0gc2VsZikge1xuICAgICAgICB0aHJvdyBcIkluY29ycmVjdCBpbmNpZGVuY3khXCI7XG4gICAgICB9XG5cbiAgICAgIG5laWdoYm9ycy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn07XG5cbkxOb2RlLnByb3RvdHlwZS53aXRoQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3aXRoTmVpZ2hib3JzTGlzdCA9IG5ldyBTZXQoKTtcbiAgdmFyIGNoaWxkTm9kZTtcbiAgdmFyIGNoaWxkcmVuO1xuXG4gIHdpdGhOZWlnaGJvcnNMaXN0LmFkZCh0aGlzKTtcblxuICBpZiAodGhpcy5jaGlsZCAhPSBudWxsKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkTm9kZSA9IG5vZGVzW2ldO1xuICAgICAgY2hpbGRyZW4gPSBjaGlsZE5vZGUud2l0aENoaWxkcmVuKCk7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHdpdGhOZWlnaGJvcnNMaXN0LmFkZChub2RlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aXRoTmVpZ2hib3JzTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXROb09mQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub09mQ2hpbGRyZW4gPSAwO1xuICB2YXIgY2hpbGROb2RlO1xuXG4gIGlmICh0aGlzLmNoaWxkID09IG51bGwpIHtcbiAgICBub09mQ2hpbGRyZW4gPSAxO1xuICB9IGVsc2Uge1xuICAgIHZhciBub2RlcyA9IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgbm9PZkNoaWxkcmVuICs9IGNoaWxkTm9kZS5nZXROb09mQ2hpbGRyZW4oKTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9PZkNoaWxkcmVuID09IDApIHtcbiAgICBub09mQ2hpbGRyZW4gPSAxO1xuICB9XG4gIHJldHVybiBub09mQ2hpbGRyZW47XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZXN0aW1hdGVkU2l6ZSA9PSBJbnRlZ2VyLk1JTl9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuY2FsY0VzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNoaWxkID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplID0gKHRoaXMucmVjdC53aWR0aCArIHRoaXMucmVjdC5oZWlnaHQpIC8gMjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSB0aGlzLmNoaWxkLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gICAgdGhpcy5yZWN0LndpZHRoID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICAgIHRoaXMucmVjdC5oZWlnaHQgPSB0aGlzLmVzdGltYXRlZFNpemU7XG5cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICB9XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2NhdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhbmRvbUNlbnRlclg7XG4gIHZhciByYW5kb21DZW50ZXJZO1xuXG4gIHZhciBtaW5YID0gLUxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICB2YXIgbWF4WCA9IExheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICByYW5kb21DZW50ZXJYID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YICsgUmFuZG9tU2VlZC5uZXh0RG91YmxlKCkgKiAobWF4WCAtIG1pblgpICsgbWluWDtcblxuICB2YXIgbWluWSA9IC1MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgdmFyIG1heFkgPSBMYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgcmFuZG9tQ2VudGVyWSA9IExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSArIFJhbmRvbVNlZWQubmV4dERvdWJsZSgpICogKG1heFkgLSBtaW5ZKSArIG1pblk7XG5cbiAgdGhpcy5yZWN0LnggPSByYW5kb21DZW50ZXJYO1xuICB0aGlzLnJlY3QueSA9IHJhbmRvbUNlbnRlclk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICBpZiAodGhpcy5nZXRDaGlsZCgpLmdldE5vZGVzKCkubGVuZ3RoICE9IDApIHtcbiAgICAvLyB3cmFwIHRoZSBjaGlsZHJlbiBub2RlcyBieSByZS1hcnJhbmdpbmcgdGhlIGJvdW5kYXJpZXNcbiAgICB2YXIgY2hpbGRHcmFwaCA9IHRoaXMuZ2V0Q2hpbGQoKTtcbiAgICBjaGlsZEdyYXBoLnVwZGF0ZUJvdW5kcyh0cnVlKTtcblxuICAgIHRoaXMucmVjdC54ID0gY2hpbGRHcmFwaC5nZXRMZWZ0KCk7XG4gICAgdGhpcy5yZWN0LnkgPSBjaGlsZEdyYXBoLmdldFRvcCgpO1xuXG4gICAgdGhpcy5zZXRXaWR0aChjaGlsZEdyYXBoLmdldFJpZ2h0KCkgLSBjaGlsZEdyYXBoLmdldExlZnQoKSk7XG4gICAgdGhpcy5zZXRIZWlnaHQoY2hpbGRHcmFwaC5nZXRCb3R0b20oKSAtIGNoaWxkR3JhcGguZ2V0VG9wKCkpO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyAgICBcbiAgICBpZiAoTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjaGlsZEdyYXBoLmdldFJpZ2h0KCkgLSBjaGlsZEdyYXBoLmdldExlZnQoKTtcbiAgICAgIHZhciBoZWlnaHQgPSBjaGlsZEdyYXBoLmdldEJvdHRvbSgpIC0gY2hpbGRHcmFwaC5nZXRUb3AoKTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxXaWR0aCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueCAtPSB0aGlzLmxhYmVsV2lkdGg7XG4gICAgICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCArIHRoaXMubGFiZWxXaWR0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJjZW50ZXJcIiAmJiB0aGlzLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIHRoaXMucmVjdC54IC09ICh0aGlzLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy5sYWJlbFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICB0aGlzLnNldFdpZHRoKHdpZHRoICsgdGhpcy5sYWJlbFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueSAtPSB0aGlzLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCArIHRoaXMubGFiZWxIZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImNlbnRlclwiICYmIHRoaXMubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueSAtPSAodGhpcy5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KHRoaXMubGFiZWxIZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0ICsgdGhpcy5sYWJlbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmluY2x1c2lvblRyZWVEZXB0aCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmluY2x1c2lvblRyZWVEZXB0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgdmFyIGxlZnQgPSB0aGlzLnJlY3QueDtcblxuICBpZiAobGVmdCA+IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIGxlZnQgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH0gZWxzZSBpZiAobGVmdCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICBsZWZ0ID0gLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfVxuXG4gIHZhciB0b3AgPSB0aGlzLnJlY3QueTtcblxuICBpZiAodG9wID4gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgdG9wID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9IGVsc2UgaWYgKHRvcCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICB0b3AgPSAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9XG5cbiAgdmFyIGxlZnRUb3AgPSBuZXcgUG9pbnREKGxlZnQsIHRvcCk7XG4gIHZhciB2TGVmdFRvcCA9IHRyYW5zLmludmVyc2VUcmFuc2Zvcm1Qb2ludChsZWZ0VG9wKTtcblxuICB0aGlzLnNldExvY2F0aW9uKHZMZWZ0VG9wLngsIHZMZWZ0VG9wLnkpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm93bmVyID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyLmdldFBhcmVudCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMTm9kZTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBGRExheW91dENvbnN0YW50cygpIHt9XG5cbi8vRkRMYXlvdXRDb25zdGFudHMgaW5oZXJpdHMgc3RhdGljIHByb3BzIGluIExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXRDb25zdGFudHMpIHtcbiAgRkRMYXlvdXRDb25zdGFudHNbcHJvcF0gPSBMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gMjUwMDtcblxuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IDUwO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEggPSAwLjQ1O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSA0NTAwLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSAwLjQ7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSAxLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gMy44O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IDEuNTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OID0gdHJ1ZTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX1JFUFVMU0lPTl9SQU5HRV9DQUxDVUxBVElPTiA9IHRydWU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gMC4zO1xuRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiA9IDAuMzM7XG5GRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQgPSAxMDAwO1xuRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUID0gNTAwMDtcbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCA9IDEwMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMICogMztcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EID0gMTAwO1xuRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IDAuMTtcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9FREdFX0xFTkdUSCA9IDE7XG5GRExheW91dENvbnN0YW50cy5HUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCA9IDEwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Q29uc3RhbnRzO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUG9pbnREKHgsIHkpIHtcbiAgaWYgKHggPT0gbnVsbCAmJiB5ID09IG51bGwpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG59XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiAoeSkge1xuICB0aGlzLnkgPSB5O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5nZXREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHB0KSB7XG4gIHJldHVybiBuZXcgRGltZW5zaW9uRCh0aGlzLnggLSBwdC54LCB0aGlzLnkgLSBwdC55KTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuUG9pbnRELnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZGltKSB7XG4gIHRoaXMueCArPSBkaW0ud2lkdGg7XG4gIHRoaXMueSArPSBkaW0uaGVpZ2h0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnREO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBSZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbmZ1bmN0aW9uIExHcmFwaChwYXJlbnQsIG9iajIsIHZHcmFwaCkge1xuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2R3JhcGgpO1xuICB0aGlzLmVzdGltYXRlZFNpemUgPSBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgdGhpcy5tYXJnaW4gPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFQSF9NQVJHSU47XG4gIHRoaXMuZWRnZXMgPSBbXTtcbiAgdGhpcy5ub2RlcyA9IFtdO1xuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIGlmIChvYmoyICE9IG51bGwgJiYgb2JqMiBpbnN0YW5jZW9mIExHcmFwaE1hbmFnZXIpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajI7XG4gIH0gZWxzZSBpZiAob2JqMiAhPSBudWxsICYmIG9iajIgaW5zdGFuY2VvZiBMYXlvdXQpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajIuZ3JhcGhNYW5hZ2VyO1xuICB9XG59XG5cbkxHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTEdyYXBoW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MR3JhcGgucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlcztcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVkZ2VzO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlcjtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlZnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yaWdodDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50b3A7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYm90dG9tO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmoxLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIGlmIChzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgdmFyIG5ld05vZGUgPSBvYmoxO1xuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGhhcyBubyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE5vZGVzKCkuaW5kZXhPZihuZXdOb2RlKSA+IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgYWxyZWFkeSBpbiBncmFwaCFcIjtcbiAgICB9XG4gICAgbmV3Tm9kZS5vd25lciA9IHRoaXM7XG4gICAgdGhpcy5nZXROb2RlcygpLnB1c2gobmV3Tm9kZSk7XG5cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3RWRnZSA9IG9iajE7XG4gICAgaWYgKCEodGhpcy5nZXROb2RlcygpLmluZGV4T2Yoc291cmNlTm9kZSkgPiAtMSAmJiB0aGlzLmdldE5vZGVzKCkuaW5kZXhPZih0YXJnZXROb2RlKSA+IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2Ugb3IgdGFyZ2V0IG5vdCBpbiBncmFwaCFcIjtcbiAgICB9XG5cbiAgICBpZiAoIShzb3VyY2VOb2RlLm93bmVyID09IHRhcmdldE5vZGUub3duZXIgJiYgc291cmNlTm9kZS5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJCb3RoIG93bmVycyBtdXN0IGJlIHRoaXMgZ3JhcGghXCI7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZU5vZGUub3duZXIgIT0gdGFyZ2V0Tm9kZS5vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHNvdXJjZSBhbmQgdGFyZ2V0XG4gICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgIG5ld0VkZ2UudGFyZ2V0ID0gdGFyZ2V0Tm9kZTtcblxuICAgIC8vIHNldCBhcyBpbnRyYS1ncmFwaCBlZGdlXG4gICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSBmYWxzZTtcblxuICAgIC8vIGFkZCB0byBncmFwaCBlZGdlIGxpc3RcbiAgICB0aGlzLmdldEVkZ2VzKCkucHVzaChuZXdFZGdlKTtcblxuICAgIC8vIGFkZCB0byBpbmNpZGVuY3kgbGlzdHNcbiAgICBzb3VyY2VOb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICBpZiAodGFyZ2V0Tm9kZSAhPSBzb3VyY2VOb2RlKSB7XG4gICAgICB0YXJnZXROb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0VkZ2U7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgbm9kZSA9IG9iajtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJOb2RlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKG5vZGUub3duZXIgIT0gbnVsbCAmJiBub2RlLm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIGlzIGludmFsaWQhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIG1hbmFnZXIgaXMgaW52YWxpZCFcIjtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGluY2lkZW50IGVkZ2VzIGZpcnN0IChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIGVkZ2VzVG9CZVJlbW92ZWQgPSBub2RlLmVkZ2VzLnNsaWNlKCk7XG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG5cbiAgICAgIGlmIChlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlLnNvdXJjZS5vd25lci5yZW1vdmUoZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm93IHRoZSBub2RlIGl0c2VsZlxuICAgIHZhciBpbmRleCA9IHRoaXMubm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm9kZSBub3QgaW4gb3duZXIgbm9kZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIHRoaXMubm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIHZhciBlZGdlID0gb2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKGVkZ2Uuc291cmNlLm93bmVyICE9IG51bGwgJiYgZWRnZS50YXJnZXQub3duZXIgIT0gbnVsbCAmJiBlZGdlLnNvdXJjZS5vd25lciA9PSB0aGlzICYmIGVkZ2UudGFyZ2V0Lm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IG93bmVyIGlzIGludmFsaWQhXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICB2YXIgdGFyZ2V0SW5kZXggPSBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGlmICghKHNvdXJjZUluZGV4ID4gLTEgJiYgdGFyZ2V0SW5kZXggPiAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgZG9lc24ndCBrbm93IHRoaXMgZWRnZSFcIjtcbiAgICB9XG5cbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2Uoc291cmNlSW5kZXgsIDEpO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ICE9IGVkZ2Uuc291cmNlKSB7XG4gICAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuaW5kZXhPZihlZGdlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm90IGluIG93bmVyJ3MgZWRnZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVMZWZ0VG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9wID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBtYXJnaW47XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG4gIH1cblxuICAvLyBEbyB3ZSBoYXZlIGFueSBub2RlcyBpbiB0aGlzIGdyYXBoP1xuICBpZiAodG9wID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgbWFyZ2luID0gbm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQ7XG4gIH0gZWxzZSB7XG4gICAgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gIH1cblxuICB0aGlzLmxlZnQgPSBsZWZ0IC0gbWFyZ2luO1xuICB0aGlzLnRvcCA9IHRvcCAtIG1hcmdpbjtcblxuICAvLyBBcHBseSB0aGUgbWFyZ2lucyBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKHJlY3Vyc2l2ZSkge1xuICAvLyBjYWxjdWxhdGUgYm91bmRzXG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcbiAgdmFyIG1hcmdpbjtcblxuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChyZWN1cnNpdmUgJiYgbE5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgbE5vZGUudXBkYXRlQm91bmRzKCk7XG4gICAgfVxuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgaWYgKGxlZnQgPT0gSW50ZWdlci5NQVhfVkFMVUUpIHtcbiAgICB0aGlzLmxlZnQgPSB0aGlzLnBhcmVudC5nZXRMZWZ0KCk7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMucGFyZW50LmdldFJpZ2h0KCk7XG4gICAgdGhpcy50b3AgPSB0aGlzLnBhcmVudC5nZXRUb3AoKTtcbiAgICB0aGlzLmJvdHRvbSA9IHRoaXMucGFyZW50LmdldEJvdHRvbSgpO1xuICB9XG5cbiAgaWYgKG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0ICE9IHVuZGVmaW5lZCkge1xuICAgIG1hcmdpbiA9IG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0O1xuICB9IGVsc2Uge1xuICAgIG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICB9XG5cbiAgdGhpcy5sZWZ0ID0gYm91bmRpbmdSZWN0LnggLSBtYXJnaW47XG4gIHRoaXMucmlnaHQgPSBib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCArIG1hcmdpbjtcbiAgdGhpcy50b3AgPSBib3VuZGluZ1JlY3QueSAtIG1hcmdpbjtcbiAgdGhpcy5ib3R0b20gPSBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgKyBtYXJnaW47XG59O1xuXG5MR3JhcGguY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcblxuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcblxuICByZXR1cm4gYm91bmRpbmdSZWN0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzID09IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5lc3RpbWF0ZWRTaXplID09IEludGVnZXIuTUlOX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuY2FsY0VzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBzaXplICs9IGxOb2RlLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gIH1cblxuICBpZiAoc2l6ZSA9PSAwKSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gTGF5b3V0Q29uc3RhbnRzLkVNUFRZX0NPTVBPVU5EX05PREVfU0laRTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBzaXplIC8gTWF0aC5zcXJ0KHRoaXMubm9kZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUNvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLm5vZGVzWzBdO1xuICB2YXIgbmVpZ2hib3JFZGdlcztcbiAgdmFyIGN1cnJlbnROZWlnaGJvcjtcbiAgdmFyIGNoaWxkcmVuT2ZOb2RlID0gY3VycmVudE5vZGUud2l0aENoaWxkcmVuKCk7XG4gIGNoaWxkcmVuT2ZOb2RlLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICB9KTtcblxuICB3aGlsZSAocXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcbiAgICB2YXIgc2l6ZSA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbmVpZ2hib3JFZGdlID0gbmVpZ2hib3JFZGdlc1tpXTtcbiAgICAgIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZS5nZXRPdGhlckVuZEluR3JhcGgoY3VycmVudE5vZGUsIHRoaXMpO1xuXG4gICAgICAvLyBBZGQgdW52aXNpdGVkIG5laWdoYm9ycyB0byB0aGUgbGlzdCB0byB2aXNpdFxuICAgICAgaWYgKGN1cnJlbnROZWlnaGJvciAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbk9mTmVpZ2hib3IgPSBjdXJyZW50TmVpZ2hib3Iud2l0aENoaWxkcmVuKCk7XG5cbiAgICAgICAgY2hpbGRyZW5PZk5laWdoYm9yLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG5cbiAgaWYgKHZpc2l0ZWQuc2l6ZSA+PSB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICAgIHZhciBub09mVmlzaXRlZEluVGhpc0dyYXBoID0gMDtcblxuICAgIHZpc2l0ZWQuZm9yRWFjaChmdW5jdGlvbiAodmlzaXRlZE5vZGUpIHtcbiAgICAgIGlmICh2aXNpdGVkTm9kZS5vd25lciA9PSBzZWxmKSB7XG4gICAgICAgIG5vT2ZWaXNpdGVkSW5UaGlzR3JhcGgrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChub09mVmlzaXRlZEluVGhpc0dyYXBoID09IHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaDtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmZ1bmN0aW9uIExHcmFwaE1hbmFnZXIobGF5b3V0KSB7XG4gIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7IC8vIEl0IG1heSBiZSBiZXR0ZXIgdG8gaW5pdGlsaXplIHRoaXMgb3V0IG9mIHRoaXMgZnVuY3Rpb24gYnV0IGl0IGdpdmVzIGFuIGVycm9yIChSaWdodC1oYW5kIHNpZGUgb2YgJ2luc3RhbmNlb2YnIGlzIG5vdCBjYWxsYWJsZSkgbm93LlxuICB0aGlzLmxheW91dCA9IGxheW91dDtcblxuICB0aGlzLmdyYXBocyA9IFtdO1xuICB0aGlzLmVkZ2VzID0gW107XG59XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmFkZFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZ3JhcGggPSB0aGlzLmxheW91dC5uZXdHcmFwaCgpO1xuICB2YXIgbm5vZGUgPSB0aGlzLmxheW91dC5uZXdOb2RlKG51bGwpO1xuICB2YXIgcm9vdCA9IHRoaXMuYWRkKG5ncmFwaCwgbm5vZGUpO1xuICB0aGlzLnNldFJvb3RHcmFwaChyb290KTtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5ld0dyYXBoLCBwYXJlbnROb2RlLCBuZXdFZGdlLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIC8vdGhlcmUgYXJlIGp1c3QgMiBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQgdGhlbiBpdCBhZGRzIGFuIExHcmFwaCBlbHNlIGl0IGFkZHMgYW4gTEVkZ2VcbiAgaWYgKG5ld0VkZ2UgPT0gbnVsbCAmJiBzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgaWYgKG5ld0dyYXBoID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiR3JhcGggaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJQYXJlbnQgbm9kZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5ncmFwaHMuaW5kZXhPZihuZXdHcmFwaCkgPiAtMSkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBhbHJlYWR5IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cblxuICAgIHRoaXMuZ3JhcGhzLnB1c2gobmV3R3JhcGgpO1xuXG4gICAgaWYgKG5ld0dyYXBoLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgcGFyZW50IVwiO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgY2hpbGQhXCI7XG4gICAgfVxuXG4gICAgbmV3R3JhcGgucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmNoaWxkID0gbmV3R3JhcGg7XG5cbiAgICByZXR1cm4gbmV3R3JhcGg7XG4gIH0gZWxzZSB7XG4gICAgLy9jaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAgdGFyZ2V0Tm9kZSA9IG5ld0VkZ2U7XG4gICAgc291cmNlTm9kZSA9IHBhcmVudE5vZGU7XG4gICAgbmV3RWRnZSA9IG5ld0dyYXBoO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSB0YXJnZXROb2RlLmdldE93bmVyKCk7XG5cbiAgICBpZiAoIShzb3VyY2VHcmFwaCAhPSBudWxsICYmIHNvdXJjZUdyYXBoLmdldEdyYXBoTWFuYWdlcigpID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICghKHRhcmdldEdyYXBoICE9IG51bGwgJiYgdGFyZ2V0R3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiVGFyZ2V0IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlR3JhcGggPT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gZmFsc2U7XG4gICAgICByZXR1cm4gc291cmNlR3JhcGguYWRkKG5ld0VkZ2UsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IHRydWU7XG5cbiAgICAgIC8vIHNldCBzb3VyY2UgYW5kIHRhcmdldFxuICAgICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgICAgbmV3RWRnZS50YXJnZXQgPSB0YXJnZXROb2RlO1xuXG4gICAgICAvLyBhZGQgZWRnZSB0byBpbnRlci1ncmFwaCBlZGdlIGxpc3RcbiAgICAgIGlmICh0aGlzLmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPiAtMSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2UgYWxyZWFkeSBpbiBpbnRlci1ncmFwaCBlZGdlIGxpc3QhXCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgLy8gYWRkIGVkZ2UgdG8gc291cmNlIGFuZCB0YXJnZXQgaW5jaWRlbmN5IGxpc3RzXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZSAhPSBudWxsICYmIG5ld0VkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBzb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID09IC0xICYmIG5ld0VkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPT0gLTEpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBhbHJlYWR5IGluIHNvdXJjZSBhbmQvb3IgdGFyZ2V0IGluY2lkZW5jeSBsaXN0IVwiO1xuICAgICAgfVxuXG4gICAgICBuZXdFZGdlLnNvdXJjZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgICAgbmV3RWRnZS50YXJnZXQuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobE9iaikge1xuICBpZiAobE9iaiBpbnN0YW5jZW9mIExHcmFwaCkge1xuICAgIHZhciBncmFwaCA9IGxPYmo7XG4gICAgaWYgKGdyYXBoLmdldEdyYXBoTWFuYWdlcigpICE9IHRoaXMpIHtcbiAgICAgIHRocm93IFwiR3JhcGggbm90IGluIHRoaXMgZ3JhcGggbWdyXCI7XG4gICAgfVxuICAgIGlmICghKGdyYXBoID09IHRoaXMucm9vdEdyYXBoIHx8IGdyYXBoLnBhcmVudCAhPSBudWxsICYmIGdyYXBoLnBhcmVudC5ncmFwaE1hbmFnZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBwYXJlbnQgbm9kZSFcIjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdCB0aGUgZWRnZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgZWRnZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgZWRnZXNUb0JlUmVtb3ZlZCA9IGVkZ2VzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldEVkZ2VzKCkpO1xuXG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gICAgLy8gdGhlbiB0aGUgbm9kZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgbm9kZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgbm9kZXNUb0JlUmVtb3ZlZCA9IG5vZGVzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldE5vZGVzKCkpO1xuXG4gICAgdmFyIG5vZGU7XG4gICAgcyA9IG5vZGVzVG9CZVJlbW92ZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNUb0JlUmVtb3ZlZFtpXTtcbiAgICAgIGdyYXBoLnJlbW92ZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBncmFwaCBpcyB0aGUgcm9vdFxuICAgIGlmIChncmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgdGhpcy5zZXRSb290R3JhcGgobnVsbCk7XG4gICAgfVxuXG4gICAgLy8gbm93IHJlbW92ZSB0aGUgZ3JhcGggaXRzZWxmXG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncmFwaHMuaW5kZXhPZihncmFwaCk7XG4gICAgdGhpcy5ncmFwaHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIGFsc28gcmVzZXQgdGhlIHBhcmVudCBvZiB0aGUgZ3JhcGhcbiAgICBncmFwaC5wYXJlbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGxPYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIGVkZ2UgPSBsT2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIWVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICB0aHJvdyBcIk5vdCBhbiBpbnRlci1ncmFwaCBlZGdlIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBzb3VyY2UgYW5kIHRhcmdldCBub2RlcycgaW5jaWRlbmN5IGxpc3RzXG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKGVkZ2UpICE9IC0xICYmIGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSkgIT0gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGRvZXNuJ3Qga25vdyB0aGlzIGVkZ2UhXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGluZGV4ID0gZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBvd25lciBncmFwaCBtYW5hZ2VyJ3MgaW50ZXItZ3JhcGggZWRnZSBsaXN0XG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5vd25lciAhPSBudWxsICYmIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIkVkZ2Ugb3duZXIgZ3JhcGggb3Igb3duZXIgZ3JhcGggbWFuYWdlciBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuaW5kZXhPZihlZGdlKSA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJOb3QgaW4gb3duZXIgZ3JhcGggbWFuYWdlcidzIGVkZ2UgbGlzdCFcIjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yb290R3JhcGgudXBkYXRlQm91bmRzKHRydWUpO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0R3JhcGhzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaHM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXMgPT0gbnVsbCkge1xuICAgIHZhciBub2RlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICB0aGlzLmFsbE5vZGVzID0gbm9kZUxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYWxsTm9kZXM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbE5vZGVzID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsRWRnZXMgPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsRWRnZXMgPT0gbnVsbCkge1xuICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldEVkZ2VzKCkpO1xuICAgIH1cblxuICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHRoaXMuZWRnZXMpO1xuXG4gICAgdGhpcy5hbGxFZGdlcyA9IGVkZ2VMaXN0O1xuICB9XG4gIHJldHVybiB0aGlzLmFsbEVkZ2VzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAobm9kZUxpc3QpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gIT0gbnVsbCkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG5vZGVMaXN0O1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0Um9vdEdyYXBoID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gIGlmIChncmFwaC5nZXRHcmFwaE1hbmFnZXIoKSAhPSB0aGlzKSB7XG4gICAgdGhyb3cgXCJSb290IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgfVxuXG4gIHRoaXMucm9vdEdyYXBoID0gZ3JhcGg7XG4gIC8vIHJvb3QgZ3JhcGggbXVzdCBoYXZlIGEgcm9vdCBub2RlIGFzc29jaWF0ZWQgd2l0aCBpdCBmb3IgY29udmVuaWVuY2VcbiAgaWYgKGdyYXBoLnBhcmVudCA9PSBudWxsKSB7XG4gICAgZ3JhcGgucGFyZW50ID0gdGhpcy5sYXlvdXQubmV3Tm9kZShcIlJvb3Qgbm9kZVwiKTtcbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sYXlvdXQ7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pc09uZUFuY2VzdG9yT2ZPdGhlciA9IGZ1bmN0aW9uIChmaXJzdE5vZGUsIHNlY29uZE5vZGUpIHtcbiAgaWYgKCEoZmlyc3ROb2RlICE9IG51bGwgJiYgc2Vjb25kTm9kZSAhPSBudWxsKSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgaWYgKGZpcnN0Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSXMgc2Vjb25kIG5vZGUgYW4gYW5jZXN0b3Igb2YgdGhlIGZpcnN0IG9uZT9cbiAgdmFyIG93bmVyR3JhcGggPSBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcbiAgdmFyIHBhcmVudE5vZGU7XG5cbiAgZG8ge1xuICAgIHBhcmVudE5vZGUgPSBvd25lckdyYXBoLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuICAvLyBJcyBmaXJzdCBub2RlIGFuIGFuY2VzdG9yIG9mIHRoZSBzZWNvbmQgb25lP1xuICBvd25lckdyYXBoID0gc2Vjb25kTm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBwYXJlbnROb2RlID0gb3duZXJHcmFwaC5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnROb2RlID09IGZpcnN0Tm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlO1xuICB2YXIgc291cmNlTm9kZTtcbiAgdmFyIHRhcmdldE5vZGU7XG4gIHZhciBzb3VyY2VBbmNlc3RvckdyYXBoO1xuICB2YXIgdGFyZ2V0QW5jZXN0b3JHcmFwaDtcblxuICB2YXIgZWRnZXMgPSB0aGlzLmdldEFsbEVkZ2VzKCk7XG4gIHZhciBzID0gZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIHNvdXJjZU5vZGUgPSBlZGdlLnNvdXJjZTtcbiAgICB0YXJnZXROb2RlID0gZWRnZS50YXJnZXQ7XG4gICAgZWRnZS5sY2EgPSBudWxsO1xuICAgIGVkZ2Uuc291cmNlSW5MY2EgPSBzb3VyY2VOb2RlO1xuICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuXG4gICAgaWYgKHNvdXJjZU5vZGUgPT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgZWRnZS5sY2EgPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzb3VyY2VBbmNlc3RvckdyYXBoID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuXG4gICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuICAgICAgdGFyZ2V0QW5jZXN0b3JHcmFwaCA9IHRhcmdldE5vZGUuZ2V0T3duZXIoKTtcblxuICAgICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRhcmdldEFuY2VzdG9yR3JhcGggPT0gc291cmNlQW5jZXN0b3JHcmFwaCkge1xuICAgICAgICAgIGVkZ2UubGNhID0gdGFyZ2V0QW5jZXN0b3JHcmFwaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRBbmNlc3RvckdyYXBoID09IHRoaXMucm9vdEdyYXBoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWRnZS5sY2EgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXRBbmNlc3RvckdyYXBoLmdldFBhcmVudCgpO1xuICAgICAgICB0YXJnZXRBbmNlc3RvckdyYXBoID0gZWRnZS50YXJnZXRJbkxjYS5nZXRPd25lcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlQW5jZXN0b3JHcmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgZWRnZS5zb3VyY2VJbkxjYSA9IHNvdXJjZUFuY2VzdG9yR3JhcGguZ2V0UGFyZW50KCk7XG4gICAgICAgIHNvdXJjZUFuY2VzdG9yR3JhcGggPSBlZGdlLnNvdXJjZUluTGNhLmdldE93bmVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9yID0gZnVuY3Rpb24gKGZpcnN0Tm9kZSwgc2Vjb25kTm9kZSkge1xuICBpZiAoZmlyc3ROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICByZXR1cm4gZmlyc3ROb2RlLmdldE93bmVyKCk7XG4gIH1cbiAgdmFyIGZpcnN0T3duZXJHcmFwaCA9IGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBpZiAoZmlyc3RPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgc2Vjb25kT3duZXJHcmFwaCA9IHNlY29uZE5vZGUuZ2V0T3duZXIoKTtcblxuICAgIGRvIHtcbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IGZpcnN0T3duZXJHcmFwaCkge1xuICAgICAgICByZXR1cm4gc2Vjb25kT3duZXJHcmFwaDtcbiAgICAgIH1cbiAgICAgIHNlY29uZE93bmVyR3JhcGggPSBzZWNvbmRPd25lckdyYXBoLmdldFBhcmVudCgpLmdldE93bmVyKCk7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBmaXJzdE93bmVyR3JhcGggPSBmaXJzdE93bmVyR3JhcGguZ2V0UGFyZW50KCkuZ2V0T3duZXIoKTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGZpcnN0T3duZXJHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzID0gZnVuY3Rpb24gKGdyYXBoLCBkZXB0aCkge1xuICBpZiAoZ3JhcGggPT0gbnVsbCAmJiBkZXB0aCA9PSBudWxsKSB7XG4gICAgZ3JhcGggPSB0aGlzLnJvb3RHcmFwaDtcbiAgICBkZXB0aCA9IDE7XG4gIH1cbiAgdmFyIG5vZGU7XG5cbiAgdmFyIG5vZGVzID0gZ3JhcGguZ2V0Tm9kZXMoKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGUuaW5jbHVzaW9uVHJlZURlcHRoID0gZGVwdGg7XG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzKG5vZGUuY2hpbGQsIGRlcHRoICsgMSk7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pbmNsdWRlc0ludmFsaWRFZGdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIGVkZ2VzVG9SZW1vdmUgPSBbXTtcblxuICB2YXIgcyA9IHRoaXMuZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXG4gICAgaWYgKHRoaXMuaXNPbmVBbmNlc3Rvck9mT3RoZXIoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KSkge1xuICAgICAgZWRnZXNUb1JlbW92ZS5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBpbnZhbGlkIGVkZ2VzIGZyb20gZ3JhcGggbWFuYWdlclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzVG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJlbW92ZShlZGdlc1RvUmVtb3ZlW2ldKTtcbiAgfVxuXG4gIC8vIEludmFsaWQgZWRnZXMgYXJlIGNsZWFyZWQsIHNvIHJldHVybiBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgbWFpbnRhaW5zIGEgbGlzdCBvZiBzdGF0aWMgZ2VvbWV0cnkgcmVsYXRlZCB1dGlsaXR5IG1ldGhvZHMuXG4gKlxuICpcbiAqIENvcHlyaWdodDogaS1WaXMgUmVzZWFyY2ggR3JvdXAsIEJpbGtlbnQgVW5pdmVyc2l0eSwgMjAwNyAtIHByZXNlbnRcbiAqL1xuXG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuZnVuY3Rpb24gSUdlb21ldHJ5KCkge31cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzICpoYWxmKiB0aGUgYW1vdW50IGluIHggYW5kIHkgZGlyZWN0aW9ucyBvZiB0aGUgdHdvXG4gKiBpbnB1dCByZWN0YW5nbGVzIG5lZWRlZCB0byBzZXBhcmF0ZSB0aGVtIGtlZXBpbmcgdGhlaXIgcmVzcGVjdGl2ZVxuICogcG9zaXRpb25pbmcsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgaW4gdGhlIGlucHV0IGFycmF5LiBBbiBpbnB1dFxuICogc2VwYXJhdGlvbiBidWZmZXIgYWRkZWQgdG8gdGhlIGFtb3VudCBpbiBib3RoIGRpcmVjdGlvbnMuIFdlIGFzc3VtZSB0aGF0XG4gKiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gaW50ZXJzZWN0LlxuICovXG5JR2VvbWV0cnkuY2FsY1NlcGFyYXRpb25BbW91bnQgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdmVybGFwQW1vdW50LCBzZXBhcmF0aW9uQnVmZmVyKSB7XG4gIGlmICghcmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIHZhciBkaXJlY3Rpb25zID0gbmV3IEFycmF5KDIpO1xuXG4gIHRoaXMuZGVjaWRlRGlyZWN0aW9uc0Zvck92ZXJsYXBwaW5nTm9kZXMocmVjdEEsIHJlY3RCLCBkaXJlY3Rpb25zKTtcblxuICBvdmVybGFwQW1vdW50WzBdID0gTWF0aC5taW4ocmVjdEEuZ2V0UmlnaHQoKSwgcmVjdEIuZ2V0UmlnaHQoKSkgLSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KTtcbiAgb3ZlcmxhcEFtb3VudFsxXSA9IE1hdGgubWluKHJlY3RBLmdldEJvdHRvbSgpLCByZWN0Qi5nZXRCb3R0b20oKSkgLSBNYXRoLm1heChyZWN0QS55LCByZWN0Qi55KTtcblxuICAvLyB1cGRhdGUgdGhlIG92ZXJsYXBwaW5nIGFtb3VudHMgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gIGlmIChyZWN0QS5nZXRYKCkgPD0gcmVjdEIuZ2V0WCgpICYmIHJlY3RBLmdldFJpZ2h0KCkgPj0gcmVjdEIuZ2V0UmlnaHQoKSkge1xuICAgIC8qIENhc2UgeC4xOlxuICAgICpcbiAgICAqIHJlY3RBXG4gICAgKiBcdHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgX19fX19fX19fICAgICAgfFxuICAgICogXHR8ICAgICAgICB8ICAgICAgIHwgICAgICB8XG4gICAgKiBcdHxfX19fX19fX3xfX19fX19ffF9fX19fX3xcbiAgICAqIFx0XHRcdCB8ICAgICAgIHxcbiAgICAqICAgICAgICAgICB8ICAgICAgIHxcbiAgICAqICAgICAgICByZWN0QlxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFswXSArPSBNYXRoLm1pbihyZWN0Qi5nZXRYKCkgLSByZWN0QS5nZXRYKCksIHJlY3RBLmdldFJpZ2h0KCkgLSByZWN0Qi5nZXRSaWdodCgpKTtcbiAgfSBlbHNlIGlmIChyZWN0Qi5nZXRYKCkgPD0gcmVjdEEuZ2V0WCgpICYmIHJlY3RCLmdldFJpZ2h0KCkgPj0gcmVjdEEuZ2V0UmlnaHQoKSkge1xuICAgIC8qIENhc2UgeC4yOlxuICAgICpcbiAgICAqIHJlY3RCXG4gICAgKiBcdHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgX19fX19fX19fICAgICAgfFxuICAgICogXHR8ICAgICAgICB8ICAgICAgIHwgICAgICB8XG4gICAgKiBcdHxfX19fX19fX3xfX19fX19ffF9fX19fX3xcbiAgICAqIFx0XHRcdCB8ICAgICAgIHxcbiAgICAqICAgICAgICAgICB8ICAgICAgIHxcbiAgICAqICAgICAgICByZWN0QVxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFswXSArPSBNYXRoLm1pbihyZWN0QS5nZXRYKCkgLSByZWN0Qi5nZXRYKCksIHJlY3RCLmdldFJpZ2h0KCkgLSByZWN0QS5nZXRSaWdodCgpKTtcbiAgfVxuICBpZiAocmVjdEEuZ2V0WSgpIDw9IHJlY3RCLmdldFkoKSAmJiByZWN0QS5nZXRCb3R0b20oKSA+PSByZWN0Qi5nZXRCb3R0b20oKSkge1xuICAgIC8qIENhc2UgeS4xOlxuICAgICAqICAgICAgICAgIF9fX19fX19fIHJlY3RBXG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8XG4gICAgICogICBfX19fX198X19fXyAgcmVjdEJcbiAgICAgKiAgICAgICAgIHwgICAgfFxuICAgICAqICAgICAgICAgfCAgICB8XG4gICAgICogICBfX19fX198X19fX3xcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxfX19fX19fX1xuICAgICAqXG4gICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFsxXSArPSBNYXRoLm1pbihyZWN0Qi5nZXRZKCkgLSByZWN0QS5nZXRZKCksIHJlY3RBLmdldEJvdHRvbSgpIC0gcmVjdEIuZ2V0Qm90dG9tKCkpO1xuICB9IGVsc2UgaWYgKHJlY3RCLmdldFkoKSA8PSByZWN0QS5nZXRZKCkgJiYgcmVjdEIuZ2V0Qm90dG9tKCkgPj0gcmVjdEEuZ2V0Qm90dG9tKCkpIHtcbiAgICAvKiBDYXNlIHkuMjpcbiAgICAqICAgICAgICAgIF9fX19fX19fIHJlY3RCXG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfFxuICAgICogICBfX19fX198X19fXyAgcmVjdEFcbiAgICAqICAgICAgICAgfCAgICB8XG4gICAgKiAgICAgICAgIHwgICAgfFxuICAgICogICBfX19fX198X19fX3xcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxfX19fX19fX1xuICAgICpcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMV0gKz0gTWF0aC5taW4ocmVjdEEuZ2V0WSgpIC0gcmVjdEIuZ2V0WSgpLCByZWN0Qi5nZXRCb3R0b20oKSAtIHJlY3RBLmdldEJvdHRvbSgpKTtcbiAgfVxuXG4gIC8vIGZpbmQgc2xvcGUgb2YgdGhlIGxpbmUgcGFzc2VzIHR3byBjZW50ZXJzXG4gIHZhciBzbG9wZSA9IE1hdGguYWJzKChyZWN0Qi5nZXRDZW50ZXJZKCkgLSByZWN0QS5nZXRDZW50ZXJZKCkpIC8gKHJlY3RCLmdldENlbnRlclgoKSAtIHJlY3RBLmdldENlbnRlclgoKSkpO1xuICAvLyBpZiBjZW50ZXJzIGFyZSBvdmVybGFwcGVkXG4gIGlmIChyZWN0Qi5nZXRDZW50ZXJZKCkgPT09IHJlY3RBLmdldENlbnRlclkoKSAmJiByZWN0Qi5nZXRDZW50ZXJYKCkgPT09IHJlY3RBLmdldENlbnRlclgoKSkge1xuICAgIC8vIGFzc3VtZSB0aGUgc2xvcGUgaXMgMSAoNDUgZGVncmVlKVxuICAgIHNsb3BlID0gMS4wO1xuICB9XG5cbiAgdmFyIG1vdmVCeVkgPSBzbG9wZSAqIG92ZXJsYXBBbW91bnRbMF07XG4gIHZhciBtb3ZlQnlYID0gb3ZlcmxhcEFtb3VudFsxXSAvIHNsb3BlO1xuICBpZiAob3ZlcmxhcEFtb3VudFswXSA8IG1vdmVCeVgpIHtcbiAgICBtb3ZlQnlYID0gb3ZlcmxhcEFtb3VudFswXTtcbiAgfSBlbHNlIHtcbiAgICBtb3ZlQnlZID0gb3ZlcmxhcEFtb3VudFsxXTtcbiAgfVxuICAvLyByZXR1cm4gaGFsZiB0aGUgYW1vdW50IHNvIHRoYXQgaWYgZWFjaCByZWN0YW5nbGUgaXMgbW92ZWQgYnkgdGhlc2VcbiAgLy8gYW1vdW50cyBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zLCBvdmVybGFwIHdpbGwgYmUgcmVzb2x2ZWRcbiAgb3ZlcmxhcEFtb3VudFswXSA9IC0xICogZGlyZWN0aW9uc1swXSAqIChtb3ZlQnlYIC8gMiArIHNlcGFyYXRpb25CdWZmZXIpO1xuICBvdmVybGFwQW1vdW50WzFdID0gLTEgKiBkaXJlY3Rpb25zWzFdICogKG1vdmVCeVkgLyAyICsgc2VwYXJhdGlvbkJ1ZmZlcik7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRlY2lkZXMgdGhlIHNlcGFyYXRpb24gZGlyZWN0aW9uIG9mIG92ZXJsYXBwaW5nIG5vZGVzXG4gKlxuICogaWYgZGlyZWN0aW9uc1swXSA9IC0xLCB0aGVuIHJlY3RBIGdvZXMgbGVmdFxuICogaWYgZGlyZWN0aW9uc1swXSA9IDEsICB0aGVuIHJlY3RBIGdvZXMgcmlnaHRcbiAqIGlmIGRpcmVjdGlvbnNbMV0gPSAtMSwgdGhlbiByZWN0QSBnb2VzIHVwXG4gKiBpZiBkaXJlY3Rpb25zWzFdID0gMSwgIHRoZW4gcmVjdEEgZ29lcyBkb3duXG4gKi9cbklHZW9tZXRyeS5kZWNpZGVEaXJlY3Rpb25zRm9yT3ZlcmxhcHBpbmdOb2RlcyA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIGRpcmVjdGlvbnMpIHtcbiAgaWYgKHJlY3RBLmdldENlbnRlclgoKSA8IHJlY3RCLmdldENlbnRlclgoKSkge1xuICAgIGRpcmVjdGlvbnNbMF0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3Rpb25zWzBdID0gMTtcbiAgfVxuXG4gIGlmIChyZWN0QS5nZXRDZW50ZXJZKCkgPCByZWN0Qi5nZXRDZW50ZXJZKCkpIHtcbiAgICBkaXJlY3Rpb25zWzFdID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0aW9uc1sxXSA9IDE7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIChjbGlwcGluZykgcG9pbnRzIG9mIHRoZSB0d29cbiAqIGlucHV0IHJlY3RhbmdsZXMgd2l0aCBsaW5lIHNlZ21lbnQgZGVmaW5lZCBieSB0aGUgY2VudGVycyBvZiB0aGVzZSB0d29cbiAqIHJlY3RhbmdsZXMuIFRoZSBjbGlwcGluZyBwb2ludHMgYXJlIHNhdmVkIGluIHRoZSBpbnB1dCBkb3VibGUgYXJyYXkgYW5kXG4gKiB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIHJlY3RhbmdsZXMgb3ZlcmxhcCBpcyByZXR1cm5lZC5cbiAqL1xuSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbjIgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCByZXN1bHQpIHtcbiAgLy9yZXN1bHRbMC0xXSB3aWxsIGNvbnRhaW4gY2xpcFBvaW50IG9mIHJlY3RBLCByZXN1bHRbMi0zXSB3aWxsIGNvbnRhaW4gY2xpcFBvaW50IG9mIHJlY3RCXG4gIHZhciBwMXggPSByZWN0QS5nZXRDZW50ZXJYKCk7XG4gIHZhciBwMXkgPSByZWN0QS5nZXRDZW50ZXJZKCk7XG4gIHZhciBwMnggPSByZWN0Qi5nZXRDZW50ZXJYKCk7XG4gIHZhciBwMnkgPSByZWN0Qi5nZXRDZW50ZXJZKCk7XG5cbiAgLy9pZiB0d28gcmVjdGFuZ2xlcyBpbnRlcnNlY3QsIHRoZW4gY2xpcHBpbmcgcG9pbnRzIGFyZSBjZW50ZXJzXG4gIGlmIChyZWN0QS5pbnRlcnNlY3RzKHJlY3RCKSkge1xuICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvL3ZhcmlhYmxlcyBmb3IgcmVjdEFcbiAgdmFyIHRvcExlZnRBeCA9IHJlY3RBLmdldFgoKTtcbiAgdmFyIHRvcExlZnRBeSA9IHJlY3RBLmdldFkoKTtcbiAgdmFyIHRvcFJpZ2h0QXggPSByZWN0QS5nZXRSaWdodCgpO1xuICB2YXIgYm90dG9tTGVmdEF4ID0gcmVjdEEuZ2V0WCgpO1xuICB2YXIgYm90dG9tTGVmdEF5ID0gcmVjdEEuZ2V0Qm90dG9tKCk7XG4gIHZhciBib3R0b21SaWdodEF4ID0gcmVjdEEuZ2V0UmlnaHQoKTtcbiAgdmFyIGhhbGZXaWR0aEEgPSByZWN0QS5nZXRXaWR0aEhhbGYoKTtcbiAgdmFyIGhhbGZIZWlnaHRBID0gcmVjdEEuZ2V0SGVpZ2h0SGFsZigpO1xuICAvL3ZhcmlhYmxlcyBmb3IgcmVjdEJcbiAgdmFyIHRvcExlZnRCeCA9IHJlY3RCLmdldFgoKTtcbiAgdmFyIHRvcExlZnRCeSA9IHJlY3RCLmdldFkoKTtcbiAgdmFyIHRvcFJpZ2h0QnggPSByZWN0Qi5nZXRSaWdodCgpO1xuICB2YXIgYm90dG9tTGVmdEJ4ID0gcmVjdEIuZ2V0WCgpO1xuICB2YXIgYm90dG9tTGVmdEJ5ID0gcmVjdEIuZ2V0Qm90dG9tKCk7XG4gIHZhciBib3R0b21SaWdodEJ4ID0gcmVjdEIuZ2V0UmlnaHQoKTtcbiAgdmFyIGhhbGZXaWR0aEIgPSByZWN0Qi5nZXRXaWR0aEhhbGYoKTtcbiAgdmFyIGhhbGZIZWlnaHRCID0gcmVjdEIuZ2V0SGVpZ2h0SGFsZigpO1xuXG4gIC8vZmxhZyB3aGV0aGVyIGNsaXBwaW5nIHBvaW50cyBhcmUgZm91bmRcbiAgdmFyIGNsaXBQb2ludEFGb3VuZCA9IGZhbHNlO1xuICB2YXIgY2xpcFBvaW50QkZvdW5kID0gZmFsc2U7XG5cbiAgLy8gbGluZSBpcyB2ZXJ0aWNhbFxuICBpZiAocDF4ID09PSBwMngpIHtcbiAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChwMXkgPCBwMnkpIHtcbiAgICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9ub3QgbGluZSwgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8vIGxpbmUgaXMgaG9yaXpvbnRhbFxuICBlbHNlIGlmIChwMXkgPT09IHAyeSkge1xuICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICByZXN1bHRbMF0gPSB0b3BMZWZ0QXg7XG4gICAgICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICAgICAgcmVzdWx0WzJdID0gdG9wUmlnaHRCeDtcbiAgICAgICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHAxeCA8IHAyeCkge1xuICAgICAgICByZXN1bHRbMF0gPSB0b3BSaWdodEF4O1xuICAgICAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgICAgIHJlc3VsdFsyXSA9IHRvcExlZnRCeDtcbiAgICAgICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL25vdCB2YWxpZCBsaW5lLCByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9zbG9wZXMgb2YgcmVjdEEncyBhbmQgcmVjdEIncyBkaWFnb25hbHNcbiAgICAgIHZhciBzbG9wZUEgPSByZWN0QS5oZWlnaHQgLyByZWN0QS53aWR0aDtcbiAgICAgIHZhciBzbG9wZUIgPSByZWN0Qi5oZWlnaHQgLyByZWN0Qi53aWR0aDtcblxuICAgICAgLy9zbG9wZSBvZiBsaW5lIGJldHdlZW4gY2VudGVyIG9mIHJlY3RBIGFuZCBjZW50ZXIgb2YgcmVjdEJcbiAgICAgIHZhciBzbG9wZVByaW1lID0gKHAyeSAtIHAxeSkgLyAocDJ4IC0gcDF4KTtcbiAgICAgIHZhciBjYXJkaW5hbERpcmVjdGlvbkEgPSB2b2lkIDA7XG4gICAgICB2YXIgY2FyZGluYWxEaXJlY3Rpb25CID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEF4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEF5ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEJ4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEJ5ID0gdm9pZCAwO1xuXG4gICAgICAvL2RldGVybWluZSB3aGV0aGVyIGNsaXBwaW5nIHBvaW50IGlzIHRoZSBjb3JuZXIgb2Ygbm9kZUFcbiAgICAgIGlmICgtc2xvcGVBID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSBib3R0b21MZWZ0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gdG9wUmlnaHRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzbG9wZUEgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICAgIHJlc3VsdFswXSA9IHRvcExlZnRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSBib3R0b21SaWdodEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnQgaXMgdGhlIGNvcm5lciBvZiBub2RlQlxuICAgICAgaWYgKC1zbG9wZUIgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAyeCA+IHAxeCkge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IGJvdHRvbUxlZnRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSB0b3BSaWdodEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNsb3BlQiA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDJ4ID4gcDF4KSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gdG9wTGVmdEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IGJvdHRvbVJpZ2h0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9pZiBib3RoIGNsaXBwaW5nIHBvaW50cyBhcmUgY29ybmVyc1xuICAgICAgaWYgKGNsaXBQb2ludEFGb3VuZCAmJiBjbGlwUG9pbnRCRm91bmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvL2RldGVybWluZSBDYXJkaW5hbCBEaXJlY3Rpb24gb2YgcmVjdGFuZ2xlc1xuICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUEsIHNsb3BlUHJpbWUsIDQpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVCLCBzbG9wZVByaW1lLCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUEsIHNsb3BlUHJpbWUsIDMpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQiwgc2xvcGVQcmltZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUEsIHNsb3BlUHJpbWUsIDEpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQiwgc2xvcGVQcmltZSwgMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUEsIHNsb3BlUHJpbWUsIDIpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVCLCBzbG9wZVByaW1lLCA0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9jYWxjdWxhdGUgY2xpcHBpbmcgUG9pbnQgaWYgaXQgaXMgbm90IGZvdW5kIGJlZm9yZVxuICAgICAgaWYgKCFjbGlwUG9pbnRBRm91bmQpIHtcbiAgICAgICAgc3dpdGNoIChjYXJkaW5hbERpcmVjdGlvbkEpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHRvcExlZnRBeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gcDF4ICsgLWhhbGZIZWlnaHRBIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IGJvdHRvbVJpZ2h0QXg7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHAxeSArIGhhbGZXaWR0aEEgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBwMXggKyBoYWxmSGVpZ2h0QSAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBib3R0b21MZWZ0QXg7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHAxeSArIC1oYWxmV2lkdGhBICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbGlwUG9pbnRCRm91bmQpIHtcbiAgICAgICAgc3dpdGNoIChjYXJkaW5hbERpcmVjdGlvbkIpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHRvcExlZnRCeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gcDJ4ICsgLWhhbGZIZWlnaHRCIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IGJvdHRvbVJpZ2h0Qng7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHAyeSArIGhhbGZXaWR0aEIgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBwMnggKyBoYWxmSGVpZ2h0QiAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBib3R0b21MZWZ0Qng7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHAyeSArIC1oYWxmV2lkdGhCICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGluIHdoaWNoIGNhcmRpbmFsIGRpcmVjdGlvbiBkb2VzIGlucHV0IHBvaW50IHN0YXlzXG4gKiAxOiBOb3J0aFxuICogMjogRWFzdFxuICogMzogU291dGhcbiAqIDQ6IFdlc3RcbiAqL1xuSUdlb21ldHJ5LmdldENhcmRpbmFsRGlyZWN0aW9uID0gZnVuY3Rpb24gKHNsb3BlLCBzbG9wZVByaW1lLCBsaW5lKSB7XG4gIGlmIChzbG9wZSA+IHNsb3BlUHJpbWUpIHtcbiAgICByZXR1cm4gbGluZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMSArIGxpbmUgJSA0O1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIGRlZmluZWQgYnlcbiAqIHBvaW50IHBhaXJzIChzMSxzMikgYW5kIChmMSxmMikuXG4gKi9cbklHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoczEsIHMyLCBmMSwgZjIpIHtcbiAgaWYgKGYyID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnRlcnNlY3Rpb24yKHMxLCBzMiwgZjEpO1xuICB9XG5cbiAgdmFyIHgxID0gczEueDtcbiAgdmFyIHkxID0gczEueTtcbiAgdmFyIHgyID0gczIueDtcbiAgdmFyIHkyID0gczIueTtcbiAgdmFyIHgzID0gZjEueDtcbiAgdmFyIHkzID0gZjEueTtcbiAgdmFyIHg0ID0gZjIueDtcbiAgdmFyIHk0ID0gZjIueTtcbiAgdmFyIHggPSB2b2lkIDAsXG4gICAgICB5ID0gdm9pZCAwOyAvLyBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgdmFyIGExID0gdm9pZCAwLFxuICAgICAgYTIgPSB2b2lkIDAsXG4gICAgICBiMSA9IHZvaWQgMCxcbiAgICAgIGIyID0gdm9pZCAwLFxuICAgICAgYzEgPSB2b2lkIDAsXG4gICAgICBjMiA9IHZvaWQgMDsgLy8gY29lZmZpY2llbnRzIG9mIGxpbmUgZXFucy5cbiAgdmFyIGRlbm9tID0gdm9pZCAwO1xuXG4gIGExID0geTIgLSB5MTtcbiAgYjEgPSB4MSAtIHgyO1xuICBjMSA9IHgyICogeTEgLSB4MSAqIHkyOyAvLyB7IGExKnggKyBiMSp5ICsgYzEgPSAwIGlzIGxpbmUgMSB9XG5cbiAgYTIgPSB5NCAtIHkzO1xuICBiMiA9IHgzIC0geDQ7XG4gIGMyID0geDQgKiB5MyAtIHgzICogeTQ7IC8vIHsgYTIqeCArIGIyKnkgKyBjMiA9IDAgaXMgbGluZSAyIH1cblxuICBkZW5vbSA9IGExICogYjIgLSBhMiAqIGIxO1xuXG4gIGlmIChkZW5vbSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgeCA9IChiMSAqIGMyIC0gYjIgKiBjMSkgLyBkZW5vbTtcbiAgeSA9IChhMiAqIGMxIC0gYTEgKiBjMikgLyBkZW5vbTtcblxuICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBmaW5kcyBhbmQgcmV0dXJucyB0aGUgYW5nbGUgb2YgdGhlIHZlY3RvciBmcm9tIHRoZSArIHgtYXhpc1xuICogaW4gY2xvY2t3aXNlIGRpcmVjdGlvbiAoY29tcGF0aWJsZSB3LyBKYXZhIGNvb3JkaW5hdGUgc3lzdGVtISkuXG4gKi9cbklHZW9tZXRyeS5hbmdsZU9mVmVjdG9yID0gZnVuY3Rpb24gKEN4LCBDeSwgTngsIE55KSB7XG4gIHZhciBDX2FuZ2xlID0gdm9pZCAwO1xuXG4gIGlmIChDeCAhPT0gTngpIHtcbiAgICBDX2FuZ2xlID0gTWF0aC5hdGFuKChOeSAtIEN5KSAvIChOeCAtIEN4KSk7XG5cbiAgICBpZiAoTnggPCBDeCkge1xuICAgICAgQ19hbmdsZSArPSBNYXRoLlBJO1xuICAgIH0gZWxzZSBpZiAoTnkgPCBDeSkge1xuICAgICAgQ19hbmdsZSArPSB0aGlzLlRXT19QSTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnkgPCBDeSkge1xuICAgIENfYW5nbGUgPSB0aGlzLk9ORV9BTkRfSEFMRl9QSTsgLy8gMjcwIGRlZ3JlZXNcbiAgfSBlbHNlIHtcbiAgICBDX2FuZ2xlID0gdGhpcy5IQUxGX1BJOyAvLyA5MCBkZWdyZWVzXG4gIH1cblxuICByZXR1cm4gQ19hbmdsZTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHR3byBsaW5lIHNlZ21lbnRzIChvbmUgd2l0aCBwb2ludFxuICogcDEgYW5kIHAyLCB0aGUgb3RoZXIgd2l0aCBwb2ludCBwMyBhbmQgcDQpIGludGVyc2VjdCBhdCBhIHBvaW50IG90aGVyXG4gKiB0aGFuIHRoZXNlIHBvaW50cy5cbiAqL1xuSUdlb21ldHJ5LmRvSW50ZXJzZWN0ID0gZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG4gIHZhciBhID0gcDEueDtcbiAgdmFyIGIgPSBwMS55O1xuICB2YXIgYyA9IHAyLng7XG4gIHZhciBkID0gcDIueTtcbiAgdmFyIHAgPSBwMy54O1xuICB2YXIgcSA9IHAzLnk7XG4gIHZhciByID0gcDQueDtcbiAgdmFyIHMgPSBwNC55O1xuICB2YXIgZGV0ID0gKGMgLSBhKSAqIChzIC0gcSkgLSAociAtIHApICogKGQgLSBiKTtcblxuICBpZiAoZGV0ID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBsYW1iZGEgPSAoKHMgLSBxKSAqIChyIC0gYSkgKyAocCAtIHIpICogKHMgLSBiKSkgLyBkZXQ7XG4gICAgdmFyIGdhbW1hID0gKChiIC0gZCkgKiAociAtIGEpICsgKGMgLSBhKSAqIChzIC0gYikpIC8gZGV0O1xuICAgIHJldHVybiAwIDwgbGFtYmRhICYmIGxhbWJkYSA8IDEgJiYgMCA8IGdhbW1hICYmIGdhbW1hIDwgMTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgYW5kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiBcbiAqIGEgbGluZSBzZWdtZW50IGFuZCBhIGNpcmNsZS5cbiAqL1xuSUdlb21ldHJ5LmZpbmRDaXJjbGVMaW5lSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIChFeCwgRXksIEx4LCBMeSwgQ3gsIEN5LCByKSB7XG5cbiAgLy8gRSBpcyB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIHJheSxcbiAgLy8gTCBpcyB0aGUgZW5kIHBvaW50IG9mIHRoZSByYXksXG4gIC8vIEMgaXMgdGhlIGNlbnRlciBvZiBzcGhlcmUgeW91J3JlIHRlc3RpbmcgYWdhaW5zdFxuICAvLyByIGlzIHRoZSByYWRpdXMgb2YgdGhhdCBzcGhlcmVcblxuICAvLyBDb21wdXRlOlxuICAvLyBkID0gTCAtIEUgKCBEaXJlY3Rpb24gdmVjdG9yIG9mIHJheSwgZnJvbSBzdGFydCB0byBlbmQgKVxuICAvLyBmID0gRSAtIEMgKCBWZWN0b3IgZnJvbSBjZW50ZXIgc3BoZXJlIHRvIHJheSBzdGFydCApXG5cbiAgLy8gVGhlbiB0aGUgaW50ZXJzZWN0aW9uIGlzIGZvdW5kIGJ5Li5cbiAgLy8gUCA9IEUgKyB0ICogZFxuICAvLyBUaGlzIGlzIGEgcGFyYW1ldHJpYyBlcXVhdGlvbjpcbiAgLy8gUHggPSBFeCArIHRkeFxuICAvLyBQeSA9IEV5ICsgdGR5XG5cbiAgLy8gZ2V0IGEsIGIsIGMgdmFsdWVzXG4gIHZhciBhID0gKEx4IC0gRXgpICogKEx4IC0gRXgpICsgKEx5IC0gRXkpICogKEx5IC0gRXkpO1xuICB2YXIgYiA9IDIgKiAoKEV4IC0gQ3gpICogKEx4IC0gRXgpICsgKEV5IC0gQ3kpICogKEx5IC0gRXkpKTtcbiAgdmFyIGMgPSAoRXggLSBDeCkgKiAoRXggLSBDeCkgKyAoRXkgLSBDeSkgKiAoRXkgLSBDeSkgLSByICogcjtcblxuICAvLyBnZXQgZGlzY3JpbWluYW50XG4gIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gIGlmIChkaXNjID49IDApIHtcbiAgICAvLyBpbnNlcnQgaW50byBxdWFkcmF0aWMgZm9ybXVsYVxuICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiICogYiAtIDQgKiBhICogYykpIC8gKDIgKiBhKTtcbiAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYiAqIGIgLSA0ICogYSAqIGMpKSAvICgyICogYSk7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBudWxsO1xuICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgIC8vIHQxIGlzIHRoZSBpbnRlcnNlY3Rpb24sIGFuZCBpdCdzIGNsb3NlciB0aGFuIHQyXG4gICAgICAvLyAoc2luY2UgdDEgdXNlcyAtYiAtIGRpc2NyaW1pbmFudClcbiAgICAgIC8vIEltcGFsZSwgUG9rZVxuICAgICAgcmV0dXJuIFt0MV07XG4gICAgfVxuXG4gICAgLy8gaGVyZSB0MSBkaWRuJ3QgaW50ZXJzZWN0IHNvIHdlIGFyZSBlaXRoZXIgc3RhcnRlZFxuICAgIC8vIGluc2lkZSB0aGUgc3BoZXJlIG9yIGNvbXBsZXRlbHkgcGFzdCBpdFxuICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgIC8vIEV4aXRXb3VuZFxuICAgICAgcmV0dXJuIFt0Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH0gZWxzZSByZXR1cm4gbnVsbDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBDbGFzcyBDb25zdGFudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFNvbWUgdXNlZnVsIHByZS1jYWxjdWxhdGVkIGNvbnN0YW50c1xuICovXG5JR2VvbWV0cnkuSEFMRl9QSSA9IDAuNSAqIE1hdGguUEk7XG5JR2VvbWV0cnkuT05FX0FORF9IQUxGX1BJID0gMS41ICogTWF0aC5QSTtcbklHZW9tZXRyeS5UV09fUEkgPSAyLjAgKiBNYXRoLlBJO1xuSUdlb21ldHJ5LlRIUkVFX1BJID0gMy4wICogTWF0aC5QSTtcblxubW9kdWxlLmV4cG9ydHMgPSBJR2VvbWV0cnk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBJTWF0aCgpIHt9XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgc2lnbiBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gKi9cbklNYXRoLnNpZ24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuSU1hdGguZmxvb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguY2VpbCh2YWx1ZSkgOiBNYXRoLmZsb29yKHZhbHVlKTtcbn07XG5cbklNYXRoLmNlaWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguZmxvb3IodmFsdWUpIDogTWF0aC5jZWlsKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSU1hdGg7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gSW50ZWdlcigpIHt9XG5cbkludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbkludGVnZXIuTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZWdlcjtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgbm9kZUZyb20gPSBmdW5jdGlvbiBub2RlRnJvbSh2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIG5leHQ6IG51bGwsIHByZXY6IG51bGwgfTtcbn07XG5cbnZhciBhZGQgPSBmdW5jdGlvbiBhZGQocHJldiwgbm9kZSwgbmV4dCwgbGlzdCkge1xuICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgIHByZXYubmV4dCA9IG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC5oZWFkID0gbm9kZTtcbiAgfVxuXG4gIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgbmV4dC5wcmV2ID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LnRhaWwgPSBub2RlO1xuICB9XG5cbiAgbm9kZS5wcmV2ID0gcHJldjtcbiAgbm9kZS5uZXh0ID0gbmV4dDtcblxuICBsaXN0Lmxlbmd0aCsrO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIF9yZW1vdmUgPSBmdW5jdGlvbiBfcmVtb3ZlKG5vZGUsIGxpc3QpIHtcbiAgdmFyIHByZXYgPSBub2RlLnByZXYsXG4gICAgICBuZXh0ID0gbm9kZS5uZXh0O1xuXG5cbiAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIGxpc3QuaGVhZCA9IG5leHQ7XG4gIH1cblxuICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC50YWlsID0gcHJldjtcbiAgfVxuXG4gIG5vZGUucHJldiA9IG5vZGUubmV4dCA9IG51bGw7XG5cbiAgbGlzdC5sZW5ndGgtLTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5rZWRMaXN0KHZhbHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmtlZExpc3QpO1xuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcblxuICAgIGlmICh2YWxzICE9IG51bGwpIHtcbiAgICAgIHZhbHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gX3RoaXMucHVzaCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5rZWRMaXN0LCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUodmFsLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLnByZXYsIG5vZGVGcm9tKHZhbCksIG90aGVyTm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEFmdGVyKHZhbCwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZSwgbm9kZUZyb20odmFsKSwgb3RoZXJOb2RlLm5leHQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydE5vZGVCZWZvcmUobmV3Tm9kZSwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZS5wcmV2LCBuZXdOb2RlLCBvdGhlck5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZUFmdGVyKG5ld05vZGUsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUsIG5ld05vZGUsIG90aGVyTm9kZS5uZXh0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHZhbCkge1xuICAgICAgcmV0dXJuIGFkZCh0aGlzLnRhaWwsIG5vZGVGcm9tKHZhbCksIG51bGwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodmFsKSB7XG4gICAgICByZXR1cm4gYWRkKG51bGwsIG5vZGVGcm9tKHZhbCksIHRoaXMuaGVhZCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUobm9kZSkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUobm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3BOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMuaGVhZCwgdGhpcykudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLmhlYWQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRfb2JqZWN0X2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9vYmplY3RfYXQoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0X29iamVjdF9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRfb2JqZWN0X2F0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4IDw9IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGkgPCBpbmRleCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRMaXN0O1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXHJcbiAqVGhpcyBjbGFzcyBpcyB0aGUgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9pbnQuamF2YSBjbGFzcyBpbiBqZGtcclxuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5LCBwKSB7XG4gIHRoaXMueCA9IG51bGw7XG4gIHRoaXMueSA9IG51bGw7XG4gIGlmICh4ID09IG51bGwgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJyAmJiBwID09IG51bGwpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH0gZWxzZSBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMueCA9IHAueDtcbiAgICB0aGlzLnkgPSBwLnk7XG4gIH1cbn1cblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgcCkge1xuICBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMuc2V0TG9jYXRpb24ocC54LCBwLnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09ICdudW1iZXInICYmIHR5cGVvZiB5ID09ICdudW1iZXInICYmIHAgPT0gbnVsbCkge1xuICAgIC8vaWYgYm90aCBwYXJhbWV0ZXJzIGFyZSBpbnRlZ2VyIGp1c3QgbW92ZSAoeCx5KSBsb2NhdGlvblxuICAgIGlmIChwYXJzZUludCh4KSA9PSB4ICYmIHBhcnNlSW50KHkpID09IHkpIHtcbiAgICAgIHRoaXMubW92ZSh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ID0gTWF0aC5mbG9vcih4ICsgMC41KTtcbiAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoeSArIDAuNSk7XG4gICAgfVxuICB9XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICB0aGlzLnggKz0gZHg7XG4gIHRoaXMueSArPSBkeTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PSBcIlBvaW50XCIpIHtcbiAgICB2YXIgcHQgPSBvYmo7XG4gICAgcmV0dXJuIHRoaXMueCA9PSBwdC54ICYmIHRoaXMueSA9PSBwdC55O1xuICB9XG4gIHJldHVybiB0aGlzID09IG9iajtcbn07XG5cblBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCgpLmNvbnN0cnVjdG9yLm5hbWUgKyBcIlt4PVwiICsgdGhpcy54ICsgXCIseT1cIiArIHRoaXMueSArIFwiXVwiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBSZWN0YW5nbGVEKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy54ID0gMDtcbiAgdGhpcy55ID0gMDtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcblxuICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxufVxuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uICh5KSB7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAoYSkge1xuICBpZiAodGhpcy5nZXRSaWdodCgpIDwgYS54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuZ2V0Qm90dG9tKCkgPCBhLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5nZXRSaWdodCgpIDwgdGhpcy54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuZ2V0Qm90dG9tKCkgPCB0aGlzLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldENlbnRlclggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1pblggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1heFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKSArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRDZW50ZXJZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWluWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWF4WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpICsgdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldEhlaWdodEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodCAvIDI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZUQ7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBVbmlxdWVJREdlbmVyZXRvcigpIHt9XG5cblVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRCA9IDA7XG5cblVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAoVW5pcXVlSURHZW5lcmV0b3IuaXNQcmltaXRpdmUob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKG9iai51bmlxdWVJRCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9iai51bmlxdWVJRDtcbiAgfVxuICBvYmoudW5pcXVlSUQgPSBVbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcoKTtcbiAgVW5pcXVlSURHZW5lcmV0b3IubGFzdElEKys7XG4gIHJldHVybiBvYmoudW5pcXVlSUQ7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGlkID09IG51bGwpIGlkID0gVW5pcXVlSURHZW5lcmV0b3IubGFzdElEO1xuICByZXR1cm4gXCJPYmplY3QjXCIgKyBpZCArIFwiXCI7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoYXJnKTtcbiAgcmV0dXJuIGFyZyA9PSBudWxsIHx8IHR5cGUgIT0gXCJvYmplY3RcIiAmJiB0eXBlICE9IFwiZnVuY3Rpb25cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pcXVlSURHZW5lcmV0b3I7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIExHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuZnVuY3Rpb24gTGF5b3V0KGlzUmVtb3RlVXNlKSB7XG4gIEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvL0xheW91dCBRdWFsaXR5OiAwOmRyYWZ0LCAxOmRlZmF1bHQsIDI6cHJvb2ZcbiAgdGhpcy5sYXlvdXRRdWFsaXR5ID0gTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFk7XG4gIC8vV2hldGhlciBsYXlvdXQgc2hvdWxkIGNyZWF0ZSBiZW5kcG9pbnRzIGFzIG5lZWRlZCBvciBub3RcbiAgdGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRDtcbiAgLy9XaGV0aGVyIGxheW91dCBzaG91bGQgYmUgaW5jcmVtZW50YWwgb3Igbm90XG4gIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgLy9XaGV0aGVyIHdlIGFuaW1hdGUgZnJvbSBiZWZvcmUgdG8gYWZ0ZXIgbGF5b3V0IG5vZGUgcG9zaXRpb25zXG4gIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAvL1doZXRoZXIgd2UgYW5pbWF0ZSB0aGUgbGF5b3V0IHByb2Nlc3Mgb3Igbm90XG4gIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gIC8vTnVtYmVyIGl0ZXJhdGlvbnMgdGhhdCBzaG91bGQgYmUgZG9uZSBiZXR3ZWVuIHR3byBzdWNjZXNzaXZlIGFuaW1hdGlvbnNcbiAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAvKipcclxuICAgKiBXaGV0aGVyIG9yIG5vdCBsZWFmIG5vZGVzIChub24tY29tcG91bmQgbm9kZXMpIGFyZSBvZiB1bmlmb3JtIHNpemVzLiBXaGVuXHJcbiAgICogdGhleSBhcmUsIGJvdGggc3ByaW5nIGFuZCByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gdHdvIGxlYWYgbm9kZXMgY2FuIGJlXHJcbiAgICogY2FsY3VsYXRlZCB3aXRob3V0IHRoZSBleHBlbnNpdmUgY2xpcHBpbmcgcG9pbnQgY2FsY3VsYXRpb25zLCByZXN1bHRpbmdcclxuICAgKiBpbiBtYWpvciBzcGVlZC11cC5cclxuICAgKi9cbiAgdGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTO1xuICAvKipcclxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW9uIG9mIGJlbmRwb2ludHMgYnkgdXNpbmcgZHVtbXkgbm9kZXMgYW5kIGVkZ2VzLlxyXG4gICAqIE1hcHMgYW4gTEVkZ2UgdG8gaXRzIGR1bW15IGJlbmRwb2ludCBwYXRoLlxyXG4gICAqL1xuICB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMgPSBuZXcgTWFwKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuICB0aGlzLmlzU3ViTGF5b3V0ID0gZmFsc2U7XG4gIHRoaXMuaXNSZW1vdGVVc2UgPSBmYWxzZTtcblxuICBpZiAoaXNSZW1vdGVVc2UgIT0gbnVsbCkge1xuICAgIHRoaXMuaXNSZW1vdGVVc2UgPSBpc1JlbW90ZVVzZTtcbiAgfVxufVxuXG5MYXlvdXQuUkFORE9NX1NFRUQgPSAxO1xuXG5MYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXI7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3R3JhcGggPSBmdW5jdGlvbiAodkdyYXBoKSB7XG4gIHJldHVybiBuZXcgTEdyYXBoKG51bGwsIHRoaXMuZ3JhcGhNYW5hZ2VyLCB2R3JhcGgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XG4gIHJldHVybiBuZXcgTE5vZGUodGhpcy5ncmFwaE1hbmFnZXIsIHZOb2RlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IExFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuY2hlY2tMYXlvdXRTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpID09IG51bGwgfHwgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCkubGVuZ3RoID09IDAgfHwgdGhpcy5ncmFwaE1hbmFnZXIuaW5jbHVkZXNJbnZhbGlkRWRnZSgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5ydW5MYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnRpbGluZ1ByZUxheW91dCkge1xuICAgIHRoaXMudGlsaW5nUHJlTGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmluaXRQYXJhbWV0ZXJzKCk7XG4gIHZhciBpc0xheW91dFN1Y2Nlc3NmdWxsO1xuXG4gIGlmICh0aGlzLmNoZWNrTGF5b3V0U3VjY2VzcygpKSB7XG4gICAgaXNMYXlvdXRTdWNjZXNzZnVsbCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGlzTGF5b3V0U3VjY2Vzc2Z1bGwgPSB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaWYgKExheW91dENvbnN0YW50cy5BTklNQVRFID09PSAnZHVyaW5nJykge1xuICAgIC8vIElmIHRoaXMgaXMgYSAnZHVyaW5nJyBsYXlvdXQgYW5pbWF0aW9uLiBMYXlvdXQgaXMgbm90IGZpbmlzaGVkIHlldC4gXG4gICAgLy8gV2UgbmVlZCB0byBwZXJmb3JtIHRoZXNlIGluIGluZGV4LmpzIHdoZW4gbGF5b3V0IGlzIHJlYWxseSBmaW5pc2hlZC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNMYXlvdXRTdWNjZXNzZnVsbCkge1xuICAgIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgICAgdGhpcy5kb1Bvc3RMYXlvdXQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50aWxpbmdQb3N0TGF5b3V0KSB7XG4gICAgdGhpcy50aWxpbmdQb3N0TGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSB0cnVlO1xuXG4gIHJldHVybiBpc0xheW91dFN1Y2Nlc3NmdWxsO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGFmdGVyIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmRvUG9zdExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgLy9hc3NlcnQgIWlzU3ViTGF5b3V0IDogXCJTaG91bGQgbm90IGJlIGNhbGxlZCBvbiBzdWItbGF5b3V0IVwiO1xuICAvLyBQcm9wYWdhdGUgZ2VvbWV0cmljIGNoYW5nZXMgdG8gdi1sZXZlbCBvYmplY3RzXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHRoaXMudHJhbnNmb3JtKCk7XG4gIH1cbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBnZW9tZXRyeSBvZiB0aGUgdGFyZ2V0IGdyYXBoIGFjY29yZGluZyB0b1xyXG4gKiBjYWxjdWxhdGVkIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLnVwZGF0ZTIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHVwZGF0ZSBiZW5kIHBvaW50c1xuICBpZiAodGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkKSB7XG4gICAgdGhpcy5jcmVhdGVCZW5kcG9pbnRzRnJvbUR1bW15Tm9kZXMoKTtcblxuICAgIC8vIHJlc2V0IGFsbCBlZGdlcywgc2luY2UgdGhlIHRvcG9sb2d5IGhhcyBjaGFuZ2VkXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICB9XG5cbiAgLy8gcGVyZm9ybSBlZGdlLCBub2RlIGFuZCByb290IHVwZGF0ZXMgaWYgbGF5b3V0IGlzIG5vdCBjYWxsZWRcbiAgLy8gcmVtb3RlbHlcbiAgaWYgKCF0aGlzLmlzUmVtb3RlVXNlKSB7XG4gICAgLy8gdXBkYXRlIGFsbCBlZGdlc1xuICAgIHZhciBlZGdlO1xuICAgIHZhciBhbGxFZGdlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuICAgICAgLy8gICAgICB0aGlzLnVwZGF0ZShlZGdlKTtcbiAgICB9XG5cbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgbm9kZXNcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAvLyAgICAgIHRoaXMudXBkYXRlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSByb290IGdyYXBoXG4gICAgdGhpcy51cGRhdGUodGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHRoaXMudXBkYXRlMigpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgdmFyIG5vZGUgPSBvYmo7XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICAvLyBzaW5jZSBub2RlIGlzIGNvbXBvdW5kLCByZWN1cnNpdmVseSB1cGRhdGUgY2hpbGQgbm9kZXNcbiAgICAgIHZhciBub2RlcyA9IG5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGUobm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBsLWxldmVsIG5vZGUgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdi1sZXZlbCBncmFwaCBvYmplY3QsXG4gICAgLy8gdGhlbiBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHYtbGV2ZWwgbm9kZSBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG4gICAgaWYgKG5vZGUudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2Tm9kZSA9IG5vZGUudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZOb2RlLnVwZGF0ZShub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICB2YXIgZWRnZSA9IG9iajtcbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBlZGdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIGVkZ2UgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuXG4gICAgaWYgKGVkZ2UudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2RWRnZSA9IGVkZ2UudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZFZGdlLnVwZGF0ZShlZGdlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEdyYXBoKSB7XG4gICAgdmFyIGdyYXBoID0gb2JqO1xuICAgIC8vIGlmIHRoZSBsLWxldmVsIGdyYXBoIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIG9iamVjdCBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG5cbiAgICBpZiAoZ3JhcGgudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2R3JhcGggPSBncmFwaC52R3JhcGhPYmplY3Q7XG5cbiAgICAgIC8vIGNhbGwgdGhlIHVwZGF0ZSBtZXRob2Qgb2YgdGhlIGludGVyZmFjZVxuICAgICAgdkdyYXBoLnVwZGF0ZShncmFwaCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZXQgYWxsIGxheW91dCBwYXJhbWV0ZXJzIHRvIGRlZmF1bHQgdmFsdWVzXHJcbiAqIGRldGVybWluZWQgYXQgY29tcGlsZSB0aW1lLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgIHRoaXMubGF5b3V0UXVhbGl0eSA9IExheW91dENvbnN0YW50cy5RVUFMSVRZO1xuICAgIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gICAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAgIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgICB0aGlzLmNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICAgIHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUztcbiAgfVxuXG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCkge1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBmYWxzZTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAobmV3TGVmdFRvcCkge1xuICBpZiAobmV3TGVmdFRvcCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRyYW5zZm9ybShuZXcgUG9pbnREKDAsIDApKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgYSB0cmFuc2Zvcm1hdGlvbiBvYmplY3QgKGZyb20gRWNsaXBzZSB0byBsYXlvdXQpLiBXaGVuIGFuXG4gICAgLy8gaW52ZXJzZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCwgd2UgZ2V0IHVwcGVyLWxlZnQgY29vcmRpbmF0ZSBvZiB0aGVcbiAgICAvLyBkcmF3aW5nIG9yIHRoZSByb290IGdyYXBoIGF0IGdpdmVuIGlucHV0IGNvb3JkaW5hdGUgKHNvbWUgbWFyZ2luc1xuICAgIC8vIGFscmVhZHkgaW5jbHVkZWQgaW4gY2FsY3VsYXRpb24gb2YgbGVmdC10b3ApLlxuXG4gICAgdmFyIHRyYW5zID0gbmV3IFRyYW5zZm9ybSgpO1xuICAgIHZhciBsZWZ0VG9wID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLnVwZGF0ZUxlZnRUb3AoKTtcblxuICAgIGlmIChsZWZ0VG9wICE9IG51bGwpIHtcbiAgICAgIHRyYW5zLnNldFdvcmxkT3JnWChuZXdMZWZ0VG9wLngpO1xuICAgICAgdHJhbnMuc2V0V29ybGRPcmdZKG5ld0xlZnRUb3AueSk7XG5cbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1gobGVmdFRvcC54KTtcbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1kobGVmdFRvcC55KTtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICAgICAgdmFyIG5vZGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnRyYW5zZm9ybSh0cmFucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnBvc2l0aW9uTm9kZXNSYW5kb21seSA9IGZ1bmN0aW9uIChncmFwaCkge1xuXG4gIGlmIChncmFwaCA9PSB1bmRlZmluZWQpIHtcbiAgICAvL2Fzc2VydCAhdGhpcy5pbmNyZW1lbnRhbDtcbiAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSh0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKSk7XG4gICAgdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCkudXBkYXRlQm91bmRzKHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsTm9kZTtcbiAgICB2YXIgY2hpbGRHcmFwaDtcblxuICAgIHZhciBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNoaWxkR3JhcGggPSBsTm9kZS5nZXRDaGlsZCgpO1xuXG4gICAgICBpZiAoY2hpbGRHcmFwaCA9PSBudWxsKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRHcmFwaC5nZXROb2RlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KGNoaWxkR3JhcGgpO1xuICAgICAgICBsTm9kZS51cGRhdGVCb3VuZHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbGlzdCBvZiB0cmVlcyB3aGVyZSBlYWNoIHRyZWUgaXMgcmVwcmVzZW50ZWQgYXMgYVxyXG4gKiBsaXN0IG9mIGwtbm9kZXMuIFRoZSBtZXRob2QgcmV0dXJucyBhIGxpc3Qgb2Ygc2l6ZSAwIHdoZW46XHJcbiAqIC0gVGhlIGdyYXBoIGlzIG5vdCBmbGF0IG9yXHJcbiAqIC0gT25lIG9mIHRoZSBjb21wb25lbnQocykgb2YgdGhlIGdyYXBoIGlzIG5vdCBhIHRyZWUuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5nZXRGbGF0Rm9yZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZmxhdEZvcmVzdCA9IFtdO1xuICB2YXIgaXNGb3Jlc3QgPSB0cnVlO1xuXG4gIC8vIFF1aWNrIHJlZmVyZW5jZSBmb3IgYWxsIG5vZGVzIGluIHRoZSBncmFwaCBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aFxuICAvLyB0aGlzIGxheW91dC4gVGhlIGxpc3Qgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcblxuICAvLyBGaXJzdCBiZSBzdXJlIHRoYXQgdGhlIGdyYXBoIGlzIGZsYXRcbiAgdmFyIGlzRmxhdCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhbGxOb2Rlc1tpXS5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIGlzRmxhdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiBlbXB0eSBmb3Jlc3QgaWYgdGhlIGdyYXBoIGlzIG5vdCBmbGF0LlxuICBpZiAoIWlzRmxhdCkge1xuICAgIHJldHVybiBmbGF0Rm9yZXN0O1xuICB9XG5cbiAgLy8gUnVuIEJGUyBmb3IgZWFjaCBjb21wb25lbnQgb2YgdGhlIGdyYXBoLlxuXG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgdG9CZVZpc2l0ZWQgPSBbXTtcbiAgdmFyIHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gIHZhciB1blByb2Nlc3NlZE5vZGVzID0gW107XG5cbiAgdW5Qcm9jZXNzZWROb2RlcyA9IHVuUHJvY2Vzc2VkTm9kZXMuY29uY2F0KGFsbE5vZGVzKTtcblxuICAvLyBFYWNoIGl0ZXJhdGlvbiBvZiB0aGlzIGxvb3AgZmluZHMgYSBjb21wb25lbnQgb2YgdGhlIGdyYXBoIGFuZFxuICAvLyBkZWNpZGVzIHdoZXRoZXIgaXQgaXMgYSB0cmVlIG9yIG5vdC4gSWYgaXQgaXMgYSB0cmVlLCBhZGRzIGl0IHRvIHRoZVxuICAvLyBmb3Jlc3QgYW5kIGNvbnRpbnVlZCB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudC5cblxuICB3aGlsZSAodW5Qcm9jZXNzZWROb2Rlcy5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgdG9CZVZpc2l0ZWQucHVzaCh1blByb2Nlc3NlZE5vZGVzWzBdKTtcblxuICAgIC8vIFN0YXJ0IHRoZSBCRlMuIEVhY2ggaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCB2aXNpdHMgYSBub2RlIGluIGFcbiAgICAvLyBCRlMgbWFubmVyLlxuICAgIHdoaWxlICh0b0JlVmlzaXRlZC5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgICAvL3Bvb2wgb3BlcmF0aW9uXG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB0b0JlVmlzaXRlZFswXTtcbiAgICAgIHRvQmVWaXNpdGVkLnNwbGljZSgwLCAxKTtcbiAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICAgIHZhciBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvckVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2VzW2ldLmdldE90aGVyRW5kKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyBJZiBCRlMgaXMgbm90IGdyb3dpbmcgZnJvbSB0aGlzIG5laWdoYm9yLlxuICAgICAgICBpZiAocGFyZW50cy5nZXQoY3VycmVudE5vZGUpICE9IGN1cnJlbnROZWlnaGJvcikge1xuICAgICAgICAgIC8vIFdlIGhhdmVuJ3QgcHJldmlvdXNseSB2aXNpdGVkIHRoaXMgbmVpZ2hib3IuXG4gICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgICAgICB0b0JlVmlzaXRlZC5wdXNoKGN1cnJlbnROZWlnaGJvcik7XG4gICAgICAgICAgICBwYXJlbnRzLnNldChjdXJyZW50TmVpZ2hib3IsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBwcmV2aW91c2x5IHZpc2l0ZWQgdGhpcyBuZWlnaGJvciBhbmRcbiAgICAgICAgICAvLyB0aGlzIG5laWdoYm9yIGlzIG5vdCBwYXJlbnQgb2YgY3VycmVudE5vZGUsIGdpdmVuXG4gICAgICAgICAgLy8gZ3JhcGggY29udGFpbnMgYSBjb21wb25lbnQgdGhhdCBpcyBub3QgdHJlZSwgaGVuY2VcbiAgICAgICAgICAvLyBpdCBpcyBub3QgYSBmb3Jlc3QuXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlzRm9yZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGdyYXBoIGNvbnRhaW5zIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IGEgdHJlZS4gRW1wdHlcbiAgICAvLyBwcmV2aW91c2x5IGZvdW5kIHRyZWVzLiBUaGUgbWV0aG9kIHdpbGwgZW5kLlxuICAgIGlmICghaXNGb3Jlc3QpIHtcbiAgICAgIGZsYXRGb3Jlc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gU2F2ZSBjdXJyZW50bHkgdmlzaXRlZCBub2RlcyBhcyBhIHRyZWUgaW4gb3VyIGZvcmVzdC4gUmVzZXRcbiAgICAvLyB2aXNpdGVkIGFuZCBwYXJlbnRzIGxpc3RzLiBDb250aW51ZSB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudCBvZlxuICAgIC8vIHRoZSBncmFwaCwgaWYgYW55LlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdGVtcCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmlzaXRlZCkpO1xuICAgICAgICBmbGF0Rm9yZXN0LnB1c2godGVtcCk7XG4gICAgICAgIC8vZmxhdEZvcmVzdCA9IGZsYXRGb3Jlc3QuY29uY2F0KHRlbXApO1xuICAgICAgICAvL3VuUHJvY2Vzc2VkTm9kZXMucmVtb3ZlQWxsKHZpc2l0ZWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0ZW1wW2ldO1xuICAgICAgICAgIHZhciBpbmRleCA9IHVuUHJvY2Vzc2VkTm9kZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHVuUHJvY2Vzc2VkTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBmbGF0Rm9yZXN0O1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgZHVtbXkgbm9kZXMgKGFuIGwtbGV2ZWwgbm9kZSB3aXRoIG1pbmltYWwgZGltZW5zaW9ucylcclxuICogZm9yIHRoZSBnaXZlbiBlZGdlIChvbmUgcGVyIGJlbmRwb2ludCkuIFRoZSBleGlzdGluZyBsLWxldmVsIHN0cnVjdHVyZVxyXG4gKiBpcyB1cGRhdGVkIGFjY29yZGluZ2x5LlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgZHVtbXlOb2RlcyA9IFtdO1xuICB2YXIgcHJldiA9IGVkZ2Uuc291cmNlO1xuXG4gIHZhciBncmFwaCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcihlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZS5iZW5kcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gY3JlYXRlIG5ldyBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15Tm9kZSA9IHRoaXMubmV3Tm9kZShudWxsKTtcbiAgICBkdW1teU5vZGUuc2V0UmVjdChuZXcgUG9pbnQoMCwgMCksIG5ldyBEaW1lbnNpb24oMSwgMSkpO1xuXG4gICAgZ3JhcGguYWRkKGR1bW15Tm9kZSk7XG5cbiAgICAvLyBjcmVhdGUgbmV3IGR1bW15IGVkZ2UgYmV0d2VlbiBwcmV2IGFuZCBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5hZGQoZHVtbXlFZGdlLCBwcmV2LCBkdW1teU5vZGUpO1xuXG4gICAgZHVtbXlOb2Rlcy5hZGQoZHVtbXlOb2RlKTtcbiAgICBwcmV2ID0gZHVtbXlOb2RlO1xuICB9XG5cbiAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGR1bW15RWRnZSwgcHJldiwgZWRnZS50YXJnZXQpO1xuXG4gIHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5zZXQoZWRnZSwgZHVtbXlOb2Rlcyk7XG5cbiAgLy8gcmVtb3ZlIHJlYWwgZWRnZSBmcm9tIGdyYXBoIG1hbmFnZXIgaWYgaXQgaXMgaW50ZXItZ3JhcGhcbiAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKCkpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gIH1cbiAgLy8gZWxzZSwgcmVtb3ZlIHRoZSBlZGdlIGZyb20gdGhlIGN1cnJlbnQgZ3JhcGhcbiAgZWxzZSB7XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gIHJldHVybiBkdW1teU5vZGVzO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYmVuZHBvaW50cyBmb3IgZWRnZXMgZnJvbSB0aGUgZHVtbXkgbm9kZXNcclxuICogYXQgbC1sZXZlbC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmNyZWF0ZUJlbmRwb2ludHNGcm9tRHVtbXlOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIGVkZ2VzID0gZWRnZXMuY29uY2F0KHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCkpO1xuICBlZGdlcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5lZGdlVG9EdW1teU5vZGVzLmtleXMoKSkpLmNvbmNhdChlZGdlcyk7XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBlZGdlcy5sZW5ndGg7IGsrKykge1xuICAgIHZhciBsRWRnZSA9IGVkZ2VzW2tdO1xuXG4gICAgaWYgKGxFZGdlLmJlbmRwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMuZ2V0KGxFZGdlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkdW1teU5vZGUgPSBwYXRoW2ldO1xuICAgICAgICB2YXIgcCA9IG5ldyBQb2ludEQoZHVtbXlOb2RlLmdldENlbnRlclgoKSwgZHVtbXlOb2RlLmdldENlbnRlclkoKSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJlbmRwb2ludCdzIGxvY2F0aW9uIGFjY29yZGluZyB0byBkdW1teSBub2RlXG4gICAgICAgIHZhciBlYnAgPSBsRWRnZS5iZW5kcG9pbnRzLmdldChpKTtcbiAgICAgICAgZWJwLnggPSBwLng7XG4gICAgICAgIGVicC55ID0gcC55O1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZHVtbXkgbm9kZSwgZHVtbXkgZWRnZXMgaW5jaWRlbnQgd2l0aCB0aGlzXG4gICAgICAgIC8vIGR1bW15IG5vZGUgaXMgYWxzbyByZW1vdmVkICh3aXRoaW4gdGhlIHJlbW92ZSBtZXRob2QpXG4gICAgICAgIGR1bW15Tm9kZS5nZXRPd25lcigpLnJlbW92ZShkdW1teU5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdGhlIHJlYWwgZWRnZSB0byBncmFwaFxuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGxFZGdlLCBsRWRnZS5zb3VyY2UsIGxFZGdlLnRhcmdldCk7XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQudHJhbnNmb3JtID0gZnVuY3Rpb24gKHNsaWRlclZhbHVlLCBkZWZhdWx0VmFsdWUsIG1pbkRpdiwgbWF4TXVsKSB7XG4gIGlmIChtaW5EaXYgIT0gdW5kZWZpbmVkICYmIG1heE11bCAhPSB1bmRlZmluZWQpIHtcbiAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoc2xpZGVyVmFsdWUgPD0gNTApIHtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IGRlZmF1bHRWYWx1ZSAvIG1pbkRpdjtcbiAgICAgIHZhbHVlIC09IChkZWZhdWx0VmFsdWUgLSBtaW5WYWx1ZSkgLyA1MCAqICg1MCAtIHNsaWRlclZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heFZhbHVlID0gZGVmYXVsdFZhbHVlICogbWF4TXVsO1xuICAgICAgdmFsdWUgKz0gKG1heFZhbHVlIC0gZGVmYXVsdFZhbHVlKSAvIDUwICogKHNsaWRlclZhbHVlIC0gNTApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSwgYjtcblxuICAgIGlmIChzbGlkZXJWYWx1ZSA8PSA1MCkge1xuICAgICAgYSA9IDkuMCAqIGRlZmF1bHRWYWx1ZSAvIDUwMC4wO1xuICAgICAgYiA9IGRlZmF1bHRWYWx1ZSAvIDEwLjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSA5LjAgKiBkZWZhdWx0VmFsdWUgLyA1MC4wO1xuICAgICAgYiA9IC04ICogZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhICogc2xpZGVyVmFsdWUgKyBiO1xuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgZmluZHMgYW5kIHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gbm9kZXMsIGFzc3VtaW5nXHJcbiAqIHRoYXQgdGhlIGdpdmVuIG5vZGVzIGZvcm0gYSB0cmVlIGluIHRoZW1zZWx2ZXMuXHJcbiAqL1xuTGF5b3V0LmZpbmRDZW50ZXJPZlRyZWUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgbGlzdCA9IGxpc3QuY29uY2F0KG5vZGVzKTtcblxuICB2YXIgcmVtb3ZlZE5vZGVzID0gW107XG4gIHZhciByZW1haW5pbmdEZWdyZWVzID0gbmV3IE1hcCgpO1xuICB2YXIgZm91bmRDZW50ZXIgPSBmYWxzZTtcbiAgdmFyIGNlbnRlck5vZGUgPSBudWxsO1xuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PSAxIHx8IGxpc3QubGVuZ3RoID09IDIpIHtcbiAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgY2VudGVyTm9kZSA9IGxpc3RbMF07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGxpc3RbaV07XG4gICAgdmFyIGRlZ3JlZSA9IG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpLnNpemU7XG4gICAgcmVtYWluaW5nRGVncmVlcy5zZXQobm9kZSwgbm9kZS5nZXROZWlnaGJvcnNMaXN0KCkuc2l6ZSk7XG5cbiAgICBpZiAoZGVncmVlID09IDEpIHtcbiAgICAgIHJlbW92ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZW1wTGlzdCA9IFtdO1xuICB0ZW1wTGlzdCA9IHRlbXBMaXN0LmNvbmNhdChyZW1vdmVkTm9kZXMpO1xuXG4gIHdoaWxlICghZm91bmRDZW50ZXIpIHtcbiAgICB2YXIgdGVtcExpc3QyID0gW107XG4gICAgdGVtcExpc3QyID0gdGVtcExpc3QyLmNvbmNhdCh0ZW1wTGlzdCk7XG4gICAgdGVtcExpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBsaXN0W2ldO1xuXG4gICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2Yobm9kZSk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvdXJzID0gbm9kZS5nZXROZWlnaGJvcnNMaXN0KCk7XG5cbiAgICAgIG5laWdoYm91cnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3VyKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaW5kZXhPZihuZWlnaGJvdXIpIDwgMCkge1xuICAgICAgICAgIHZhciBvdGhlckRlZ3JlZSA9IHJlbWFpbmluZ0RlZ3JlZXMuZ2V0KG5laWdoYm91cik7XG4gICAgICAgICAgdmFyIG5ld0RlZ3JlZSA9IG90aGVyRGVncmVlIC0gMTtcblxuICAgICAgICAgIGlmIChuZXdEZWdyZWUgPT0gMSkge1xuICAgICAgICAgICAgdGVtcExpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbWFpbmluZ0RlZ3JlZXMuc2V0KG5laWdoYm91ciwgbmV3RGVncmVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzLmNvbmNhdCh0ZW1wTGlzdCk7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMSB8fCBsaXN0Lmxlbmd0aCA9PSAyKSB7XG4gICAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgICBjZW50ZXJOb2RlID0gbGlzdFswXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2VudGVyTm9kZTtcbn07XG5cbi8qKlxyXG4gKiBEdXJpbmcgdGhlIGNvYXJzZW5pbmcgcHJvY2VzcywgdGhpcyBsYXlvdXQgbWF5IGJlIHJlZmVyZW5jZWQgYnkgdHdvIGdyYXBoIG1hbmFnZXJzXHJcbiAqIHRoaXMgc2V0dGVyIGZ1bmN0aW9uIGdyYW50cyBhY2Nlc3MgdG8gY2hhbmdlIHRoZSBjdXJyZW50bHkgYmVpbmcgdXNlZCBncmFwaCBtYW5hZ2VyXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5zZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoZ20pIHtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFJhbmRvbVNlZWQoKSB7fVxuLy8gYWRhcHRlZCBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTkzMDM3MjVcblJhbmRvbVNlZWQuc2VlZCA9IDE7XG5SYW5kb21TZWVkLnggPSAwO1xuXG5SYW5kb21TZWVkLm5leHREb3VibGUgPSBmdW5jdGlvbiAoKSB7XG4gIFJhbmRvbVNlZWQueCA9IE1hdGguc2luKFJhbmRvbVNlZWQuc2VlZCsrKSAqIDEwMDAwO1xuICByZXR1cm4gUmFuZG9tU2VlZC54IC0gTWF0aC5mbG9vcihSYW5kb21TZWVkLngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21TZWVkO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oeCwgeSkge1xuICB0aGlzLmx3b3JsZE9yZ1ggPSAwLjA7XG4gIHRoaXMubHdvcmxkT3JnWSA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWCA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWSA9IDAuMDtcbiAgdGhpcy5sd29ybGRFeHRYID0gMS4wO1xuICB0aGlzLmx3b3JsZEV4dFkgPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFggPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFkgPSAxLjA7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1ggPSBmdW5jdGlvbiAod294KSB7XG4gIHRoaXMubHdvcmxkT3JnWCA9IHdveDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1kgPSBmdW5jdGlvbiAod295KSB7XG4gIHRoaXMubHdvcmxkT3JnWSA9IHdveTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFggPSBmdW5jdGlvbiAod2V4KSB7XG4gIHRoaXMubHdvcmxkRXh0WCA9IHdleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFkgPSBmdW5jdGlvbiAod2V5KSB7XG4gIHRoaXMubHdvcmxkRXh0WSA9IHdleTtcbn07XG5cbi8qIERldmljZSByZWxhdGVkICovXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlT3JnWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZU9yZ1g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZU9yZ1ggPSBmdW5jdGlvbiAoZG94KSB7XG4gIHRoaXMubGRldmljZU9yZ1ggPSBkb3g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZU9yZ1kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VPcmdZID0gZnVuY3Rpb24gKGRveSkge1xuICB0aGlzLmxkZXZpY2VPcmdZID0gZG95O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlRXh0WDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlRXh0WCA9IGZ1bmN0aW9uIChkZXgpIHtcbiAgdGhpcy5sZGV2aWNlRXh0WCA9IGRleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlRXh0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZUV4dFk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZUV4dFkgPSBmdW5jdGlvbiAoZGV5KSB7XG4gIHRoaXMubGRldmljZUV4dFkgPSBkZXk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVggPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgeERldmljZSA9IDAuMDtcbiAgdmFyIHdvcmxkRXh0WCA9IHRoaXMubHdvcmxkRXh0WDtcbiAgaWYgKHdvcmxkRXh0WCAhPSAwLjApIHtcbiAgICB4RGV2aWNlID0gdGhpcy5sZGV2aWNlT3JnWCArICh4IC0gdGhpcy5sd29ybGRPcmdYKSAqIHRoaXMubGRldmljZUV4dFggLyB3b3JsZEV4dFg7XG4gIH1cblxuICByZXR1cm4geERldmljZTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5RGV2aWNlID0gMC4wO1xuICB2YXIgd29ybGRFeHRZID0gdGhpcy5sd29ybGRFeHRZO1xuICBpZiAod29ybGRFeHRZICE9IDAuMCkge1xuICAgIHlEZXZpY2UgPSB0aGlzLmxkZXZpY2VPcmdZICsgKHkgLSB0aGlzLmx3b3JsZE9yZ1kpICogdGhpcy5sZGV2aWNlRXh0WSAvIHdvcmxkRXh0WTtcbiAgfVxuXG4gIHJldHVybiB5RGV2aWNlO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciB4V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRYID0gdGhpcy5sZGV2aWNlRXh0WDtcbiAgaWYgKGRldmljZUV4dFggIT0gMC4wKSB7XG4gICAgeFdvcmxkID0gdGhpcy5sd29ybGRPcmdYICsgKHggLSB0aGlzLmxkZXZpY2VPcmdYKSAqIHRoaXMubHdvcmxkRXh0WCAvIGRldmljZUV4dFg7XG4gIH1cblxuICByZXR1cm4geFdvcmxkO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRZID0gdGhpcy5sZGV2aWNlRXh0WTtcbiAgaWYgKGRldmljZUV4dFkgIT0gMC4wKSB7XG4gICAgeVdvcmxkID0gdGhpcy5sd29ybGRPcmdZICsgKHkgLSB0aGlzLmxkZXZpY2VPcmdZKSAqIHRoaXMubHdvcmxkRXh0WSAvIGRldmljZUV4dFk7XG4gIH1cbiAgcmV0dXJuIHlXb3JsZDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24gKGluUG9pbnQpIHtcbiAgdmFyIG91dFBvaW50ID0gbmV3IFBvaW50RCh0aGlzLmludmVyc2VUcmFuc2Zvcm1YKGluUG9pbnQueCksIHRoaXMuaW52ZXJzZVRyYW5zZm9ybVkoaW5Qb2ludC55KSk7XG4gIHJldHVybiBvdXRQb2ludDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0KCkge1xuICBMYXlvdXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTjtcbiAgdGhpcy5ncmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gIHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSA9IDMuMCAqIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMDA7XG4gIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gIHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBGRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUztcbn1cblxuRkRMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXQpIHtcbiAgRkRMYXlvdXRbcHJvcF0gPSBMYXlvdXRbcHJvcF07XG59XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycy5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMgPSAwO1xuICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9IDA7XG5cbiAgdGhpcy51c2VGUkdyaWRWYXJpYW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfUkVQVUxTSU9OX1JBTkdFX0NBTENVTEFUSU9OO1xuXG4gIHRoaXMuZ3JpZCA9IFtdO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNJZGVhbEVkZ2VMZW5ndGhzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIG9yaWdpbmFsSWRlYWxMZW5ndGg7XG4gIHZhciBsY2FEZXB0aDtcbiAgdmFyIHNvdXJjZTtcbiAgdmFyIHRhcmdldDtcbiAgdmFyIHNpemVPZlNvdXJjZUluTGNhO1xuICB2YXIgc2l6ZU9mVGFyZ2V0SW5MY2E7XG5cbiAgdmFyIGFsbEVkZ2VzID0gdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRBbGxFZGdlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuXG4gICAgb3JpZ2luYWxJZGVhbExlbmd0aCA9IGVkZ2UuaWRlYWxMZW5ndGg7XG5cbiAgICBpZiAoZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgIHNvdXJjZSA9IGVkZ2UuZ2V0U291cmNlKCk7XG4gICAgICB0YXJnZXQgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gICAgICBzaXplT2ZTb3VyY2VJbkxjYSA9IGVkZ2UuZ2V0U291cmNlSW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG4gICAgICBzaXplT2ZUYXJnZXRJbkxjYSA9IGVkZ2UuZ2V0VGFyZ2V0SW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG5cbiAgICAgIGlmICh0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgZWRnZS5pZGVhbExlbmd0aCArPSBzaXplT2ZTb3VyY2VJbkxjYSArIHNpemVPZlRhcmdldEluTGNhIC0gMiAqIExheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFO1xuICAgICAgfVxuXG4gICAgICBsY2FEZXB0aCA9IGVkZ2UuZ2V0TGNhKCkuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCk7XG5cbiAgICAgIGVkZ2UuaWRlYWxMZW5ndGggKz0gb3JpZ2luYWxJZGVhbExlbmd0aCAqIEZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgKiAoc291cmNlLmdldEluY2x1c2lvblRyZWVEZXB0aCgpICsgdGFyZ2V0LmdldEluY2x1c2lvblRyZWVEZXB0aCgpIC0gMiAqIGxjYURlcHRoKTtcbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHMgPSB0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoO1xuICBpZiAodGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIGlmIChzID4gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heCh0aGlzLmNvb2xpbmdGYWN0b3IgKiBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SLCB0aGlzLmNvb2xpbmdGYWN0b3IgLSAocyAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgLyAoRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAqIHRoaXMuY29vbGluZ0ZhY3RvciAqICgxIC0gRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUikpO1xuICAgIH1cbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUw7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHMgPiBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IsIDEuMCAtIChzIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAvIChGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpICogKDEgLSBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IDEuMDtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsQ29vbGluZ0ZhY3RvciA9IHRoaXMuY29vbGluZ0ZhY3RvcjtcbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlQ7XG4gIH1cblxuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCh0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoICogNSwgdGhpcy5tYXhJdGVyYXRpb25zKTtcblxuICAvLyBSZWFzc2lnbiB0aGlzIGF0dHJpYnV0ZSBieSB1c2luZyBuZXcgY29uc3RhbnQgdmFsdWVcbiAgdGhpcy5kaXNwbGFjZW1lbnRUaHJlc2hvbGRQZXJOb2RlID0gMy4wICogRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwMDtcbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZCA9IHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSAqIHRoaXMuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG5cbiAgdGhpcy5yZXB1bHNpb25SYW5nZSA9IHRoaXMuY2FsY1JlcHVsc2lvblJhbmdlKCk7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1NwcmluZ0ZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxFZGdlcyA9IHRoaXMuZ2V0QWxsRWRnZXMoKTtcbiAgdmFyIGVkZ2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlZGdlID0gbEVkZ2VzW2ldO1xuXG4gICAgdGhpcy5jYWxjU3ByaW5nRm9yY2UoZWRnZSwgZWRnZS5pZGVhbExlbmd0aCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ3JpZFVwZGF0ZUFsbG93ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaSwgajtcbiAgdmFyIG5vZGVBLCBub2RlQjtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIHByb2Nlc3NlZE5vZGVTZXQ7XG5cbiAgaWYgKHRoaXMudXNlRlJHcmlkVmFyaWFudCkge1xuICAgIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cblxuICAgIHByb2Nlc3NlZE5vZGVTZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGVhY2ggbm9kZXMgYW5kIGl0cyBzdXJyb3VuZGluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGVBID0gbE5vZGVzW2ldO1xuICAgICAgdGhpcy5jYWxjdWxhdGVSZXB1bHNpb25Gb3JjZU9mQU5vZGUobm9kZUEsIHByb2Nlc3NlZE5vZGVTZXQsIGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKTtcbiAgICAgIHByb2Nlc3NlZE5vZGVTZXQuYWRkKG5vZGVBKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZUEgPSBsTm9kZXNbaV07XG5cbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG5vZGVCID0gbE5vZGVzW2pdO1xuXG4gICAgICAgIC8vIElmIGJvdGggbm9kZXMgYXJlIG5vdCBtZW1iZXJzIG9mIHRoZSBzYW1lIGdyYXBoLCBza2lwLlxuICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZShub2RlQSwgbm9kZUIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5jYWxjR3Jhdml0YXRpb25hbEZvcmNlKG5vZGUpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUubW92ZU5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICB2YXIgbm9kZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5tb3ZlKCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjU3ByaW5nRm9yY2UgPSBmdW5jdGlvbiAoZWRnZSwgaWRlYWxMZW5ndGgpIHtcbiAgdmFyIHNvdXJjZU5vZGUgPSBlZGdlLmdldFNvdXJjZSgpO1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgdmFyIGxlbmd0aDtcbiAgdmFyIHNwcmluZ0ZvcmNlO1xuICB2YXIgc3ByaW5nRm9yY2VYO1xuICB2YXIgc3ByaW5nRm9yY2VZO1xuXG4gIC8vIFVwZGF0ZSBlZGdlIGxlbmd0aFxuICBpZiAodGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyAmJiBzb3VyY2VOb2RlLmdldENoaWxkKCkgPT0gbnVsbCAmJiB0YXJnZXROb2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIGVkZ2UudXBkYXRlTGVuZ3RoU2ltcGxlKCk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZS51cGRhdGVMZW5ndGgoKTtcblxuICAgIGlmIChlZGdlLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxlbmd0aCA9IGVkZ2UuZ2V0TGVuZ3RoKCk7XG5cbiAgaWYgKGxlbmd0aCA9PSAwKSByZXR1cm47XG5cbiAgLy8gQ2FsY3VsYXRlIHNwcmluZyBmb3JjZXNcbiAgc3ByaW5nRm9yY2UgPSBlZGdlLmVkZ2VFbGFzdGljaXR5ICogKGxlbmd0aCAtIGlkZWFsTGVuZ3RoKTtcblxuICAvLyBQcm9qZWN0IGZvcmNlIG9udG8geCBhbmQgeSBheGVzXG4gIHNwcmluZ0ZvcmNlWCA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWCAvIGxlbmd0aCk7XG4gIHNwcmluZ0ZvcmNlWSA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWSAvIGxlbmd0aCk7XG5cbiAgLy8gQXBwbHkgZm9yY2VzIG9uIHRoZSBlbmQgbm9kZXNcbiAgc291cmNlTm9kZS5zcHJpbmdGb3JjZVggKz0gc3ByaW5nRm9yY2VYO1xuICBzb3VyY2VOb2RlLnNwcmluZ0ZvcmNlWSArPSBzcHJpbmdGb3JjZVk7XG4gIHRhcmdldE5vZGUuc3ByaW5nRm9yY2VYIC09IHNwcmluZ0ZvcmNlWDtcbiAgdGFyZ2V0Tm9kZS5zcHJpbmdGb3JjZVkgLT0gc3ByaW5nRm9yY2VZO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25Gb3JjZSA9IGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgdmFyIHJlY3RBID0gbm9kZUEuZ2V0UmVjdCgpO1xuICB2YXIgcmVjdEIgPSBub2RlQi5nZXRSZWN0KCk7XG4gIHZhciBvdmVybGFwQW1vdW50ID0gbmV3IEFycmF5KDIpO1xuICB2YXIgY2xpcFBvaW50cyA9IG5ldyBBcnJheSg0KTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGRpc3RhbmNlU3F1YXJlZDtcbiAgdmFyIGRpc3RhbmNlO1xuICB2YXIgcmVwdWxzaW9uRm9yY2U7XG4gIHZhciByZXB1bHNpb25Gb3JjZVg7XG4gIHZhciByZXB1bHNpb25Gb3JjZVk7XG5cbiAgaWYgKHJlY3RBLmludGVyc2VjdHMocmVjdEIpKSAvLyB0d28gbm9kZXMgb3ZlcmxhcFxuICAgIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBzZXBhcmF0aW9uIGFtb3VudCBpbiB4IGFuZCB5IGRpcmVjdGlvbnNcbiAgICAgIElHZW9tZXRyeS5jYWxjU2VwYXJhdGlvbkFtb3VudChyZWN0QSwgcmVjdEIsIG92ZXJsYXBBbW91bnQsIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAyLjApO1xuXG4gICAgICByZXB1bHNpb25Gb3JjZVggPSAyICogb3ZlcmxhcEFtb3VudFswXTtcbiAgICAgIHJlcHVsc2lvbkZvcmNlWSA9IDIgKiBvdmVybGFwQW1vdW50WzFdO1xuXG4gICAgICB2YXIgY2hpbGRyZW5Db25zdGFudCA9IG5vZGVBLm5vT2ZDaGlsZHJlbiAqIG5vZGVCLm5vT2ZDaGlsZHJlbiAvIChub2RlQS5ub09mQ2hpbGRyZW4gKyBub2RlQi5ub09mQ2hpbGRyZW4pO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2Rlc1xuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VYIC09IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWTtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWCArPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VZICs9IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVk7XG4gICAgfSBlbHNlIC8vIG5vIG92ZXJsYXBcbiAgICB7XG4gICAgICAvLyBjYWxjdWxhdGUgZGlzdGFuY2VcblxuICAgICAgaWYgKHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgJiYgbm9kZUEuZ2V0Q2hpbGQoKSA9PSBudWxsICYmIG5vZGVCLmdldENoaWxkKCkgPT0gbnVsbCkgLy8gc2ltcGx5IGJhc2UgcmVwdWxzaW9uIG9uIGRpc3RhbmNlIG9mIG5vZGUgY2VudGVyc1xuICAgICAgICB7XG4gICAgICAgICAgZGlzdGFuY2VYID0gcmVjdEIuZ2V0Q2VudGVyWCgpIC0gcmVjdEEuZ2V0Q2VudGVyWCgpO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IHJlY3RCLmdldENlbnRlclkoKSAtIHJlY3RBLmdldENlbnRlclkoKTtcbiAgICAgICAgfSBlbHNlIC8vIHVzZSBjbGlwcGluZyBwb2ludHNcbiAgICAgICAge1xuICAgICAgICAgIElHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24ocmVjdEEsIHJlY3RCLCBjbGlwUG9pbnRzKTtcblxuICAgICAgICAgIGRpc3RhbmNlWCA9IGNsaXBQb2ludHNbMl0gLSBjbGlwUG9pbnRzWzBdO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IGNsaXBQb2ludHNbM10gLSBjbGlwUG9pbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vIHJlcHVsc2lvbiByYW5nZS4gRlIgZ3JpZCB2YXJpYW50IHNob3VsZCB0YWtlIGNhcmUgb2YgdGhpcy5cbiAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVgpIDwgRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUKSB7XG4gICAgICAgIGRpc3RhbmNlWCA9IElNYXRoLnNpZ24oZGlzdGFuY2VYKSAqIEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVDtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWSkgPCBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QpIHtcbiAgICAgICAgZGlzdGFuY2VZID0gSU1hdGguc2lnbihkaXN0YW5jZVkpICogRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkaXN0YW5jZVNxdWFyZWQpO1xuXG4gICAgICAvLyBIZXJlIHdlIHVzZSBoYWxmIG9mIHRoZSBub2RlcycgcmVwdWxzaW9uIHZhbHVlcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgcmVwdWxzaW9uRm9yY2UgPSAobm9kZUEubm9kZVJlcHVsc2lvbiAvIDIgKyBub2RlQi5ub2RlUmVwdWxzaW9uIC8gMikgKiBub2RlQS5ub09mQ2hpbGRyZW4gKiBub2RlQi5ub09mQ2hpbGRyZW4gLyBkaXN0YW5jZVNxdWFyZWQ7XG5cbiAgICAgIC8vIFByb2plY3QgZm9yY2Ugb250byB4IGFuZCB5IGF4ZXNcbiAgICAgIHJlcHVsc2lvbkZvcmNlWCA9IHJlcHVsc2lvbkZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICByZXB1bHNpb25Gb3JjZVkgPSByZXB1bHNpb25Gb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2RlcyAgICBcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWCAtPSByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gcmVwdWxzaW9uRm9yY2VZO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VYICs9IHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWSArPSByZXB1bHNpb25Gb3JjZVk7XG4gICAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgb3duZXJHcmFwaDtcbiAgdmFyIG93bmVyQ2VudGVyWDtcbiAgdmFyIG93bmVyQ2VudGVyWTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGFic0Rpc3RhbmNlWDtcbiAgdmFyIGFic0Rpc3RhbmNlWTtcbiAgdmFyIGVzdGltYXRlZFNpemU7XG4gIG93bmVyR3JhcGggPSBub2RlLmdldE93bmVyKCk7XG5cbiAgb3duZXJDZW50ZXJYID0gKG93bmVyR3JhcGguZ2V0UmlnaHQoKSArIG93bmVyR3JhcGguZ2V0TGVmdCgpKSAvIDI7XG4gIG93bmVyQ2VudGVyWSA9IChvd25lckdyYXBoLmdldFRvcCgpICsgb3duZXJHcmFwaC5nZXRCb3R0b20oKSkgLyAyO1xuICBkaXN0YW5jZVggPSBub2RlLmdldENlbnRlclgoKSAtIG93bmVyQ2VudGVyWDtcbiAgZGlzdGFuY2VZID0gbm9kZS5nZXRDZW50ZXJZKCkgLSBvd25lckNlbnRlclk7XG4gIGFic0Rpc3RhbmNlWCA9IE1hdGguYWJzKGRpc3RhbmNlWCkgKyBub2RlLmdldFdpZHRoKCkgLyAyO1xuICBhYnNEaXN0YW5jZVkgPSBNYXRoLmFicyhkaXN0YW5jZVkpICsgbm9kZS5nZXRIZWlnaHQoKSAvIDI7XG5cbiAgaWYgKG5vZGUuZ2V0T3duZXIoKSA9PSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpIC8vIGluIHRoZSByb290IGdyYXBoXG4gICAge1xuICAgICAgZXN0aW1hdGVkU2l6ZSA9IG93bmVyR3JhcGguZ2V0RXN0aW1hdGVkU2l6ZSgpICogdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3I7XG5cbiAgICAgIGlmIChhYnNEaXN0YW5jZVggPiBlc3RpbWF0ZWRTaXplIHx8IGFic0Rpc3RhbmNlWSA+IGVzdGltYXRlZFNpemUpIHtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWCA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWDtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWSA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWTtcbiAgICAgIH1cbiAgICB9IGVsc2UgLy8gaW5zaWRlIGEgY29tcG91bmRcbiAgICB7XG4gICAgICBlc3RpbWF0ZWRTaXplID0gb3duZXJHcmFwaC5nZXRFc3RpbWF0ZWRTaXplKCkgKiB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yO1xuXG4gICAgICBpZiAoYWJzRGlzdGFuY2VYID4gZXN0aW1hdGVkU2l6ZSB8fCBhYnNEaXN0YW5jZVkgPiBlc3RpbWF0ZWRTaXplKSB7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVggPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVggKiB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50O1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VZID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VZICogdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudDtcbiAgICAgIH1cbiAgICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuaXNDb252ZXJnZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb252ZXJnZWQ7XG4gIHZhciBvc2NpbGF0aW5nID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zID4gdGhpcy5tYXhJdGVyYXRpb25zIC8gMykge1xuICAgIG9zY2lsYXRpbmcgPSBNYXRoLmFicyh0aGlzLnRvdGFsRGlzcGxhY2VtZW50IC0gdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCkgPCAyO1xuICB9XG5cbiAgY29udmVyZ2VkID0gdGhpcy50b3RhbERpc3BsYWNlbWVudCA8IHRoaXMudG90YWxEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG5cbiAgdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCA9IHRoaXMudG90YWxEaXNwbGFjZW1lbnQ7XG5cbiAgcmV0dXJuIGNvbnZlcmdlZCB8fCBvc2NpbGF0aW5nO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCAmJiAhdGhpcy5pc1N1YkxheW91dCkge1xuICAgIGlmICh0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9PSB0aGlzLmFuaW1hdGlvblBlcmlvZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMrKztcbiAgICB9XG4gIH1cbn07XG5cbi8vVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuICh3ZWlnaHQpIGZvciBhbGwgbm9kZXNcbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlO1xuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgbm9kZS5ub09mQ2hpbGRyZW4gPSBub2RlLmdldE5vT2ZDaGlsZHJlbigpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogRlItR3JpZCBWYXJpYW50IFJlcHVsc2lvbiBGb3JjZSBDYWxjdWxhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmlkID0gZnVuY3Rpb24gKGdyYXBoKSB7XG5cbiAgdmFyIHNpemVYID0gMDtcbiAgdmFyIHNpemVZID0gMDtcblxuICBzaXplWCA9IHBhcnNlSW50KE1hdGguY2VpbCgoZ3JhcGguZ2V0UmlnaHQoKSAtIGdyYXBoLmdldExlZnQoKSkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHNpemVZID0gcGFyc2VJbnQoTWF0aC5jZWlsKChncmFwaC5nZXRCb3R0b20oKSAtIGdyYXBoLmdldFRvcCgpKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcblxuICB2YXIgZ3JpZCA9IG5ldyBBcnJheShzaXplWCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWDsgaSsrKSB7XG4gICAgZ3JpZFtpXSA9IG5ldyBBcnJheShzaXplWSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVZOyBqKyspIHtcbiAgICAgIGdyaWRbaV1bal0gPSBuZXcgQXJyYXkoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ3JpZDtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5hZGROb2RlVG9HcmlkID0gZnVuY3Rpb24gKHYsIGxlZnQsIHRvcCkge1xuXG4gIHZhciBzdGFydFggPSAwO1xuICB2YXIgZmluaXNoWCA9IDA7XG4gIHZhciBzdGFydFkgPSAwO1xuICB2YXIgZmluaXNoWSA9IDA7XG5cbiAgc3RhcnRYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkueCAtIGxlZnQpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkud2lkdGggKyB2LmdldFJlY3QoKS54IC0gbGVmdCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHN0YXJ0WSA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLnkgLSB0b3ApIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hZID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkuaGVpZ2h0ICsgdi5nZXRSZWN0KCkueSAtIHRvcCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0WDsgaSA8PSBmaW5pc2hYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gc3RhcnRZOyBqIDw9IGZpbmlzaFk7IGorKykge1xuICAgICAgdGhpcy5ncmlkW2ldW2pdLnB1c2godik7XG4gICAgICB2LnNldEdyaWRDb29yZGluYXRlcyhzdGFydFgsIGZpbmlzaFgsIHN0YXJ0WSwgZmluaXNoWSk7XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUudXBkYXRlR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIHZhciBub2RlQTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcblxuICB0aGlzLmdyaWQgPSB0aGlzLmNhbGNHcmlkKHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSk7XG5cbiAgLy8gcHV0IGFsbCBub2RlcyB0byBwcm9wZXIgZ3JpZCBjZWxsc1xuICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZUEgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5hZGROb2RlVG9HcmlkKG5vZGVBLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0TGVmdCgpLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0VG9wKCkpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY3VsYXRlUmVwdWxzaW9uRm9yY2VPZkFOb2RlID0gZnVuY3Rpb24gKG5vZGVBLCBwcm9jZXNzZWROb2RlU2V0LCBncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuXG4gIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQgfHwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuICAgIHZhciBzdXJyb3VuZGluZyA9IG5ldyBTZXQoKTtcbiAgICBub2RlQS5zdXJyb3VuZGluZyA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBub2RlQjtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZDtcblxuICAgIGZvciAodmFyIGkgPSBub2RlQS5zdGFydFggLSAxOyBpIDwgbm9kZUEuZmluaXNoWCArIDI7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IG5vZGVBLnN0YXJ0WSAtIDE7IGogPCBub2RlQS5maW5pc2hZICsgMjsgaisrKSB7XG4gICAgICAgIGlmICghKGkgPCAwIHx8IGogPCAwIHx8IGkgPj0gZ3JpZC5sZW5ndGggfHwgaiA+PSBncmlkWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdyaWRbaV1bal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIG5vZGVCID0gZ3JpZFtpXVtqXVtrXTtcblxuICAgICAgICAgICAgLy8gSWYgYm90aCBub2RlcyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIHNhbWUgZ3JhcGgsIFxuICAgICAgICAgICAgLy8gb3IgYm90aCBub2RlcyBhcmUgdGhlIHNhbWUsIHNraXAuXG4gICAgICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpIHx8IG5vZGVBID09IG5vZGVCKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVwdWxzaW9uIGZvcmNlIGJldHdlZW5cbiAgICAgICAgICAgIC8vIG5vZGVBIGFuZCBub2RlQiBoYXMgYWxyZWFkeSBiZWVuIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkTm9kZVNldC5oYXMobm9kZUIpICYmICFzdXJyb3VuZGluZy5oYXMobm9kZUIpKSB7XG4gICAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLmFicyhub2RlQS5nZXRDZW50ZXJYKCkgLSBub2RlQi5nZXRDZW50ZXJYKCkpIC0gKG5vZGVBLmdldFdpZHRoKCkgLyAyICsgbm9kZUIuZ2V0V2lkdGgoKSAvIDIpO1xuICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5hYnMobm9kZUEuZ2V0Q2VudGVyWSgpIC0gbm9kZUIuZ2V0Q2VudGVyWSgpKSAtIChub2RlQS5nZXRIZWlnaHQoKSAvIDIgKyBub2RlQi5nZXRIZWlnaHQoKSAvIDIpO1xuXG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIG5vZGVBIGFuZCBub2RlQiBcbiAgICAgICAgICAgICAgLy8gaXMgbGVzcyB0aGVuIGNhbGN1bGF0aW9uIHJhbmdlXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZVggPD0gdGhpcy5yZXB1bHNpb25SYW5nZSAmJiBkaXN0YW5jZVkgPD0gdGhpcy5yZXB1bHNpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgIC8vdGhlbiBhZGQgbm9kZUIgdG8gc3Vycm91bmRpbmcgb2Ygbm9kZUFcbiAgICAgICAgICAgICAgICBzdXJyb3VuZGluZy5hZGQobm9kZUIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZUEuc3Vycm91bmRpbmcgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHN1cnJvdW5kaW5nKSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG5vZGVBLnN1cnJvdW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2Uobm9kZUEsIG5vZGVBLnN1cnJvdW5kaW5nW2ldKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDAuMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0RWRnZShzb3VyY2UsIHRhcmdldCwgdkVkZ2UpIHtcbiAgTEVkZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdkVkZ2UpO1xuXG4gIC8vIElkZWFsIGxlbmd0aCBhbmQgZWxhc3RpY2l0eSB2YWx1ZSBmb3IgdGhpcyBlZGdlXG4gIHRoaXMuaWRlYWxMZW5ndGggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICB0aGlzLmVkZ2VFbGFzdGljaXR5ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEg7XG59XG5cbkZETGF5b3V0RWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExFZGdlLnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTEVkZ2UpIHtcbiAgRkRMYXlvdXRFZGdlW3Byb3BdID0gTEVkZ2VbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXRFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBGRExheW91dE5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgLy8gYWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgaXMgaGFuZGxlZCBpbnNpZGUgTE5vZGVcbiAgTE5vZGUuY2FsbCh0aGlzLCBnbSwgbG9jLCBzaXplLCB2Tm9kZSk7XG5cbiAgLy8gUmVwdWxzaW9uIHZhbHVlIG9mIHRoaXMgbm9kZVxuICB0aGlzLm5vZGVSZXB1bHNpb24gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSDtcblxuICAvL1NwcmluZywgcmVwdWxzaW9uIGFuZCBncmF2aXRhdGlvbmFsIGZvcmNlcyBhY3Rpbmcgb24gdGhpcyBub2RlXG4gIHRoaXMuc3ByaW5nRm9yY2VYID0gMDtcbiAgdGhpcy5zcHJpbmdGb3JjZVkgPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWCA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VZID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkgPSAwO1xuICAvL0Ftb3VudCBieSB3aGljaCB0aGlzIG5vZGUgaXMgdG8gYmUgbW92ZWQgaW4gdGhpcyBpdGVyYXRpb25cbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcblxuICAvL1N0YXJ0IGFuZCBmaW5pc2ggZ3JpZCBjb29yZGluYXRlcyB0aGF0IHRoaXMgbm9kZSBpcyBmYWxsZW4gaW50b1xuICB0aGlzLnN0YXJ0WCA9IDA7XG4gIHRoaXMuZmluaXNoWCA9IDA7XG4gIHRoaXMuc3RhcnRZID0gMDtcbiAgdGhpcy5maW5pc2hZID0gMDtcblxuICAvL0dlb21ldHJpYyBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gIHRoaXMuc3Vycm91bmRpbmcgPSBbXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTE5vZGUucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMTm9kZSkge1xuICBGRExheW91dE5vZGVbcHJvcF0gPSBMTm9kZVtwcm9wXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZS5zZXRHcmlkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoX3N0YXJ0WCwgX2ZpbmlzaFgsIF9zdGFydFksIF9maW5pc2hZKSB7XG4gIHRoaXMuc3RhcnRYID0gX3N0YXJ0WDtcbiAgdGhpcy5maW5pc2hYID0gX2ZpbmlzaFg7XG4gIHRoaXMuc3RhcnRZID0gX3N0YXJ0WTtcbiAgdGhpcy5maW5pc2hZID0gX2ZpbmlzaFk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Tm9kZTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBEaW1lbnNpb25EKHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgaWYgKHdpZHRoICE9PSBudWxsICYmIGhlaWdodCAhPT0gbnVsbCkge1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgfVxufVxuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpbWVuc2lvbkQ7XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hNYXAoKSB7XG4gIHRoaXMubWFwID0ge307XG4gIHRoaXMua2V5cyA9IFtdO1xufVxuXG5IYXNoTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChrZXkpO1xuICBpZiAoIXRoaXMuY29udGFpbnModGhlSWQpKSB7XG4gICAgdGhpcy5tYXBbdGhlSWRdID0gdmFsdWU7XG4gICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgfVxufTtcblxuSGFzaE1hcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFtrZXldICE9IG51bGw7XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFt0aGVJZF07XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5rZXlTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmtleXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hNYXA7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hTZXQoKSB7XG4gIHRoaXMuc2V0ID0ge307XG59XG47XG5cbkhhc2hTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKTtcbiAgaWYgKCF0aGlzLmNvbnRhaW5zKHRoZUlkKSkgdGhpcy5zZXRbdGhlSWRdID0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICBkZWxldGUgdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV07XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXQgPSB7fTtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV0gPT0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2l6ZSgpID09PSAwO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0KS5sZW5ndGg7XG59O1xuXG4vL2NvbmNhdHMgdGhpcy5zZXQgdG8gdGhlIGdpdmVuIGxpc3Rcbkhhc2hTZXQucHJvdG90eXBlLmFkZEFsbFRvID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnNldCk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxpc3QucHVzaCh0aGlzLnNldFtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNldCkubGVuZ3RoO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIHMgPSBsaXN0Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgdiA9IGxpc3RbaV07XG4gICAgdGhpcy5hZGQodik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFNldDtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyBTb21lIG1hdHJpeCAoMWQgYW5kIDJkIGFycmF5KSBvcGVyYXRpb25zXG5mdW5jdGlvbiBNYXRyaXgoKSB7fVxuXG4vKipcbiAqIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICogYXJyYXkxLCBhcnJheTIgYW5kIHJlc3VsdCBhcmUgMmQgYXJyYXlzXG4gKi9cbk1hdHJpeC5tdWx0TWF0ID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXkyWzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICByZXN1bHRbaV1bal0gPSAwO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcnJheTFbMF0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgcmVzdWx0W2ldW2pdICs9IGFycmF5MVtpXVtrXSAqIGFycmF5MltrXVtqXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogbWF0cml4IHRyYW5zcG9zZVxuICogYXJyYXkgYW5kIHJlc3VsdCBhcmUgMmQgYXJyYXlzXG4gKi9cbk1hdHJpeC50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICByZXN1bHRbaV1bal0gPSBhcnJheVtqXVtpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBtdWx0aXBseSBhcnJheSB3aXRoIGNvbnN0YW50XG4gKiBhcnJheSBhbmQgcmVzdWx0IGFyZSAxZCBhcnJheXNcbiAqL1xuTWF0cml4Lm11bHRDb25zID0gZnVuY3Rpb24gKGFycmF5LCBjb25zdGFudCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGFycmF5W2ldICogY29uc3RhbnQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBzdWJzdHJhY3QgdHdvIGFycmF5c1xuICogYXJyYXkxLCBhcnJheTIgYW5kIHJlc3VsdCBhcmUgMWQgYXJyYXlzXG4gKi9cbk1hdHJpeC5taW51c09wID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGFycmF5MVtpXSAtIGFycmF5MltpXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIGRvdCBwcm9kdWN0IG9mIHR3byBhcnJheXMgd2l0aCBzYW1lIHNpemVcbiAqIGFycmF5MSBhbmQgYXJyYXkyIGFyZSAxZCBhcnJheXNcbiAqL1xuTWF0cml4LmRvdFByb2R1Y3QgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIpIHtcbiAgdmFyIHByb2R1Y3QgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdCArPSBhcnJheTFbaV0gKiBhcnJheTJbaV07XG4gIH1cblxuICByZXR1cm4gcHJvZHVjdDtcbn07XG5cbi8qKlxuICogbWFnbml0dWRlIG9mIGFuIGFycmF5XG4gKiBhcnJheSBpcyAxZCBhcnJheVxuICovXG5NYXRyaXgubWFnID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5kb3RQcm9kdWN0KGFycmF5LCBhcnJheSkpO1xufTtcblxuLyoqXG4gKiBub3JtYWxpemF0aW9uIG9mIGFuIGFycmF5XG4gKiBhcnJheSBhbmQgcmVzdWx0IGFyZSAxZCBhcnJheVxuICovXG5NYXRyaXgubm9ybWFsaXplID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIG1hZ25pdHVkZSA9IHRoaXMubWFnKGFycmF5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gYXJyYXlbaV0gLyBtYWduaXR1ZGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBtdWx0aXBseSBhbiBhcnJheSB3aXRoIGNlbnRlcmluZyBtYXRyaXhcbiAqIGFycmF5IGFuZCByZXN1bHQgYXJlIDFkIGFycmF5XG4gKi9cbk1hdHJpeC5tdWx0R2FtbWEgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgc3VtID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtICs9IGFycmF5W2ldO1xuICB9XG5cbiAgc3VtICo9IC0xIC8gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcnJheS5sZW5ndGg7IF9pKyspIHtcbiAgICByZXN1bHRbX2ldID0gc3VtICsgYXJyYXlbX2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIGEgc3BlY2lhbCBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAqIHJlc3VsdCA9IDAuNSAqIEMgKiBJTlYgKiBDXlQgKiBhcnJheVxuICogYXJyYXkgYW5kIHJlc3VsdCBhcmUgMWQsIEMgYW5kIElOViBhcmUgMmQgYXJyYXlzXG4gKi9cbk1hdHJpeC5tdWx0TCA9IGZ1bmN0aW9uIChhcnJheSwgQywgSU5WKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHRlbXAxID0gW107XG4gIHZhciB0ZW1wMiA9IFtdO1xuXG4gIC8vIG11bHRpcGx5IGJ5IENeVFxuICBmb3IgKHZhciBpID0gMDsgaSA8IENbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IEMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHN1bSArPSAtMC41ICogQ1tqXVtpXSAqIGFycmF5W2pdO1xuICAgIH1cbiAgICB0ZW1wMVtpXSA9IHN1bTtcbiAgfVxuICAvLyBtdWx0aXBseSB0aGUgcmVzdWx0IGJ5IElOVlxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBJTlYubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfc3VtID0gMDtcbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgSU5WLmxlbmd0aDsgX2orKykge1xuICAgICAgX3N1bSArPSBJTlZbX2kyXVtfal0gKiB0ZW1wMVtfal07XG4gICAgfVxuICAgIHRlbXAyW19pMl0gPSBfc3VtO1xuICB9XG4gIC8vIG11bHRpcGx5IHRoZSByZXN1bHQgYnkgQ1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBDLmxlbmd0aDsgX2kzKyspIHtcbiAgICB2YXIgX3N1bTIgPSAwO1xuICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IENbMF0ubGVuZ3RoOyBfajIrKykge1xuICAgICAgX3N1bTIgKz0gQ1tfaTNdW19qMl0gKiB0ZW1wMltfajJdO1xuICAgIH1cbiAgICByZXN1bHRbX2kzXSA9IF9zdW0yO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBjbGFzc2ljIFF1aWNrc29ydCBhbGdvcml0aG0gd2l0aCBIb2FyZSdzIHBhcnRpdGlvblxuICogLSBXb3JrcyBhbHNvIG9uIExpbmtlZExpc3Qgb2JqZWN0c1xuICpcbiAqIENvcHlyaWdodDogaS1WaXMgUmVzZWFyY2ggR3JvdXAsIEJpbGtlbnQgVW5pdmVyc2l0eSwgMjAwNyAtIHByZXNlbnRcbiAqL1xuXG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgUXVpY2tzb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1aWNrc29ydChBLCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrc29ydCk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmVGdW5jdGlvbiAhPT0gbnVsbCB8fCBjb21wYXJlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkgdGhpcy5jb21wYXJlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIGlmIChBIGluc3RhbmNlb2YgTGlua2VkTGlzdCkgbGVuZ3RoID0gQS5zaXplKCk7ZWxzZSBsZW5ndGggPSBBLmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgMCwgbGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFF1aWNrc29ydCwgW3tcbiAgICAgICAga2V5OiAnX3F1aWNrc29ydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcXVpY2tzb3J0KEEsIHAsIHIpIHtcbiAgICAgICAgICAgIGlmIChwIDwgcikge1xuICAgICAgICAgICAgICAgIHZhciBxID0gdGhpcy5fcGFydGl0aW9uKEEsIHAsIHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1aWNrc29ydChBLCBwLCBxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgcSArIDEsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcGFydGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJ0aXRpb24oQSwgcCwgcikge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLl9nZXQoQSwgcCk7XG4gICAgICAgICAgICB2YXIgaSA9IHA7XG4gICAgICAgICAgICB2YXIgaiA9IHI7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbXBhcmVGdW5jdGlvbih4LCB0aGlzLl9nZXQoQSwgaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9d2hpbGUgKHRoaXMuY29tcGFyZUZ1bmN0aW9uKHRoaXMuX2dldChBLCBpKSwgeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1pZiAoaSA8IGopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dhcChBLCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHJldHVybiBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQob2JqZWN0LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIExpbmtlZExpc3QpIHJldHVybiBvYmplY3QuZ2V0X29iamVjdF9hdChpbmRleCk7ZWxzZSByZXR1cm4gb2JqZWN0W2luZGV4XTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0KG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTGlua2VkTGlzdCkgb2JqZWN0LnNldF9vYmplY3RfYXQoaW5kZXgsIHZhbHVlKTtlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3N3YXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3N3YXAoQSwgaSwgaikge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLl9nZXQoQSwgaSk7XG4gICAgICAgICAgICB0aGlzLl9zZXQoQSwgaSwgdGhpcy5fZ2V0KEEsIGopKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChBLCBqLCB0ZW1wKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgPiBhO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFF1aWNrc29ydDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWlja3NvcnQ7XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gU2luZ3VsYXIgVmFsdWUgRGVjb21wb3NpdGlvbiBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gU1ZEKCkge307XG5cbi8qIEJlbG93IHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gKHN2ZCkgY29kZSBpbmNsdWRpbmcgaHlwb3QgZnVuY3Rpb24gaXMgYWRvcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kcmFnb25mbHktYWkvSmFtYUpTXG4gICBTb21lIGNoYW5nZXMgYXJlIGFwcGxpZWQgdG8gbWFrZSB0aGUgY29kZSBjb21wYXRpYmxlIHdpdGggdGhlIGZjb3NlIGNvZGUgYW5kIHRvIG1ha2UgaXQgaW5kZXBlbmRlbnQgZnJvbSBKYW1hLlxuICAgSW5wdXQgbWF0cml4IGlzIGNoYW5nZWQgdG8gYSAyRCBhcnJheSBpbnN0ZWFkIG9mIEphbWEgbWF0cml4LiBNYXRyaXggZGltZW5zaW9ucyBhcmUgdGFrZW4gYWNjb3JkaW5nIHRvIDJEIGFycmF5IGluc3RlYWQgb2YgdXNpbmcgSmFtYSBmdW5jdGlvbnMuXG4gICBBbiBvYmplY3QgdGhhdCBpbmNsdWRlcyBzaW5ndWxhciB2YWx1ZSBjb21wb25lbnRzIGlzIGNyZWF0ZWQgZm9yIHJldHVybi4gXG4gICBUaGUgdHlwZXMgb2YgaW5wdXQgcGFyYW1ldGVycyBvZiB0aGUgaHlwb3QgZnVuY3Rpb24gYXJlIHJlbW92ZWQuIFxuICAgbGV0IGlzIHVzZWQgaW5zdGVhZCBvZiB2YXIgZm9yIHRoZSB2YXJpYWJsZSBpbml0aWFsaXphdGlvbi5cbiovXG4vKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwYWNoZSBMaWNlbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0XG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvXG5cbiAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBVU0UsIFJFUFJPRFVDVElPTiwgQU5EIERJU1RSSUJVVElPTlxuXG4gICAxLiBEZWZpbml0aW9ucy5cblxuICAgICAgXCJMaWNlbnNlXCIgc2hhbGwgbWVhbiB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgZm9yIHVzZSwgcmVwcm9kdWN0aW9uLFxuICAgICAgYW5kIGRpc3RyaWJ1dGlvbiBhcyBkZWZpbmVkIGJ5IFNlY3Rpb25zIDEgdGhyb3VnaCA5IG9mIHRoaXMgZG9jdW1lbnQuXG5cbiAgICAgIFwiTGljZW5zb3JcIiBzaGFsbCBtZWFuIHRoZSBjb3B5cmlnaHQgb3duZXIgb3IgZW50aXR5IGF1dGhvcml6ZWQgYnlcbiAgICAgIHRoZSBjb3B5cmlnaHQgb3duZXIgdGhhdCBpcyBncmFudGluZyB0aGUgTGljZW5zZS5cblxuICAgICAgXCJMZWdhbCBFbnRpdHlcIiBzaGFsbCBtZWFuIHRoZSB1bmlvbiBvZiB0aGUgYWN0aW5nIGVudGl0eSBhbmQgYWxsXG4gICAgICBvdGhlciBlbnRpdGllcyB0aGF0IGNvbnRyb2wsIGFyZSBjb250cm9sbGVkIGJ5LCBvciBhcmUgdW5kZXIgY29tbW9uXG4gICAgICBjb250cm9sIHdpdGggdGhhdCBlbnRpdHkuIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBkZWZpbml0aW9uLFxuICAgICAgXCJjb250cm9sXCIgbWVhbnMgKGkpIHRoZSBwb3dlciwgZGlyZWN0IG9yIGluZGlyZWN0LCB0byBjYXVzZSB0aGVcbiAgICAgIGRpcmVjdGlvbiBvciBtYW5hZ2VtZW50IG9mIHN1Y2ggZW50aXR5LCB3aGV0aGVyIGJ5IGNvbnRyYWN0IG9yXG4gICAgICBvdGhlcndpc2UsIG9yIChpaSkgb3duZXJzaGlwIG9mIGZpZnR5IHBlcmNlbnQgKDUwJSkgb3IgbW9yZSBvZiB0aGVcbiAgICAgIG91dHN0YW5kaW5nIHNoYXJlcywgb3IgKGlpaSkgYmVuZWZpY2lhbCBvd25lcnNoaXAgb2Ygc3VjaCBlbnRpdHkuXG5cbiAgICAgIFwiWW91XCIgKG9yIFwiWW91clwiKSBzaGFsbCBtZWFuIGFuIGluZGl2aWR1YWwgb3IgTGVnYWwgRW50aXR5XG4gICAgICBleGVyY2lzaW5nIHBlcm1pc3Npb25zIGdyYW50ZWQgYnkgdGhpcyBMaWNlbnNlLlxuXG4gICAgICBcIlNvdXJjZVwiIGZvcm0gc2hhbGwgbWVhbiB0aGUgcHJlZmVycmVkIGZvcm0gZm9yIG1ha2luZyBtb2RpZmljYXRpb25zLFxuICAgICAgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byBzb2Z0d2FyZSBzb3VyY2UgY29kZSwgZG9jdW1lbnRhdGlvblxuICAgICAgc291cmNlLCBhbmQgY29uZmlndXJhdGlvbiBmaWxlcy5cblxuICAgICAgXCJPYmplY3RcIiBmb3JtIHNoYWxsIG1lYW4gYW55IGZvcm0gcmVzdWx0aW5nIGZyb20gbWVjaGFuaWNhbFxuICAgICAgdHJhbnNmb3JtYXRpb24gb3IgdHJhbnNsYXRpb24gb2YgYSBTb3VyY2UgZm9ybSwgaW5jbHVkaW5nIGJ1dFxuICAgICAgbm90IGxpbWl0ZWQgdG8gY29tcGlsZWQgb2JqZWN0IGNvZGUsIGdlbmVyYXRlZCBkb2N1bWVudGF0aW9uLFxuICAgICAgYW5kIGNvbnZlcnNpb25zIHRvIG90aGVyIG1lZGlhIHR5cGVzLlxuXG4gICAgICBcIldvcmtcIiBzaGFsbCBtZWFuIHRoZSB3b3JrIG9mIGF1dGhvcnNoaXAsIHdoZXRoZXIgaW4gU291cmNlIG9yXG4gICAgICBPYmplY3QgZm9ybSwgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIExpY2Vuc2UsIGFzIGluZGljYXRlZCBieSBhXG4gICAgICBjb3B5cmlnaHQgbm90aWNlIHRoYXQgaXMgaW5jbHVkZWQgaW4gb3IgYXR0YWNoZWQgdG8gdGhlIHdvcmtcbiAgICAgIChhbiBleGFtcGxlIGlzIHByb3ZpZGVkIGluIHRoZSBBcHBlbmRpeCBiZWxvdykuXG5cbiAgICAgIFwiRGVyaXZhdGl2ZSBXb3Jrc1wiIHNoYWxsIG1lYW4gYW55IHdvcmssIHdoZXRoZXIgaW4gU291cmNlIG9yIE9iamVjdFxuICAgICAgZm9ybSwgdGhhdCBpcyBiYXNlZCBvbiAob3IgZGVyaXZlZCBmcm9tKSB0aGUgV29yayBhbmQgZm9yIHdoaWNoIHRoZVxuICAgICAgZWRpdG9yaWFsIHJldmlzaW9ucywgYW5ub3RhdGlvbnMsIGVsYWJvcmF0aW9ucywgb3Igb3RoZXIgbW9kaWZpY2F0aW9uc1xuICAgICAgcmVwcmVzZW50LCBhcyBhIHdob2xlLCBhbiBvcmlnaW5hbCB3b3JrIG9mIGF1dGhvcnNoaXAuIEZvciB0aGUgcHVycG9zZXNcbiAgICAgIG9mIHRoaXMgTGljZW5zZSwgRGVyaXZhdGl2ZSBXb3JrcyBzaGFsbCBub3QgaW5jbHVkZSB3b3JrcyB0aGF0IHJlbWFpblxuICAgICAgc2VwYXJhYmxlIGZyb20sIG9yIG1lcmVseSBsaW5rIChvciBiaW5kIGJ5IG5hbWUpIHRvIHRoZSBpbnRlcmZhY2VzIG9mLFxuICAgICAgdGhlIFdvcmsgYW5kIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZi5cblxuICAgICAgXCJDb250cmlidXRpb25cIiBzaGFsbCBtZWFuIGFueSB3b3JrIG9mIGF1dGhvcnNoaXAsIGluY2x1ZGluZ1xuICAgICAgdGhlIG9yaWdpbmFsIHZlcnNpb24gb2YgdGhlIFdvcmsgYW5kIGFueSBtb2RpZmljYXRpb25zIG9yIGFkZGl0aW9uc1xuICAgICAgdG8gdGhhdCBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiwgdGhhdCBpcyBpbnRlbnRpb25hbGx5XG4gICAgICBzdWJtaXR0ZWQgdG8gTGljZW5zb3IgZm9yIGluY2x1c2lvbiBpbiB0aGUgV29yayBieSB0aGUgY29weXJpZ2h0IG93bmVyXG4gICAgICBvciBieSBhbiBpbmRpdmlkdWFsIG9yIExlZ2FsIEVudGl0eSBhdXRob3JpemVkIHRvIHN1Ym1pdCBvbiBiZWhhbGYgb2ZcbiAgICAgIHRoZSBjb3B5cmlnaHQgb3duZXIuIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBkZWZpbml0aW9uLCBcInN1Ym1pdHRlZFwiXG4gICAgICBtZWFucyBhbnkgZm9ybSBvZiBlbGVjdHJvbmljLCB2ZXJiYWwsIG9yIHdyaXR0ZW4gY29tbXVuaWNhdGlvbiBzZW50XG4gICAgICB0byB0aGUgTGljZW5zb3Igb3IgaXRzIHJlcHJlc2VudGF0aXZlcywgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0b1xuICAgICAgY29tbXVuaWNhdGlvbiBvbiBlbGVjdHJvbmljIG1haWxpbmcgbGlzdHMsIHNvdXJjZSBjb2RlIGNvbnRyb2wgc3lzdGVtcyxcbiAgICAgIGFuZCBpc3N1ZSB0cmFja2luZyBzeXN0ZW1zIHRoYXQgYXJlIG1hbmFnZWQgYnksIG9yIG9uIGJlaGFsZiBvZiwgdGhlXG4gICAgICBMaWNlbnNvciBmb3IgdGhlIHB1cnBvc2Ugb2YgZGlzY3Vzc2luZyBhbmQgaW1wcm92aW5nIHRoZSBXb3JrLCBidXRcbiAgICAgIGV4Y2x1ZGluZyBjb21tdW5pY2F0aW9uIHRoYXQgaXMgY29uc3BpY3VvdXNseSBtYXJrZWQgb3Igb3RoZXJ3aXNlXG4gICAgICBkZXNpZ25hdGVkIGluIHdyaXRpbmcgYnkgdGhlIGNvcHlyaWdodCBvd25lciBhcyBcIk5vdCBhIENvbnRyaWJ1dGlvbi5cIlxuXG4gICAgICBcIkNvbnRyaWJ1dG9yXCIgc2hhbGwgbWVhbiBMaWNlbnNvciBhbmQgYW55IGluZGl2aWR1YWwgb3IgTGVnYWwgRW50aXR5XG4gICAgICBvbiBiZWhhbGYgb2Ygd2hvbSBhIENvbnRyaWJ1dGlvbiBoYXMgYmVlbiByZWNlaXZlZCBieSBMaWNlbnNvciBhbmRcbiAgICAgIHN1YnNlcXVlbnRseSBpbmNvcnBvcmF0ZWQgd2l0aGluIHRoZSBXb3JrLlxuXG4gICAyLiBHcmFudCBvZiBDb3B5cmlnaHQgTGljZW5zZS4gU3ViamVjdCB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2ZcbiAgICAgIHRoaXMgTGljZW5zZSwgZWFjaCBDb250cmlidXRvciBoZXJlYnkgZ3JhbnRzIHRvIFlvdSBhIHBlcnBldHVhbCxcbiAgICAgIHdvcmxkd2lkZSwgbm9uLWV4Y2x1c2l2ZSwgbm8tY2hhcmdlLCByb3lhbHR5LWZyZWUsIGlycmV2b2NhYmxlXG4gICAgICBjb3B5cmlnaHQgbGljZW5zZSB0byByZXByb2R1Y2UsIHByZXBhcmUgRGVyaXZhdGl2ZSBXb3JrcyBvZixcbiAgICAgIHB1YmxpY2x5IGRpc3BsYXksIHB1YmxpY2x5IHBlcmZvcm0sIHN1YmxpY2Vuc2UsIGFuZCBkaXN0cmlidXRlIHRoZVxuICAgICAgV29yayBhbmQgc3VjaCBEZXJpdmF0aXZlIFdvcmtzIGluIFNvdXJjZSBvciBPYmplY3QgZm9ybS5cblxuICAgMy4gR3JhbnQgb2YgUGF0ZW50IExpY2Vuc2UuIFN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mXG4gICAgICB0aGlzIExpY2Vuc2UsIGVhY2ggQ29udHJpYnV0b3IgaGVyZWJ5IGdyYW50cyB0byBZb3UgYSBwZXJwZXR1YWwsXG4gICAgICB3b3JsZHdpZGUsIG5vbi1leGNsdXNpdmUsIG5vLWNoYXJnZSwgcm95YWx0eS1mcmVlLCBpcnJldm9jYWJsZVxuICAgICAgKGV4Y2VwdCBhcyBzdGF0ZWQgaW4gdGhpcyBzZWN0aW9uKSBwYXRlbnQgbGljZW5zZSB0byBtYWtlLCBoYXZlIG1hZGUsXG4gICAgICB1c2UsIG9mZmVyIHRvIHNlbGwsIHNlbGwsIGltcG9ydCwgYW5kIG90aGVyd2lzZSB0cmFuc2ZlciB0aGUgV29yayxcbiAgICAgIHdoZXJlIHN1Y2ggbGljZW5zZSBhcHBsaWVzIG9ubHkgdG8gdGhvc2UgcGF0ZW50IGNsYWltcyBsaWNlbnNhYmxlXG4gICAgICBieSBzdWNoIENvbnRyaWJ1dG9yIHRoYXQgYXJlIG5lY2Vzc2FyaWx5IGluZnJpbmdlZCBieSB0aGVpclxuICAgICAgQ29udHJpYnV0aW9uKHMpIGFsb25lIG9yIGJ5IGNvbWJpbmF0aW9uIG9mIHRoZWlyIENvbnRyaWJ1dGlvbihzKVxuICAgICAgd2l0aCB0aGUgV29yayB0byB3aGljaCBzdWNoIENvbnRyaWJ1dGlvbihzKSB3YXMgc3VibWl0dGVkLiBJZiBZb3VcbiAgICAgIGluc3RpdHV0ZSBwYXRlbnQgbGl0aWdhdGlvbiBhZ2FpbnN0IGFueSBlbnRpdHkgKGluY2x1ZGluZyBhXG4gICAgICBjcm9zcy1jbGFpbSBvciBjb3VudGVyY2xhaW0gaW4gYSBsYXdzdWl0KSBhbGxlZ2luZyB0aGF0IHRoZSBXb3JrXG4gICAgICBvciBhIENvbnRyaWJ1dGlvbiBpbmNvcnBvcmF0ZWQgd2l0aGluIHRoZSBXb3JrIGNvbnN0aXR1dGVzIGRpcmVjdFxuICAgICAgb3IgY29udHJpYnV0b3J5IHBhdGVudCBpbmZyaW5nZW1lbnQsIHRoZW4gYW55IHBhdGVudCBsaWNlbnNlc1xuICAgICAgZ3JhbnRlZCB0byBZb3UgdW5kZXIgdGhpcyBMaWNlbnNlIGZvciB0aGF0IFdvcmsgc2hhbGwgdGVybWluYXRlXG4gICAgICBhcyBvZiB0aGUgZGF0ZSBzdWNoIGxpdGlnYXRpb24gaXMgZmlsZWQuXG5cbiAgIDQuIFJlZGlzdHJpYnV0aW9uLiBZb3UgbWF5IHJlcHJvZHVjZSBhbmQgZGlzdHJpYnV0ZSBjb3BpZXMgb2YgdGhlXG4gICAgICBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiBpbiBhbnkgbWVkaXVtLCB3aXRoIG9yIHdpdGhvdXRcbiAgICAgIG1vZGlmaWNhdGlvbnMsIGFuZCBpbiBTb3VyY2Ugb3IgT2JqZWN0IGZvcm0sIHByb3ZpZGVkIHRoYXQgWW91XG4gICAgICBtZWV0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgICAgKGEpIFlvdSBtdXN0IGdpdmUgYW55IG90aGVyIHJlY2lwaWVudHMgb2YgdGhlIFdvcmsgb3JcbiAgICAgICAgICBEZXJpdmF0aXZlIFdvcmtzIGEgY29weSBvZiB0aGlzIExpY2Vuc2U7IGFuZFxuXG4gICAgICAoYikgWW91IG11c3QgY2F1c2UgYW55IG1vZGlmaWVkIGZpbGVzIHRvIGNhcnJ5IHByb21pbmVudCBub3RpY2VzXG4gICAgICAgICAgc3RhdGluZyB0aGF0IFlvdSBjaGFuZ2VkIHRoZSBmaWxlczsgYW5kXG5cbiAgICAgIChjKSBZb3UgbXVzdCByZXRhaW4sIGluIHRoZSBTb3VyY2UgZm9ybSBvZiBhbnkgRGVyaXZhdGl2ZSBXb3Jrc1xuICAgICAgICAgIHRoYXQgWW91IGRpc3RyaWJ1dGUsIGFsbCBjb3B5cmlnaHQsIHBhdGVudCwgdHJhZGVtYXJrLCBhbmRcbiAgICAgICAgICBhdHRyaWJ1dGlvbiBub3RpY2VzIGZyb20gdGhlIFNvdXJjZSBmb3JtIG9mIHRoZSBXb3JrLFxuICAgICAgICAgIGV4Y2x1ZGluZyB0aG9zZSBub3RpY2VzIHRoYXQgZG8gbm90IHBlcnRhaW4gdG8gYW55IHBhcnQgb2ZcbiAgICAgICAgICB0aGUgRGVyaXZhdGl2ZSBXb3JrczsgYW5kXG5cbiAgICAgIChkKSBJZiB0aGUgV29yayBpbmNsdWRlcyBhIFwiTk9USUNFXCIgdGV4dCBmaWxlIGFzIHBhcnQgb2YgaXRzXG4gICAgICAgICAgZGlzdHJpYnV0aW9uLCB0aGVuIGFueSBEZXJpdmF0aXZlIFdvcmtzIHRoYXQgWW91IGRpc3RyaWJ1dGUgbXVzdFxuICAgICAgICAgIGluY2x1ZGUgYSByZWFkYWJsZSBjb3B5IG9mIHRoZSBhdHRyaWJ1dGlvbiBub3RpY2VzIGNvbnRhaW5lZFxuICAgICAgICAgIHdpdGhpbiBzdWNoIE5PVElDRSBmaWxlLCBleGNsdWRpbmcgdGhvc2Ugbm90aWNlcyB0aGF0IGRvIG5vdFxuICAgICAgICAgIHBlcnRhaW4gdG8gYW55IHBhcnQgb2YgdGhlIERlcml2YXRpdmUgV29ya3MsIGluIGF0IGxlYXN0IG9uZVxuICAgICAgICAgIG9mIHRoZSBmb2xsb3dpbmcgcGxhY2VzOiB3aXRoaW4gYSBOT1RJQ0UgdGV4dCBmaWxlIGRpc3RyaWJ1dGVkXG4gICAgICAgICAgYXMgcGFydCBvZiB0aGUgRGVyaXZhdGl2ZSBXb3Jrczsgd2l0aGluIHRoZSBTb3VyY2UgZm9ybSBvclxuICAgICAgICAgIGRvY3VtZW50YXRpb24sIGlmIHByb3ZpZGVkIGFsb25nIHdpdGggdGhlIERlcml2YXRpdmUgV29ya3M7IG9yLFxuICAgICAgICAgIHdpdGhpbiBhIGRpc3BsYXkgZ2VuZXJhdGVkIGJ5IHRoZSBEZXJpdmF0aXZlIFdvcmtzLCBpZiBhbmRcbiAgICAgICAgICB3aGVyZXZlciBzdWNoIHRoaXJkLXBhcnR5IG5vdGljZXMgbm9ybWFsbHkgYXBwZWFyLiBUaGUgY29udGVudHNcbiAgICAgICAgICBvZiB0aGUgTk9USUNFIGZpbGUgYXJlIGZvciBpbmZvcm1hdGlvbmFsIHB1cnBvc2VzIG9ubHkgYW5kXG4gICAgICAgICAgZG8gbm90IG1vZGlmeSB0aGUgTGljZW5zZS4gWW91IG1heSBhZGQgWW91ciBvd24gYXR0cmlidXRpb25cbiAgICAgICAgICBub3RpY2VzIHdpdGhpbiBEZXJpdmF0aXZlIFdvcmtzIHRoYXQgWW91IGRpc3RyaWJ1dGUsIGFsb25nc2lkZVxuICAgICAgICAgIG9yIGFzIGFuIGFkZGVuZHVtIHRvIHRoZSBOT1RJQ0UgdGV4dCBmcm9tIHRoZSBXb3JrLCBwcm92aWRlZFxuICAgICAgICAgIHRoYXQgc3VjaCBhZGRpdGlvbmFsIGF0dHJpYnV0aW9uIG5vdGljZXMgY2Fubm90IGJlIGNvbnN0cnVlZFxuICAgICAgICAgIGFzIG1vZGlmeWluZyB0aGUgTGljZW5zZS5cblxuICAgICAgWW91IG1heSBhZGQgWW91ciBvd24gY29weXJpZ2h0IHN0YXRlbWVudCB0byBZb3VyIG1vZGlmaWNhdGlvbnMgYW5kXG4gICAgICBtYXkgcHJvdmlkZSBhZGRpdGlvbmFsIG9yIGRpZmZlcmVudCBsaWNlbnNlIHRlcm1zIGFuZCBjb25kaXRpb25zXG4gICAgICBmb3IgdXNlLCByZXByb2R1Y3Rpb24sIG9yIGRpc3RyaWJ1dGlvbiBvZiBZb3VyIG1vZGlmaWNhdGlvbnMsIG9yXG4gICAgICBmb3IgYW55IHN1Y2ggRGVyaXZhdGl2ZSBXb3JrcyBhcyBhIHdob2xlLCBwcm92aWRlZCBZb3VyIHVzZSxcbiAgICAgIHJlcHJvZHVjdGlvbiwgYW5kIGRpc3RyaWJ1dGlvbiBvZiB0aGUgV29yayBvdGhlcndpc2UgY29tcGxpZXMgd2l0aFxuICAgICAgdGhlIGNvbmRpdGlvbnMgc3RhdGVkIGluIHRoaXMgTGljZW5zZS5cblxuICAgNS4gU3VibWlzc2lvbiBvZiBDb250cmlidXRpb25zLiBVbmxlc3MgWW91IGV4cGxpY2l0bHkgc3RhdGUgb3RoZXJ3aXNlLFxuICAgICAgYW55IENvbnRyaWJ1dGlvbiBpbnRlbnRpb25hbGx5IHN1Ym1pdHRlZCBmb3IgaW5jbHVzaW9uIGluIHRoZSBXb3JrXG4gICAgICBieSBZb3UgdG8gdGhlIExpY2Vuc29yIHNoYWxsIGJlIHVuZGVyIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZlxuICAgICAgdGhpcyBMaWNlbnNlLCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIHRlcm1zIG9yIGNvbmRpdGlvbnMuXG4gICAgICBOb3R3aXRoc3RhbmRpbmcgdGhlIGFib3ZlLCBub3RoaW5nIGhlcmVpbiBzaGFsbCBzdXBlcnNlZGUgb3IgbW9kaWZ5XG4gICAgICB0aGUgdGVybXMgb2YgYW55IHNlcGFyYXRlIGxpY2Vuc2UgYWdyZWVtZW50IHlvdSBtYXkgaGF2ZSBleGVjdXRlZFxuICAgICAgd2l0aCBMaWNlbnNvciByZWdhcmRpbmcgc3VjaCBDb250cmlidXRpb25zLlxuXG4gICA2LiBUcmFkZW1hcmtzLiBUaGlzIExpY2Vuc2UgZG9lcyBub3QgZ3JhbnQgcGVybWlzc2lvbiB0byB1c2UgdGhlIHRyYWRlXG4gICAgICBuYW1lcywgdHJhZGVtYXJrcywgc2VydmljZSBtYXJrcywgb3IgcHJvZHVjdCBuYW1lcyBvZiB0aGUgTGljZW5zb3IsXG4gICAgICBleGNlcHQgYXMgcmVxdWlyZWQgZm9yIHJlYXNvbmFibGUgYW5kIGN1c3RvbWFyeSB1c2UgaW4gZGVzY3JpYmluZyB0aGVcbiAgICAgIG9yaWdpbiBvZiB0aGUgV29yayBhbmQgcmVwcm9kdWNpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIE5PVElDRSBmaWxlLlxuXG4gICA3LiBEaXNjbGFpbWVyIG9mIFdhcnJhbnR5LiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3JcbiAgICAgIGFncmVlZCB0byBpbiB3cml0aW5nLCBMaWNlbnNvciBwcm92aWRlcyB0aGUgV29yayAoYW5kIGVhY2hcbiAgICAgIENvbnRyaWJ1dG9yIHByb3ZpZGVzIGl0cyBDb250cmlidXRpb25zKSBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3JcbiAgICAgIGltcGxpZWQsIGluY2x1ZGluZywgd2l0aG91dCBsaW1pdGF0aW9uLCBhbnkgd2FycmFudGllcyBvciBjb25kaXRpb25zXG4gICAgICBvZiBUSVRMRSwgTk9OLUlORlJJTkdFTUVOVCwgTUVSQ0hBTlRBQklMSVRZLCBvciBGSVRORVNTIEZPUiBBXG4gICAgICBQQVJUSUNVTEFSIFBVUlBPU0UuIFlvdSBhcmUgc29sZWx5IHJlc3BvbnNpYmxlIGZvciBkZXRlcm1pbmluZyB0aGVcbiAgICAgIGFwcHJvcHJpYXRlbmVzcyBvZiB1c2luZyBvciByZWRpc3RyaWJ1dGluZyB0aGUgV29yayBhbmQgYXNzdW1lIGFueVxuICAgICAgcmlza3MgYXNzb2NpYXRlZCB3aXRoIFlvdXIgZXhlcmNpc2Ugb2YgcGVybWlzc2lvbnMgdW5kZXIgdGhpcyBMaWNlbnNlLlxuXG4gICA4LiBMaW1pdGF0aW9uIG9mIExpYWJpbGl0eS4gSW4gbm8gZXZlbnQgYW5kIHVuZGVyIG5vIGxlZ2FsIHRoZW9yeSxcbiAgICAgIHdoZXRoZXIgaW4gdG9ydCAoaW5jbHVkaW5nIG5lZ2xpZ2VuY2UpLCBjb250cmFjdCwgb3Igb3RoZXJ3aXNlLFxuICAgICAgdW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IChzdWNoIGFzIGRlbGliZXJhdGUgYW5kIGdyb3NzbHlcbiAgICAgIG5lZ2xpZ2VudCBhY3RzKSBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc2hhbGwgYW55IENvbnRyaWJ1dG9yIGJlXG4gICAgICBsaWFibGUgdG8gWW91IGZvciBkYW1hZ2VzLCBpbmNsdWRpbmcgYW55IGRpcmVjdCwgaW5kaXJlY3QsIHNwZWNpYWwsXG4gICAgICBpbmNpZGVudGFsLCBvciBjb25zZXF1ZW50aWFsIGRhbWFnZXMgb2YgYW55IGNoYXJhY3RlciBhcmlzaW5nIGFzIGFcbiAgICAgIHJlc3VsdCBvZiB0aGlzIExpY2Vuc2Ugb3Igb3V0IG9mIHRoZSB1c2Ugb3IgaW5hYmlsaXR5IHRvIHVzZSB0aGVcbiAgICAgIFdvcmsgKGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gZGFtYWdlcyBmb3IgbG9zcyBvZiBnb29kd2lsbCxcbiAgICAgIHdvcmsgc3RvcHBhZ2UsIGNvbXB1dGVyIGZhaWx1cmUgb3IgbWFsZnVuY3Rpb24sIG9yIGFueSBhbmQgYWxsXG4gICAgICBvdGhlciBjb21tZXJjaWFsIGRhbWFnZXMgb3IgbG9zc2VzKSwgZXZlbiBpZiBzdWNoIENvbnRyaWJ1dG9yXG4gICAgICBoYXMgYmVlbiBhZHZpc2VkIG9mIHRoZSBwb3NzaWJpbGl0eSBvZiBzdWNoIGRhbWFnZXMuXG5cbiAgIDkuIEFjY2VwdGluZyBXYXJyYW50eSBvciBBZGRpdGlvbmFsIExpYWJpbGl0eS4gV2hpbGUgcmVkaXN0cmlidXRpbmdcbiAgICAgIHRoZSBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiwgWW91IG1heSBjaG9vc2UgdG8gb2ZmZXIsXG4gICAgICBhbmQgY2hhcmdlIGEgZmVlIGZvciwgYWNjZXB0YW5jZSBvZiBzdXBwb3J0LCB3YXJyYW50eSwgaW5kZW1uaXR5LFxuICAgICAgb3Igb3RoZXIgbGlhYmlsaXR5IG9ibGlnYXRpb25zIGFuZC9vciByaWdodHMgY29uc2lzdGVudCB3aXRoIHRoaXNcbiAgICAgIExpY2Vuc2UuIEhvd2V2ZXIsIGluIGFjY2VwdGluZyBzdWNoIG9ibGlnYXRpb25zLCBZb3UgbWF5IGFjdCBvbmx5XG4gICAgICBvbiBZb3VyIG93biBiZWhhbGYgYW5kIG9uIFlvdXIgc29sZSByZXNwb25zaWJpbGl0eSwgbm90IG9uIGJlaGFsZlxuICAgICAgb2YgYW55IG90aGVyIENvbnRyaWJ1dG9yLCBhbmQgb25seSBpZiBZb3UgYWdyZWUgdG8gaW5kZW1uaWZ5LFxuICAgICAgZGVmZW5kLCBhbmQgaG9sZCBlYWNoIENvbnRyaWJ1dG9yIGhhcm1sZXNzIGZvciBhbnkgbGlhYmlsaXR5XG4gICAgICBpbmN1cnJlZCBieSwgb3IgY2xhaW1zIGFzc2VydGVkIGFnYWluc3QsIHN1Y2ggQ29udHJpYnV0b3IgYnkgcmVhc29uXG4gICAgICBvZiB5b3VyIGFjY2VwdGluZyBhbnkgc3VjaCB3YXJyYW50eSBvciBhZGRpdGlvbmFsIGxpYWJpbGl0eS5cblxuICAgRU5EIE9GIFRFUk1TIEFORCBDT05ESVRJT05TXG5cbiAgIEFQUEVORElYOiBIb3cgdG8gYXBwbHkgdGhlIEFwYWNoZSBMaWNlbnNlIHRvIHlvdXIgd29yay5cblxuICAgICAgVG8gYXBwbHkgdGhlIEFwYWNoZSBMaWNlbnNlIHRvIHlvdXIgd29yaywgYXR0YWNoIHRoZSBmb2xsb3dpbmdcbiAgICAgIGJvaWxlcnBsYXRlIG5vdGljZSwgd2l0aCB0aGUgZmllbGRzIGVuY2xvc2VkIGJ5IGJyYWNrZXRzIFwie31cIlxuICAgICAgcmVwbGFjZWQgd2l0aCB5b3VyIG93biBpZGVudGlmeWluZyBpbmZvcm1hdGlvbi4gKERvbid0IGluY2x1ZGVcbiAgICAgIHRoZSBicmFja2V0cyEpICBUaGUgdGV4dCBzaG91bGQgYmUgZW5jbG9zZWQgaW4gdGhlIGFwcHJvcHJpYXRlXG4gICAgICBjb21tZW50IHN5bnRheCBmb3IgdGhlIGZpbGUgZm9ybWF0LiBXZSBhbHNvIHJlY29tbWVuZCB0aGF0IGFcbiAgICAgIGZpbGUgb3IgY2xhc3MgbmFtZSBhbmQgZGVzY3JpcHRpb24gb2YgcHVycG9zZSBiZSBpbmNsdWRlZCBvbiB0aGVcbiAgICAgIHNhbWUgXCJwcmludGVkIHBhZ2VcIiBhcyB0aGUgY29weXJpZ2h0IG5vdGljZSBmb3IgZWFzaWVyXG4gICAgICBpZGVudGlmaWNhdGlvbiB3aXRoaW4gdGhpcmQtcGFydHkgYXJjaGl2ZXMuXG5cbiAgIENvcHlyaWdodCB7eXl5eX0ge25hbWUgb2YgY29weXJpZ2h0IG93bmVyfVxuXG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblNWRC5zdmQgPSBmdW5jdGlvbiAoQSkge1xuICB0aGlzLlUgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuICB0aGlzLnMgPSBudWxsO1xuICB0aGlzLm0gPSAwO1xuICB0aGlzLm4gPSAwO1xuICB0aGlzLm0gPSBBLmxlbmd0aDtcbiAgdGhpcy5uID0gQVswXS5sZW5ndGg7XG4gIHZhciBudSA9IE1hdGgubWluKHRoaXMubSwgdGhpcy5uKTtcbiAgdGhpcy5zID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHdoaWxlIChzLS0gPiAwKSB7XG4gICAgICBhLnB1c2goMCk7XG4gICAgfXJldHVybiBhO1xuICB9KE1hdGgubWluKHRoaXMubSArIDEsIHRoaXMubikpO1xuICB0aGlzLlUgPSBmdW5jdGlvbiAoZGltcykge1xuICAgIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlKGRpbXMpIHtcbiAgICAgIGlmIChkaW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltc1swXTsgaSsrKSB7XG4gICAgICAgICAgYXJyYXkucHVzaChhbGxvY2F0ZShkaW1zLnNsaWNlKDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFsbG9jYXRlKGRpbXMpO1xuICB9KFt0aGlzLm0sIG51XSk7XG4gIHRoaXMuViA9IGZ1bmN0aW9uIChkaW1zKSB7XG4gICAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gYWxsb2NhdGUoZGltcykge1xuICAgICAgaWYgKGRpbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1zWzBdOyBpKyspIHtcbiAgICAgICAgICBhcnJheS5wdXNoKGFsbG9jYXRlKGRpbXMuc2xpY2UoMSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYWxsb2NhdGUoZGltcyk7XG4gIH0oW3RoaXMubiwgdGhpcy5uXSk7XG4gIHZhciBlID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHdoaWxlIChzLS0gPiAwKSB7XG4gICAgICBhLnB1c2goMCk7XG4gICAgfXJldHVybiBhO1xuICB9KHRoaXMubik7XG4gIHZhciB3b3JrID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHdoaWxlIChzLS0gPiAwKSB7XG4gICAgICBhLnB1c2goMCk7XG4gICAgfXJldHVybiBhO1xuICB9KHRoaXMubSk7XG4gIHZhciB3YW50dSA9IHRydWU7XG4gIHZhciB3YW50diA9IHRydWU7XG4gIHZhciBuY3QgPSBNYXRoLm1pbih0aGlzLm0gLSAxLCB0aGlzLm4pO1xuICB2YXIgbnJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5uIC0gMiwgdGhpcy5tKSk7XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgTWF0aC5tYXgobmN0LCBucnQpOyBrKyspIHtcbiAgICBpZiAoayA8IG5jdCkge1xuICAgICAgdGhpcy5zW2tdID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSBrOyBpIDwgdGhpcy5tOyBpKyspIHtcbiAgICAgICAgdGhpcy5zW2tdID0gU1ZELmh5cG90KHRoaXMuc1trXSwgQVtpXVtrXSk7XG4gICAgICB9XG4gICAgICA7XG4gICAgICBpZiAodGhpcy5zW2tdICE9PSAwLjApIHtcbiAgICAgICAgaWYgKEFba11ba10gPCAwLjApIHtcbiAgICAgICAgICB0aGlzLnNba10gPSAtdGhpcy5zW2tdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gazsgX2kgPCB0aGlzLm07IF9pKyspIHtcbiAgICAgICAgICBBW19pXVtrXSAvPSB0aGlzLnNba107XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBBW2tdW2tdICs9IDEuMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc1trXSA9IC10aGlzLnNba107XG4gICAgfVxuICAgIGZvciAodmFyIGogPSBrICsgMTsgaiA8IHRoaXMubjsgaisrKSB7XG4gICAgICBpZiAoZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiBsaHMgJiYgcmhzO1xuICAgICAgfShrIDwgbmN0LCB0aGlzLnNba10gIT09IDAuMCkpIHtcbiAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSBrOyBfaTIgPCB0aGlzLm07IF9pMisrKSB7XG4gICAgICAgICAgdCArPSBBW19pMl1ba10gKiBBW19pMl1bal07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB0ID0gLXQgLyBBW2tdW2tdO1xuICAgICAgICBmb3IgKHZhciBfaTMgPSBrOyBfaTMgPCB0aGlzLm07IF9pMysrKSB7XG4gICAgICAgICAgQVtfaTNdW2pdICs9IHQgKiBBW19pM11ba107XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgfVxuICAgICAgZVtqXSA9IEFba11bal07XG4gICAgfVxuICAgIDtcbiAgICBpZiAoZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICByZXR1cm4gbGhzICYmIHJocztcbiAgICB9KHdhbnR1LCBrIDwgbmN0KSkge1xuICAgICAgZm9yICh2YXIgX2k0ID0gazsgX2k0IDwgdGhpcy5tOyBfaTQrKykge1xuICAgICAgICB0aGlzLlVbX2k0XVtrXSA9IEFbX2k0XVtrXTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICB9XG4gICAgaWYgKGsgPCBucnQpIHtcbiAgICAgIGVba10gPSAwO1xuICAgICAgZm9yICh2YXIgX2k1ID0gayArIDE7IF9pNSA8IHRoaXMubjsgX2k1KyspIHtcbiAgICAgICAgZVtrXSA9IFNWRC5oeXBvdChlW2tdLCBlW19pNV0pO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgaWYgKGVba10gIT09IDAuMCkge1xuICAgICAgICBpZiAoZVtrICsgMV0gPCAwLjApIHtcbiAgICAgICAgICBlW2tdID0gLWVba107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2k2ID0gayArIDE7IF9pNiA8IHRoaXMubjsgX2k2KyspIHtcbiAgICAgICAgICBlW19pNl0gLz0gZVtrXTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGVbayArIDFdICs9IDEuMDtcbiAgICAgIH1cbiAgICAgIGVba10gPSAtZVtrXTtcbiAgICAgIGlmIChmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIGxocyAmJiByaHM7XG4gICAgICB9KGsgKyAxIDwgdGhpcy5tLCBlW2tdICE9PSAwLjApKSB7XG4gICAgICAgIGZvciAodmFyIF9pNyA9IGsgKyAxOyBfaTcgPCB0aGlzLm07IF9pNysrKSB7XG4gICAgICAgICAgd29ya1tfaTddID0gMC4wO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZm9yICh2YXIgX2ogPSBrICsgMTsgX2ogPCB0aGlzLm47IF9qKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTggPSBrICsgMTsgX2k4IDwgdGhpcy5tOyBfaTgrKykge1xuICAgICAgICAgICAgd29ya1tfaThdICs9IGVbX2pdICogQVtfaThdW19qXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gayArIDE7IF9qMiA8IHRoaXMubjsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX3QgPSAtZVtfajJdIC8gZVtrICsgMV07XG4gICAgICAgICAgZm9yICh2YXIgX2k5ID0gayArIDE7IF9pOSA8IHRoaXMubTsgX2k5KyspIHtcbiAgICAgICAgICAgIEFbX2k5XVtfajJdICs9IF90ICogd29ya1tfaTldO1xuICAgICAgICAgIH1cbiAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgfVxuICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgIGZvciAodmFyIF9pMTAgPSBrICsgMTsgX2kxMCA8IHRoaXMubjsgX2kxMCsrKSB7XG4gICAgICAgICAgdGhpcy5WW19pMTBdW2tdID0gZVtfaTEwXTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBwID0gTWF0aC5taW4odGhpcy5uLCB0aGlzLm0gKyAxKTtcbiAgaWYgKG5jdCA8IHRoaXMubikge1xuICAgIHRoaXMuc1tuY3RdID0gQVtuY3RdW25jdF07XG4gIH1cbiAgaWYgKHRoaXMubSA8IHApIHtcbiAgICB0aGlzLnNbcCAtIDFdID0gMC4wO1xuICB9XG4gIGlmIChucnQgKyAxIDwgcCkge1xuICAgIGVbbnJ0XSA9IEFbbnJ0XVtwIC0gMV07XG4gIH1cbiAgZVtwIC0gMV0gPSAwLjA7XG4gIGlmICh3YW50dSkge1xuICAgIGZvciAodmFyIF9qMyA9IG5jdDsgX2ozIDwgbnU7IF9qMysrKSB7XG4gICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IHRoaXMubTsgX2kxMSsrKSB7XG4gICAgICAgIHRoaXMuVVtfaTExXVtfajNdID0gMC4wO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgdGhpcy5VW19qM11bX2ozXSA9IDEuMDtcbiAgICB9O1xuICAgIGZvciAodmFyIF9rID0gbmN0IC0gMTsgX2sgPj0gMDsgX2stLSkge1xuICAgICAgaWYgKHRoaXMuc1tfa10gIT09IDAuMCkge1xuICAgICAgICBmb3IgKHZhciBfajQgPSBfayArIDE7IF9qNCA8IG51OyBfajQrKykge1xuICAgICAgICAgIHZhciBfdDIgPSAwO1xuICAgICAgICAgIGZvciAodmFyIF9pMTIgPSBfazsgX2kxMiA8IHRoaXMubTsgX2kxMisrKSB7XG4gICAgICAgICAgICBfdDIgKz0gdGhpcy5VW19pMTJdW19rXSAqIHRoaXMuVVtfaTEyXVtfajRdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3QyID0gLV90MiAvIHRoaXMuVVtfa11bX2tdO1xuICAgICAgICAgIGZvciAodmFyIF9pMTMgPSBfazsgX2kxMyA8IHRoaXMubTsgX2kxMysrKSB7XG4gICAgICAgICAgICB0aGlzLlVbX2kxM11bX2o0XSArPSBfdDIgKiB0aGlzLlVbX2kxM11bX2tdO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pMTQgPSBfazsgX2kxNCA8IHRoaXMubTsgX2kxNCsrKSB7XG4gICAgICAgICAgdGhpcy5VW19pMTRdW19rXSA9IC10aGlzLlVbX2kxNF1bX2tdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLlVbX2tdW19rXSA9IDEuMCArIHRoaXMuVVtfa11bX2tdO1xuICAgICAgICBmb3IgKHZhciBfaTE1ID0gMDsgX2kxNSA8IF9rIC0gMTsgX2kxNSsrKSB7XG4gICAgICAgICAgdGhpcy5VW19pMTVdW19rXSA9IDAuMDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pMTYgPSAwOyBfaTE2IDwgdGhpcy5tOyBfaTE2KyspIHtcbiAgICAgICAgICB0aGlzLlVbX2kxNl1bX2tdID0gMC4wO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLlVbX2tdW19rXSA9IDEuMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGlmICh3YW50dikge1xuICAgIGZvciAodmFyIF9rMiA9IHRoaXMubiAtIDE7IF9rMiA+PSAwOyBfazItLSkge1xuICAgICAgaWYgKGZ1bmN0aW9uIChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gbGhzICYmIHJocztcbiAgICAgIH0oX2syIDwgbnJ0LCBlW19rMl0gIT09IDAuMCkpIHtcbiAgICAgICAgZm9yICh2YXIgX2o1ID0gX2syICsgMTsgX2o1IDwgbnU7IF9qNSsrKSB7XG4gICAgICAgICAgdmFyIF90MyA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgX2kxNyA9IF9rMiArIDE7IF9pMTcgPCB0aGlzLm47IF9pMTcrKykge1xuICAgICAgICAgICAgX3QzICs9IHRoaXMuVltfaTE3XVtfazJdICogdGhpcy5WW19pMTddW19qNV07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdDMgPSAtX3QzIC8gdGhpcy5WW19rMiArIDFdW19rMl07XG4gICAgICAgICAgZm9yICh2YXIgX2kxOCA9IF9rMiArIDE7IF9pMTggPCB0aGlzLm47IF9pMTgrKykge1xuICAgICAgICAgICAgdGhpcy5WW19pMThdW19qNV0gKz0gX3QzICogdGhpcy5WW19pMThdW19rMl07XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMTkgPSAwOyBfaTE5IDwgdGhpcy5uOyBfaTE5KyspIHtcbiAgICAgICAgdGhpcy5WW19pMTldW19rMl0gPSAwLjA7XG4gICAgICB9O1xuICAgICAgdGhpcy5WW19rMl1bX2syXSA9IDEuMDtcbiAgICB9O1xuICB9XG4gIHZhciBwcCA9IHAgLSAxO1xuICB2YXIgaXRlciA9IDA7XG4gIHZhciBlcHMgPSBNYXRoLnBvdygyLjAsIC01Mi4wKTtcbiAgdmFyIHRpbnkgPSBNYXRoLnBvdygyLjAsIC05NjYuMCk7XG4gIHdoaWxlIChwID4gMCkge1xuICAgIHZhciBfazMgPSB2b2lkIDA7XG4gICAgdmFyIGthc2UgPSB2b2lkIDA7XG4gICAgZm9yIChfazMgPSBwIC0gMjsgX2szID49IC0xOyBfazMtLSkge1xuICAgICAgaWYgKF9rMyA9PT0gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoZVtfazNdKSA8PSB0aW55ICsgZXBzICogKE1hdGguYWJzKHRoaXMuc1tfazNdKSArIE1hdGguYWJzKHRoaXMuc1tfazMgKyAxXSkpKSB7XG4gICAgICAgIGVbX2szXSA9IDAuMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoX2szID09PSBwIC0gMikge1xuICAgICAga2FzZSA9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrcyA9IHZvaWQgMDtcbiAgICAgIGZvciAoa3MgPSBwIC0gMTsga3MgPj0gX2szOyBrcy0tKSB7XG4gICAgICAgIGlmIChrcyA9PT0gX2szKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90NCA9IChrcyAhPT0gcCA/IE1hdGguYWJzKGVba3NdKSA6IDAuMCkgKyAoa3MgIT09IF9rMyArIDEgPyBNYXRoLmFicyhlW2tzIC0gMV0pIDogMC4wKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuc1trc10pIDw9IHRpbnkgKyBlcHMgKiBfdDQpIHtcbiAgICAgICAgICB0aGlzLnNba3NdID0gMC4wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGtzID09PSBfazMpIHtcbiAgICAgICAga2FzZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKGtzID09PSBwIC0gMSkge1xuICAgICAgICBrYXNlID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGthc2UgPSAyO1xuICAgICAgICBfazMgPSBrcztcbiAgICAgIH1cbiAgICB9XG4gICAgX2szKys7XG4gICAgc3dpdGNoIChrYXNlKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZiA9IGVbcCAtIDJdO1xuICAgICAgICAgIGVbcCAtIDJdID0gMC4wO1xuICAgICAgICAgIGZvciAodmFyIF9qNiA9IHAgLSAyOyBfajYgPj0gX2szOyBfajYtLSkge1xuICAgICAgICAgICAgdmFyIF90NSA9IFNWRC5oeXBvdCh0aGlzLnNbX2o2XSwgZik7XG4gICAgICAgICAgICB2YXIgY3MgPSB0aGlzLnNbX2o2XSAvIF90NTtcbiAgICAgICAgICAgIHZhciBzbiA9IGYgLyBfdDU7XG4gICAgICAgICAgICB0aGlzLnNbX2o2XSA9IF90NTtcbiAgICAgICAgICAgIGlmIChfajYgIT09IF9rMykge1xuICAgICAgICAgICAgICBmID0gLXNuICogZVtfajYgLSAxXTtcbiAgICAgICAgICAgICAgZVtfajYgLSAxXSA9IGNzICogZVtfajYgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTIwID0gMDsgX2kyMCA8IHRoaXMubjsgX2kyMCsrKSB7XG4gICAgICAgICAgICAgICAgX3Q1ID0gY3MgKiB0aGlzLlZbX2kyMF1bX2o2XSArIHNuICogdGhpcy5WW19pMjBdW3AgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyMF1bcCAtIDFdID0gLXNuICogdGhpcy5WW19pMjBdW19qNl0gKyBjcyAqIHRoaXMuVltfaTIwXVtwIC0gMV07XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjBdW19qNl0gPSBfdDU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2YgPSBlW19rMyAtIDFdO1xuICAgICAgICAgIGVbX2szIC0gMV0gPSAwLjA7XG4gICAgICAgICAgZm9yICh2YXIgX2o3ID0gX2szOyBfajcgPCBwOyBfajcrKykge1xuICAgICAgICAgICAgdmFyIF90NiA9IFNWRC5oeXBvdCh0aGlzLnNbX2o3XSwgX2YpO1xuICAgICAgICAgICAgdmFyIF9jcyA9IHRoaXMuc1tfajddIC8gX3Q2O1xuICAgICAgICAgICAgdmFyIF9zbiA9IF9mIC8gX3Q2O1xuICAgICAgICAgICAgdGhpcy5zW19qN10gPSBfdDY7XG4gICAgICAgICAgICBfZiA9IC1fc24gKiBlW19qN107XG4gICAgICAgICAgICBlW19qN10gPSBfY3MgKiBlW19qN107XG4gICAgICAgICAgICBpZiAod2FudHUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMSA9IDA7IF9pMjEgPCB0aGlzLm07IF9pMjErKykge1xuICAgICAgICAgICAgICAgIF90NiA9IF9jcyAqIHRoaXMuVVtfaTIxXVtfajddICsgX3NuICogdGhpcy5VW19pMjFdW19rMyAtIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVVtfaTIxXVtfazMgLSAxXSA9IC1fc24gKiB0aGlzLlVbX2kyMV1bX2o3XSArIF9jcyAqIHRoaXMuVVtfaTIxXVtfazMgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlVbX2kyMV1bX2o3XSA9IF90NjtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWF4KE1hdGguYWJzKHRoaXMuc1twIC0gMV0pLCBNYXRoLmFicyh0aGlzLnNbcCAtIDJdKSksIE1hdGguYWJzKGVbcCAtIDJdKSksIE1hdGguYWJzKHRoaXMuc1tfazNdKSksIE1hdGguYWJzKGVbX2szXSkpO1xuICAgICAgICAgIHZhciBzcCA9IHRoaXMuc1twIC0gMV0gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgc3BtMSA9IHRoaXMuc1twIC0gMl0gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgZXBtMSA9IGVbcCAtIDJdIC8gc2NhbGU7XG4gICAgICAgICAgdmFyIHNrID0gdGhpcy5zW19rM10gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgZWsgPSBlW19rM10gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgYiA9ICgoc3BtMSArIHNwKSAqIChzcG0xIC0gc3ApICsgZXBtMSAqIGVwbTEpIC8gMi4wO1xuICAgICAgICAgIHZhciBjID0gc3AgKiBlcG0xICogKHNwICogZXBtMSk7XG4gICAgICAgICAgdmFyIHNoaWZ0ID0gMC4wO1xuICAgICAgICAgIGlmIChmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgICAgIHJldHVybiBsaHMgfHwgcmhzO1xuICAgICAgICAgIH0oYiAhPT0gMC4wLCBjICE9PSAwLjApKSB7XG4gICAgICAgICAgICBzaGlmdCA9IE1hdGguc3FydChiICogYiArIGMpO1xuICAgICAgICAgICAgaWYgKGIgPCAwLjApIHtcbiAgICAgICAgICAgICAgc2hpZnQgPSAtc2hpZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGlmdCA9IGMgLyAoYiArIHNoaWZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9mMiA9IChzayArIHNwKSAqIChzayAtIHNwKSArIHNoaWZ0O1xuICAgICAgICAgIHZhciBnID0gc2sgKiBlaztcbiAgICAgICAgICBmb3IgKHZhciBfajggPSBfazM7IF9qOCA8IHAgLSAxOyBfajgrKykge1xuICAgICAgICAgICAgdmFyIF90NyA9IFNWRC5oeXBvdChfZjIsIGcpO1xuICAgICAgICAgICAgdmFyIF9jczIgPSBfZjIgLyBfdDc7XG4gICAgICAgICAgICB2YXIgX3NuMiA9IGcgLyBfdDc7XG4gICAgICAgICAgICBpZiAoX2o4ICE9PSBfazMpIHtcbiAgICAgICAgICAgICAgZVtfajggLSAxXSA9IF90NztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mMiA9IF9jczIgKiB0aGlzLnNbX2o4XSArIF9zbjIgKiBlW19qOF07XG4gICAgICAgICAgICBlW19qOF0gPSBfY3MyICogZVtfajhdIC0gX3NuMiAqIHRoaXMuc1tfajhdO1xuICAgICAgICAgICAgZyA9IF9zbjIgKiB0aGlzLnNbX2o4ICsgMV07XG4gICAgICAgICAgICB0aGlzLnNbX2o4ICsgMV0gPSBfY3MyICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjIgPSAwOyBfaTIyIDwgdGhpcy5uOyBfaTIyKyspIHtcbiAgICAgICAgICAgICAgICBfdDcgPSBfY3MyICogdGhpcy5WW19pMjJdW19qOF0gKyBfc24yICogdGhpcy5WW19pMjJdW19qOCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTIyXVtfajggKyAxXSA9IC1fc24yICogdGhpcy5WW19pMjJdW19qOF0gKyBfY3MyICogdGhpcy5WW19pMjJdW19qOCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTIyXVtfajhdID0gX3Q3O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3Q3ID0gU1ZELmh5cG90KF9mMiwgZyk7XG4gICAgICAgICAgICBfY3MyID0gX2YyIC8gX3Q3O1xuICAgICAgICAgICAgX3NuMiA9IGcgLyBfdDc7XG4gICAgICAgICAgICB0aGlzLnNbX2o4XSA9IF90NztcbiAgICAgICAgICAgIF9mMiA9IF9jczIgKiBlW19qOF0gKyBfc24yICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgdGhpcy5zW19qOCArIDFdID0gLV9zbjIgKiBlW19qOF0gKyBfY3MyICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgZyA9IF9zbjIgKiBlW19qOCArIDFdO1xuICAgICAgICAgICAgZVtfajggKyAxXSA9IF9jczIgKiBlW19qOCArIDFdO1xuICAgICAgICAgICAgaWYgKHdhbnR1ICYmIF9qOCA8IHRoaXMubSAtIDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMyA9IDA7IF9pMjMgPCB0aGlzLm07IF9pMjMrKykge1xuICAgICAgICAgICAgICAgIF90NyA9IF9jczIgKiB0aGlzLlVbX2kyM11bX2o4XSArIF9zbjIgKiB0aGlzLlVbX2kyM11bX2o4ICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjNdW19qOCArIDFdID0gLV9zbjIgKiB0aGlzLlVbX2kyM11bX2o4XSArIF9jczIgKiB0aGlzLlVbX2kyM11bX2o4ICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjNdW19qOF0gPSBfdDc7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlW3AgLSAyXSA9IF9mMjtcbiAgICAgICAgICBpdGVyID0gaXRlciArIDE7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuc1tfazNdIDw9IDAuMCkge1xuICAgICAgICAgICAgdGhpcy5zW19rM10gPSB0aGlzLnNbX2szXSA8IDAuMCA/IC10aGlzLnNbX2szXSA6IDAuMDtcbiAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTI0ID0gMDsgX2kyNCA8PSBwcDsgX2kyNCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjRdW19rM10gPSAtdGhpcy5WW19pMjRdW19rM107XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChfazMgPCBwcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc1tfazNdID49IHRoaXMuc1tfazMgKyAxXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdDggPSB0aGlzLnNbX2szXTtcbiAgICAgICAgICAgIHRoaXMuc1tfazNdID0gdGhpcy5zW19rMyArIDFdO1xuICAgICAgICAgICAgdGhpcy5zW19rMyArIDFdID0gX3Q4O1xuICAgICAgICAgICAgaWYgKHdhbnR2ICYmIF9rMyA8IHRoaXMubiAtIDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyNSA9IDA7IF9pMjUgPCB0aGlzLm47IF9pMjUrKykge1xuICAgICAgICAgICAgICAgIF90OCA9IHRoaXMuVltfaTI1XVtfazMgKyAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyNV1bX2szICsgMV0gPSB0aGlzLlZbX2kyNV1bX2szXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyNV1bX2szXSA9IF90ODtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YW50dSAmJiBfazMgPCB0aGlzLm0gLSAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjYgPSAwOyBfaTI2IDwgdGhpcy5tOyBfaTI2KyspIHtcbiAgICAgICAgICAgICAgICBfdDggPSB0aGlzLlVbX2kyNl1bX2szICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjZdW19rMyArIDFdID0gdGhpcy5VW19pMjZdW19rM107XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjZdW19rM10gPSBfdDg7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfazMrKztcbiAgICAgICAgICB9O1xuICAgICAgICAgIGl0ZXIgPSAwO1xuICAgICAgICAgIHAtLTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICB2YXIgcmVzdWx0ID0geyBVOiB0aGlzLlUsIFY6IHRoaXMuViwgUzogdGhpcy5zIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBzcXJ0KGFeMiArIGJeMikgd2l0aG91dCB1bmRlci9vdmVyZmxvdy5cblNWRC5oeXBvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciByID0gdm9pZCAwO1xuICBpZiAoTWF0aC5hYnMoYSkgPiBNYXRoLmFicyhiKSkge1xuICAgIHIgPSBiIC8gYTtcbiAgICByID0gTWF0aC5hYnMoYSkgKiBNYXRoLnNxcnQoMSArIHIgKiByKTtcbiAgfSBlbHNlIGlmIChiICE9IDApIHtcbiAgICByID0gYSAvIGI7XG4gICAgciA9IE1hdGguYWJzKGIpICogTWF0aC5zcXJ0KDEgKyByICogcik7XG4gIH0gZWxzZSB7XG4gICAgciA9IDAuMDtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZEO1xuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogICBOZWVkbGVtYW4tV3Vuc2NoIGFsZ29yaXRobSBpcyBhbiBwcm9jZWR1cmUgdG8gY29tcHV0ZSB0aGUgb3B0aW1hbCBnbG9iYWwgYWxpZ25tZW50IG9mIHR3byBzdHJpbmdcbiAqICAgc2VxdWVuY2VzIGJ5IFMuQi5OZWVkbGVtYW4gYW5kIEMuRC5XdW5zY2ggKDE5NzApLlxuICpcbiAqICAgQXNpZGUgZnJvbSB0aGUgaW5wdXRzLCB5b3UgY2FuIGFzc2lnbiB0aGUgc2NvcmVzIGZvcixcbiAqICAgLSBNYXRjaDogVGhlIHR3byBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IGluZGV4IGFyZSBzYW1lLlxuICogICAtIE1pc21hdGNoOiBUaGUgdHdvIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgaW5kZXggYXJlIGRpZmZlcmVudC5cbiAqICAgLSBJbnNlcnRpb24vRGVsZXRpb24oZ2Fwcyk6IFRoZSBiZXN0IGFsaWdubWVudCBpbnZvbHZlcyBvbmUgbGV0dGVyIGFsaWduaW5nIHRvIGEgZ2FwIGluIHRoZSBvdGhlciBzdHJpbmcuXG4gKi9cblxudmFyIE5lZWRsZW1hbld1bnNjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZWVkbGVtYW5XdW5zY2goc2VxdWVuY2UxLCBzZXF1ZW5jZTIpIHtcbiAgICAgICAgdmFyIG1hdGNoX3Njb3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgICAgICB2YXIgbWlzbWF0Y2hfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogLTE7XG4gICAgICAgIHZhciBnYXBfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogLTE7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5lZWRsZW1hbld1bnNjaCk7XG5cbiAgICAgICAgdGhpcy5zZXF1ZW5jZTEgPSBzZXF1ZW5jZTE7XG4gICAgICAgIHRoaXMuc2VxdWVuY2UyID0gc2VxdWVuY2UyO1xuICAgICAgICB0aGlzLm1hdGNoX3Njb3JlID0gbWF0Y2hfc2NvcmU7XG4gICAgICAgIHRoaXMubWlzbWF0Y2hfcGVuYWx0eSA9IG1pc21hdGNoX3BlbmFsdHk7XG4gICAgICAgIHRoaXMuZ2FwX3BlbmFsdHkgPSBnYXBfcGVuYWx0eTtcblxuICAgICAgICAvLyBKdXN0IHRoZSByZW1vdmUgcmVkdW5kYW5jeVxuICAgICAgICB0aGlzLmlNYXggPSBzZXF1ZW5jZTEubGVuZ3RoICsgMTtcbiAgICAgICAgdGhpcy5qTWF4ID0gc2VxdWVuY2UyLmxlbmd0aCArIDE7XG5cbiAgICAgICAgLy8gR3JpZCBtYXRyaXggb2Ygc2NvcmVzXG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBBcnJheSh0aGlzLmlNYXgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaU1heDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRbaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjZWJhY2sgbWF0cml4ICgyRCBhcnJheSwgZWFjaCBjZWxsIGlzIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzIGZvciBbYERpYWdgLCBgVXBgLCBgTGVmdGBdIHBvc2l0aW9ucylcbiAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkID0gbmV3IEFycmF5KHRoaXMuaU1heCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmlNYXg7IF9pKyspIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHRoaXMuak1heDsgX2orKykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV1bX2pdID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGFsaWduZWQgc2VxdWVuY2VzIChyZXR1cm4gbXVsdGlwbGUgcG9zc2liaWxpdGllcylcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgLy8gRmluYWwgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgIHRoaXMuc2NvcmUgPSAtMTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NvcmVzIGFuZCB0cmFjZWJhY2tzXG4gICAgICAgIHRoaXMuY29tcHV0ZUdyaWRzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE5lZWRsZW1hbld1bnNjaCwgW3tcbiAgICAgICAga2V5OiBcImdldFNjb3JlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY29yZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3JlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0QWxpZ25tZW50c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxpZ25tZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWluIGR5bmFtaWMgcHJvZ3JhbW1pbmcgcHJvY2VkdXJlXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb21wdXRlR3JpZHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVHcmlkcygpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIGZpcnN0IHJvd1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFswXVtqXSA9IHRoaXMuZ3JpZFswXVtqIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFswXVtqXSA9IFtmYWxzZSwgZmFsc2UsIHRydWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIGluIHRoZSBmaXJzdCBjb2x1bW5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbaV1bMF0gPSB0aGlzLmdyaWRbaSAtIDFdWzBdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbaV1bMF0gPSBbZmFsc2UsIHRydWUsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCB0aGUgcmVzdCBvZiB0aGUgZ3JpZFxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMTsgX2kyIDwgdGhpcy5pTWF4OyBfaTIrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9qMiA9IDE7IF9qMiA8IHRoaXMuak1heDsgX2oyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF4IHNjb3JlKHMpIGFtb25nIFtgRGlhZ2AsIGBVcGAsIGBMZWZ0YF1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWcgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbmNlMVtfaTIgLSAxXSA9PT0gdGhpcy5zZXF1ZW5jZTJbX2oyIC0gMV0pIGRpYWcgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyIC0gMV0gKyB0aGlzLm1hdGNoX3Njb3JlO2Vsc2UgZGlhZyA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajIgLSAxXSArIHRoaXMubWlzbWF0Y2hfcGVuYWx0eTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXAgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5ncmlkW19pMl1bX2oyIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBtdWx0aXBsZSBtYXggdmFsdWVzLCBjYXB0dXJlIHRoZW0gZm9yIG11bHRpcGxlIHBhdGhzXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhPZiA9IFtkaWFnLCB1cCwgbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5hcnJheUFsbE1heEluZGV4ZXMobWF4T2YpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBHcmlkc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRbX2kyXVtfajJdID0gbWF4T2ZbaW5kaWNlc1swXV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaTJdW19qMl0gPSBbaW5kaWNlcy5pbmNsdWRlcygwKSwgaW5kaWNlcy5pbmNsdWRlcygxKSwgaW5kaWNlcy5pbmNsdWRlcygyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgICAgICB0aGlzLnNjb3JlID0gdGhpcy5ncmlkW3RoaXMuaU1heCAtIDFdW3RoaXMuak1heCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0cyBhbGwgcG9zc2libGUgdmFsaWQgc2VxdWVuY2UgY29tYmluYXRpb25zXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbGlnbm1lbnRUcmFjZWJhY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFsaWdubWVudFRyYWNlYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBpblByb2Nlc3NBbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW3RoaXMuc2VxdWVuY2UxLmxlbmd0aCwgdGhpcy5zZXF1ZW5jZTIubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICBzZXExOiBcIlwiLFxuICAgICAgICAgICAgICAgIHNlcTI6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5Qcm9jZXNzQWxpZ25tZW50c1swXSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gaW5Qcm9jZXNzQWxpZ25tZW50c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IHRoaXMudHJhY2ViYWNrR3JpZFtjdXJyZW50LnBvc1swXV1bY3VycmVudC5wb3NbMV1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0gLSAxLCBjdXJyZW50LnBvc1sxXSAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6IHRoaXMuc2VxdWVuY2UyW2N1cnJlbnQucG9zWzFdIC0gMV0gKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW2N1cnJlbnQucG9zWzBdIC0gMSwgY3VycmVudC5wb3NbMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6ICctJyArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0sIGN1cnJlbnQucG9zWzFdIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiAnLScgKyBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEyOiB0aGlzLnNlcXVlbmNlMltjdXJyZW50LnBvc1sxXSAtIDFdICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBvc1swXSA9PT0gMCAmJiBjdXJyZW50LnBvc1sxXSA9PT0gMCkgdGhpcy5hbGlnbm1lbnRzLnB1c2goeyBzZXF1ZW5jZTE6IGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2UyOiBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25tZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlbHBlciBGdW5jdGlvbnNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldEFsbEluZGV4ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbEluZGV4ZXMoYXJyLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKChpID0gYXJyLmluZGV4T2YodmFsLCBpICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYXJyYXlBbGxNYXhJbmRleGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcnJheUFsbE1heEluZGV4ZXMoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbEluZGV4ZXMoYXJyYXksIE1hdGgubWF4LmFwcGx5KG51bGwsIGFycmF5KSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTmVlZGxlbWFuV3Vuc2NoO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5lZWRsZW1hbld1bnNjaDtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbGF5b3V0QmFzZSA9IGZ1bmN0aW9uIGxheW91dEJhc2UoKSB7XG4gIHJldHVybjtcbn07XG5cbmxheW91dEJhc2UuRkRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbmxheW91dEJhc2UuRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xubGF5b3V0QmFzZS5GRExheW91dEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbmxheW91dEJhc2UuRkRMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5sYXlvdXRCYXNlLkRpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbmxheW91dEJhc2UuSGFzaE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xubGF5b3V0QmFzZS5IYXNoU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5sYXlvdXRCYXNlLklHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5sYXlvdXRCYXNlLklNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbmxheW91dEJhc2UuSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xubGF5b3V0QmFzZS5Qb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xubGF5b3V0QmFzZS5Qb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xubGF5b3V0QmFzZS5SYW5kb21TZWVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5sYXlvdXRCYXNlLlJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbmxheW91dEJhc2UuVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5sYXlvdXRCYXNlLlVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5sYXlvdXRCYXNlLlF1aWNrc29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xubGF5b3V0QmFzZS5MaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5sYXlvdXRCYXNlLkxHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5sYXlvdXRCYXNlLkxHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5sYXlvdXRCYXNlLkxFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmxheW91dEJhc2UuTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5sYXlvdXRCYXNlLkxOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmxheW91dEJhc2UuTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5sYXlvdXRCYXNlLkxheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5sYXlvdXRCYXNlLk5lZWRsZW1hbld1bnNjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xubGF5b3V0QmFzZS5NYXRyaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbmxheW91dEJhc2UuU1ZEID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbm1vZHVsZS5leHBvcnRzID0gbGF5b3V0QmFzZTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBFbWl0dGVyKCkge1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xufVxuXG52YXIgcCA9IEVtaXR0ZXIucHJvdG90eXBlO1xuXG5wLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICB0aGlzLmxpc3RlbmVycy5wdXNoKHtcbiAgICBldmVudDogZXZlbnQsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxucC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzW2ldO1xuXG4gICAgaWYgKGwuZXZlbnQgPT09IGV2ZW50ICYmIGwuY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG59O1xuXG5wLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsID0gdGhpcy5saXN0ZW5lcnNbaV07XG5cbiAgICBpZiAoZXZlbnQgPT09IGwuZXZlbnQpIHtcbiAgICAgIGwuY2FsbGJhY2soZGF0YSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js\n");

/***/ }),

/***/ "./node_modules/mermaid/dist/chunks/mermaid.core/architectureDiagram-IEHRJDOE.mjs":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   diagram: () => (/* binding */ diagram)\n/* harmony export */ });\n/* harmony import */ var _chunk_H2D2JQ3I_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-H2D2JQ3I.mjs\");\n/* harmony import */ var _chunk_C3MQ5ANM_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-C3MQ5ANM.mjs\");\n/* harmony import */ var _chunk_4BMEZGHF_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-4BMEZGHF.mjs\");\n/* harmony import */ var _chunk_XZIHB7SX_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-XZIHB7SX.mjs\");\n/* harmony import */ var _chunk_O4NI6UNU_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-O4NI6UNU.mjs\");\n/* harmony import */ var _chunk_7B677QYD_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-7B677QYD.mjs\");\n/* harmony import */ var _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-YTJNT7DU.mjs\");\n/* harmony import */ var _mermaid_js_parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"./node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs\");\n/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"./node_modules/cytoscape/dist/cytoscape.esm.mjs\");\n/* harmony import */ var cytoscape_fcose__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"./node_modules/cytoscape-fcose/cytoscape-fcose.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(\"./node_modules/d3/src/index.js\");\n\n\n\n\n\n\n\n\n// src/diagrams/architecture/architectureParser.ts\n\n\n// src/diagrams/architecture/architectureTypes.ts\nvar ArchitectureDirectionName = {\n  L: \"left\",\n  R: \"right\",\n  T: \"top\",\n  B: \"bottom\"\n};\nvar ArchitectureDirectionArrow = {\n  L: /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((scale) => `${scale},${scale / 2} 0,${scale} 0,0`, \"L\"),\n  R: /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((scale) => `0,${scale / 2} ${scale},0 ${scale},${scale}`, \"R\"),\n  T: /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((scale) => `0,0 ${scale},0 ${scale / 2},${scale}`, \"T\"),\n  B: /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((scale) => `${scale / 2},0 ${scale},${scale} 0,${scale}`, \"B\")\n};\nvar ArchitectureDirectionArrowShift = {\n  L: /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((orig, arrowSize) => orig - arrowSize + 2, \"L\"),\n  R: /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((orig, _arrowSize) => orig - 2, \"R\"),\n  T: /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((orig, arrowSize) => orig - arrowSize + 2, \"T\"),\n  B: /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((orig, _arrowSize) => orig - 2, \"B\")\n};\nvar getOppositeArchitectureDirection = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  if (isArchitectureDirectionX(x)) {\n    return x === \"L\" ? \"R\" : \"L\";\n  } else {\n    return x === \"T\" ? \"B\" : \"T\";\n  }\n}, \"getOppositeArchitectureDirection\");\nvar isArchitectureDirection = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp === \"L\" || temp === \"R\" || temp === \"T\" || temp === \"B\";\n}, \"isArchitectureDirection\");\nvar isArchitectureDirectionX = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp === \"L\" || temp === \"R\";\n}, \"isArchitectureDirectionX\");\nvar isArchitectureDirectionY = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp === \"T\" || temp === \"B\";\n}, \"isArchitectureDirectionY\");\nvar isArchitectureDirectionXY = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(a, b) {\n  const aX_bY = isArchitectureDirectionX(a) && isArchitectureDirectionY(b);\n  const aY_bX = isArchitectureDirectionY(a) && isArchitectureDirectionX(b);\n  return aX_bY || aY_bX;\n}, \"isArchitectureDirectionXY\");\nvar isArchitecturePairXY = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(pair) {\n  const lhs = pair[0];\n  const rhs = pair[1];\n  const aX_bY = isArchitectureDirectionX(lhs) && isArchitectureDirectionY(rhs);\n  const aY_bX = isArchitectureDirectionY(lhs) && isArchitectureDirectionX(rhs);\n  return aX_bY || aY_bX;\n}, \"isArchitecturePairXY\");\nvar isValidArchitectureDirectionPair = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  return x !== \"LL\" && x !== \"RR\" && x !== \"TT\" && x !== \"BB\";\n}, \"isValidArchitectureDirectionPair\");\nvar getArchitectureDirectionPair = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(sourceDir, targetDir) {\n  const pair = `${sourceDir}${targetDir}`;\n  return isValidArchitectureDirectionPair(pair) ? pair : void 0;\n}, \"getArchitectureDirectionPair\");\nvar shiftPositionByArchitectureDirectionPair = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function([x, y], pair) {\n  const lhs = pair[0];\n  const rhs = pair[1];\n  if (isArchitectureDirectionX(lhs)) {\n    if (isArchitectureDirectionY(rhs)) {\n      return [x + (lhs === \"L\" ? -1 : 1), y + (rhs === \"T\" ? 1 : -1)];\n    } else {\n      return [x + (lhs === \"L\" ? -1 : 1), y];\n    }\n  } else {\n    if (isArchitectureDirectionX(rhs)) {\n      return [x + (rhs === \"L\" ? 1 : -1), y + (lhs === \"T\" ? 1 : -1)];\n    } else {\n      return [x, y + (lhs === \"T\" ? 1 : -1)];\n    }\n  }\n}, \"shiftPositionByArchitectureDirectionPair\");\nvar getArchitectureDirectionXYFactors = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(pair) {\n  if (pair === \"LT\" || pair === \"TL\") {\n    return [1, 1];\n  } else if (pair === \"BL\" || pair === \"LB\") {\n    return [1, -1];\n  } else if (pair === \"BR\" || pair === \"RB\") {\n    return [-1, -1];\n  } else {\n    return [-1, 1];\n  }\n}, \"getArchitectureDirectionXYFactors\");\nvar getArchitectureDirectionAlignment = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(a, b) {\n  if (isArchitectureDirectionXY(a, b)) {\n    return \"bend\";\n  } else if (isArchitectureDirectionX(a)) {\n    return \"horizontal\";\n  }\n  return \"vertical\";\n}, \"getArchitectureDirectionAlignment\");\nvar isArchitectureService = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp.type === \"service\";\n}, \"isArchitectureService\");\nvar isArchitectureJunction = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp.type === \"junction\";\n}, \"isArchitectureJunction\");\nvar edgeData = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((edge) => {\n  return edge.data();\n}, \"edgeData\");\nvar nodeData = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((node) => {\n  return node.data();\n}, \"nodeData\");\n\n// src/diagrams/architecture/architectureDb.ts\nvar DEFAULT_ARCHITECTURE_CONFIG = _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.defaultConfig_default.architecture;\nvar state = new _chunk_XZIHB7SX_mjs__WEBPACK_IMPORTED_MODULE_3__.ImperativeState(() => ({\n  nodes: {},\n  groups: {},\n  edges: [],\n  registeredIds: {},\n  config: DEFAULT_ARCHITECTURE_CONFIG,\n  dataStructures: void 0,\n  elements: {}\n}));\nvar clear2 = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => {\n  state.reset();\n  (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.clear)();\n}, \"clear\");\nvar addService = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function({\n  id,\n  icon,\n  in: parent,\n  title,\n  iconText\n}) {\n  if (state.records.registeredIds[id] !== void 0) {\n    throw new Error(\n      `The service id [${id}] is already in use by another ${state.records.registeredIds[id]}`\n    );\n  }\n  if (parent !== void 0) {\n    if (id === parent) {\n      throw new Error(`The service [${id}] cannot be placed within itself`);\n    }\n    if (state.records.registeredIds[parent] === void 0) {\n      throw new Error(\n        `The service [${id}]'s parent does not exist. Please make sure the parent is created before this service`\n      );\n    }\n    if (state.records.registeredIds[parent] === \"node\") {\n      throw new Error(`The service [${id}]'s parent is not a group`);\n    }\n  }\n  state.records.registeredIds[id] = \"node\";\n  state.records.nodes[id] = {\n    id,\n    type: \"service\",\n    icon,\n    iconText,\n    title,\n    edges: [],\n    in: parent\n  };\n}, \"addService\");\nvar getServices = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => Object.values(state.records.nodes).filter(isArchitectureService), \"getServices\");\nvar addJunction = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function({ id, in: parent }) {\n  state.records.registeredIds[id] = \"node\";\n  state.records.nodes[id] = {\n    id,\n    type: \"junction\",\n    edges: [],\n    in: parent\n  };\n}, \"addJunction\");\nvar getJunctions = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => Object.values(state.records.nodes).filter(isArchitectureJunction), \"getJunctions\");\nvar getNodes = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => Object.values(state.records.nodes), \"getNodes\");\nvar getNode = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((id) => state.records.nodes[id], \"getNode\");\nvar addGroup = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function({ id, icon, in: parent, title }) {\n  if (state.records.registeredIds[id] !== void 0) {\n    throw new Error(\n      `The group id [${id}] is already in use by another ${state.records.registeredIds[id]}`\n    );\n  }\n  if (parent !== void 0) {\n    if (id === parent) {\n      throw new Error(`The group [${id}] cannot be placed within itself`);\n    }\n    if (state.records.registeredIds[parent] === void 0) {\n      throw new Error(\n        `The group [${id}]'s parent does not exist. Please make sure the parent is created before this group`\n      );\n    }\n    if (state.records.registeredIds[parent] === \"node\") {\n      throw new Error(`The group [${id}]'s parent is not a group`);\n    }\n  }\n  state.records.registeredIds[id] = \"group\";\n  state.records.groups[id] = {\n    id,\n    icon,\n    title,\n    in: parent\n  };\n}, \"addGroup\");\nvar getGroups = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => {\n  return Object.values(state.records.groups);\n}, \"getGroups\");\nvar addEdge = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function({\n  lhsId,\n  rhsId,\n  lhsDir,\n  rhsDir,\n  lhsInto,\n  rhsInto,\n  lhsGroup,\n  rhsGroup,\n  title\n}) {\n  if (!isArchitectureDirection(lhsDir)) {\n    throw new Error(\n      `Invalid direction given for left hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${lhsDir}`\n    );\n  }\n  if (!isArchitectureDirection(rhsDir)) {\n    throw new Error(\n      `Invalid direction given for right hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${rhsDir}`\n    );\n  }\n  if (state.records.nodes[lhsId] === void 0 && state.records.groups[lhsId] === void 0) {\n    throw new Error(\n      `The left-hand id [${lhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`\n    );\n  }\n  if (state.records.nodes[rhsId] === void 0 && state.records.groups[lhsId] === void 0) {\n    throw new Error(\n      `The right-hand id [${rhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`\n    );\n  }\n  const lhsGroupId = state.records.nodes[lhsId].in;\n  const rhsGroupId = state.records.nodes[rhsId].in;\n  if (lhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {\n    throw new Error(\n      `The left-hand id [${lhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`\n    );\n  }\n  if (rhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {\n    throw new Error(\n      `The right-hand id [${rhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`\n    );\n  }\n  const edge = {\n    lhsId,\n    lhsDir,\n    lhsInto,\n    lhsGroup,\n    rhsId,\n    rhsDir,\n    rhsInto,\n    rhsGroup,\n    title\n  };\n  state.records.edges.push(edge);\n  if (state.records.nodes[lhsId] && state.records.nodes[rhsId]) {\n    state.records.nodes[lhsId].edges.push(state.records.edges[state.records.edges.length - 1]);\n    state.records.nodes[rhsId].edges.push(state.records.edges[state.records.edges.length - 1]);\n  }\n}, \"addEdge\");\nvar getEdges = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => state.records.edges, \"getEdges\");\nvar getDataStructures = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => {\n  if (state.records.dataStructures === void 0) {\n    const groupAlignments = {};\n    const adjList = Object.entries(state.records.nodes).reduce((prevOuter, [id, service]) => {\n      prevOuter[id] = service.edges.reduce((prevInner, edge) => {\n        const lhsGroupId = getNode(edge.lhsId)?.in;\n        const rhsGroupId = getNode(edge.rhsId)?.in;\n        if (lhsGroupId && rhsGroupId && lhsGroupId !== rhsGroupId) {\n          const alignment = getArchitectureDirectionAlignment(edge.lhsDir, edge.rhsDir);\n          if (alignment !== \"bend\") {\n            groupAlignments[lhsGroupId] ??= {};\n            groupAlignments[lhsGroupId][rhsGroupId] = alignment;\n            groupAlignments[rhsGroupId] ??= {};\n            groupAlignments[rhsGroupId][lhsGroupId] = alignment;\n          }\n        }\n        if (edge.lhsId === id) {\n          const pair = getArchitectureDirectionPair(edge.lhsDir, edge.rhsDir);\n          if (pair) {\n            prevInner[pair] = edge.rhsId;\n          }\n        } else {\n          const pair = getArchitectureDirectionPair(edge.rhsDir, edge.lhsDir);\n          if (pair) {\n            prevInner[pair] = edge.lhsId;\n          }\n        }\n        return prevInner;\n      }, {});\n      return prevOuter;\n    }, {});\n    const firstId = Object.keys(adjList)[0];\n    const visited = { [firstId]: 1 };\n    const notVisited = Object.keys(adjList).reduce(\n      (prev, id) => id === firstId ? prev : { ...prev, [id]: 1 },\n      {}\n    );\n    const BFS = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((startingId) => {\n      const spatialMap = { [startingId]: [0, 0] };\n      const queue = [startingId];\n      while (queue.length > 0) {\n        const id = queue.shift();\n        if (id) {\n          visited[id] = 1;\n          delete notVisited[id];\n          const adj = adjList[id];\n          const [posX, posY] = spatialMap[id];\n          Object.entries(adj).forEach(([dir, rhsId]) => {\n            if (!visited[rhsId]) {\n              spatialMap[rhsId] = shiftPositionByArchitectureDirectionPair(\n                [posX, posY],\n                dir\n              );\n              queue.push(rhsId);\n            }\n          });\n        }\n      }\n      return spatialMap;\n    }, \"BFS\");\n    const spatialMaps = [BFS(firstId)];\n    while (Object.keys(notVisited).length > 0) {\n      spatialMaps.push(BFS(Object.keys(notVisited)[0]));\n    }\n    state.records.dataStructures = {\n      adjList,\n      spatialMaps,\n      groupAlignments\n    };\n  }\n  return state.records.dataStructures;\n}, \"getDataStructures\");\nvar setElementForId = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((id, element) => {\n  state.records.elements[id] = element;\n}, \"setElementForId\");\nvar getElementById = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((id) => state.records.elements[id], \"getElementById\");\nvar db = {\n  clear: clear2,\n  setDiagramTitle: _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.setDiagramTitle,\n  getDiagramTitle: _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.getDiagramTitle,\n  setAccTitle: _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.setAccTitle,\n  getAccTitle: _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.getAccTitle,\n  setAccDescription: _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.setAccDescription,\n  getAccDescription: _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.getAccDescription,\n  addService,\n  getServices,\n  addJunction,\n  getJunctions,\n  getNodes,\n  getNode,\n  addGroup,\n  getGroups,\n  addEdge,\n  getEdges,\n  setElementForId,\n  getElementById,\n  getDataStructures\n};\nfunction getConfigField(field) {\n  const arch = (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.getConfig2)().architecture;\n  if (arch?.[field]) {\n    return arch[field];\n  }\n  return DEFAULT_ARCHITECTURE_CONFIG[field];\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(getConfigField, \"getConfigField\");\n\n// src/diagrams/architecture/architectureParser.ts\nvar populateDb = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((ast, db2) => {\n  (0,_chunk_4BMEZGHF_mjs__WEBPACK_IMPORTED_MODULE_2__.populateCommonDb)(ast, db2);\n  ast.groups.map(db2.addGroup);\n  ast.services.map((service) => db2.addService({ ...service, type: \"service\" }));\n  ast.junctions.map((service) => db2.addJunction({ ...service, type: \"junction\" }));\n  ast.edges.map(db2.addEdge);\n}, \"populateDb\");\nvar parser = {\n  parse: /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async (input) => {\n    const ast = await (0,_mermaid_js_parser__WEBPACK_IMPORTED_MODULE_7__.parse)(\"architecture\", input);\n    _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.log.debug(ast);\n    populateDb(ast, db);\n  }, \"parse\")\n};\n\n// src/diagrams/architecture/architectureStyles.ts\nvar getStyles = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((options) => `\n  .edge {\n    stroke-width: ${options.archEdgeWidth};\n    stroke: ${options.archEdgeColor};\n    fill: none;\n  }\n\n  .arrow {\n    fill: ${options.archEdgeArrowColor};\n  }\n\n  .node-bkg {\n    fill: none;\n    stroke: ${options.archGroupBorderColor};\n    stroke-width: ${options.archGroupBorderWidth};\n    stroke-dasharray: 8;\n  }\n  .node-icon-text {\n    display: flex; \n    align-items: center;\n  }\n  \n  .node-icon-text > div {\n    color: #fff;\n    margin: 1px;\n    height: fit-content;\n    text-align: center;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n  }\n`, \"getStyles\");\nvar architectureStyles_default = getStyles;\n\n// src/diagrams/architecture/architectureRenderer.ts\n\n\n\n\n// src/diagrams/architecture/architectureIcons.ts\nvar wrapIcon = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((icon) => {\n  return `<g><rect width=\"80\" height=\"80\" style=\"fill: #087ebf; stroke-width: 0px;\"/>${icon}</g>`;\n}, \"wrapIcon\");\nvar architectureIcons = {\n  prefix: \"mermaid-architecture\",\n  height: 80,\n  width: 80,\n  icons: {\n    database: {\n      body: wrapIcon(\n        '<path id=\"b\" data-name=\"4\" d=\"m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path id=\"c\" data-name=\"3\" d=\"m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path id=\"d\" data-name=\"2\" d=\"m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse id=\"e\" data-name=\"1\" cx=\"40\" cy=\"22.14\" rx=\"20\" ry=\"7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"20\" y1=\"57.86\" x2=\"20\" y2=\"22.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"60\" y1=\"57.86\" x2=\"60\" y2=\"22.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>'\n      )\n    },\n    server: {\n      body: wrapIcon(\n        '<rect x=\"17.5\" y=\"17.5\" width=\"45\" height=\"45\" rx=\"2\" ry=\"2\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"32.5\" x2=\"62.5\" y2=\"32.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"47.5\" x2=\"62.5\" y2=\"47.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><g><path d=\"m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><path d=\"m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><path d=\"m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g>'\n      )\n    },\n    disk: {\n      body: wrapIcon(\n        '<rect x=\"20\" y=\"15\" width=\"40\" height=\"50\" rx=\"1\" ry=\"1\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"24\" cy=\"19.17\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"56\" cy=\"19.17\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"24\" cy=\"60.83\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"56\" cy=\"60.83\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"40\" cy=\"33.75\" rx=\"14\" ry=\"14.58\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"40\" cy=\"33.75\" rx=\"4\" ry=\"4.17\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z\" style=\"fill: #fff; stroke-width: 0px;\"/>'\n      )\n    },\n    internet: {\n      body: wrapIcon(\n        '<circle cx=\"40\" cy=\"40\" r=\"22.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"40\" y1=\"17.5\" x2=\"40\" y2=\"62.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"40\" x2=\"62.5\" y2=\"40\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"19.75\" y1=\"30.1\" x2=\"60.25\" y2=\"30.1\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"19.75\" y1=\"49.9\" x2=\"60.25\" y2=\"49.9\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>'\n      )\n    },\n    cloud: {\n      body: wrapIcon(\n        '<path d=\"m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>'\n      )\n    },\n    unknown: _chunk_H2D2JQ3I_mjs__WEBPACK_IMPORTED_MODULE_0__.unknownIcon,\n    blank: {\n      body: wrapIcon(\"\")\n    }\n  }\n};\n\n// src/diagrams/architecture/svgDraw.ts\nvar drawEdges = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async function(edgesEl, cy) {\n  const padding = getConfigField(\"padding\");\n  const iconSize = getConfigField(\"iconSize\");\n  const halfIconSize = iconSize / 2;\n  const arrowSize = iconSize / 6;\n  const halfArrowSize = arrowSize / 2;\n  await Promise.all(\n    cy.edges().map(async (edge) => {\n      const {\n        source,\n        sourceDir,\n        sourceArrow,\n        sourceGroup,\n        target,\n        targetDir,\n        targetArrow,\n        targetGroup,\n        label\n      } = edgeData(edge);\n      let { x: startX, y: startY } = edge[0].sourceEndpoint();\n      const { x: midX, y: midY } = edge[0].midpoint();\n      let { x: endX, y: endY } = edge[0].targetEndpoint();\n      const groupEdgeShift = padding + 4;\n      if (sourceGroup) {\n        if (isArchitectureDirectionX(sourceDir)) {\n          startX += sourceDir === \"L\" ? -groupEdgeShift : groupEdgeShift;\n        } else {\n          startY += sourceDir === \"T\" ? -groupEdgeShift : groupEdgeShift + 18;\n        }\n      }\n      if (targetGroup) {\n        if (isArchitectureDirectionX(targetDir)) {\n          endX += targetDir === \"L\" ? -groupEdgeShift : groupEdgeShift;\n        } else {\n          endY += targetDir === \"T\" ? -groupEdgeShift : groupEdgeShift + 18;\n        }\n      }\n      if (!sourceGroup && db.getNode(source)?.type === \"junction\") {\n        if (isArchitectureDirectionX(sourceDir)) {\n          startX += sourceDir === \"L\" ? halfIconSize : -halfIconSize;\n        } else {\n          startY += sourceDir === \"T\" ? halfIconSize : -halfIconSize;\n        }\n      }\n      if (!targetGroup && db.getNode(target)?.type === \"junction\") {\n        if (isArchitectureDirectionX(targetDir)) {\n          endX += targetDir === \"L\" ? halfIconSize : -halfIconSize;\n        } else {\n          endY += targetDir === \"T\" ? halfIconSize : -halfIconSize;\n        }\n      }\n      if (edge[0]._private.rscratch) {\n        const g = edgesEl.insert(\"g\");\n        g.insert(\"path\").attr(\"d\", `M ${startX},${startY} L ${midX},${midY} L${endX},${endY} `).attr(\"class\", \"edge\");\n        if (sourceArrow) {\n          const xShift = isArchitectureDirectionX(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startX, arrowSize) : startX - halfArrowSize;\n          const yShift = isArchitectureDirectionY(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startY, arrowSize) : startY - halfArrowSize;\n          g.insert(\"polygon\").attr(\"points\", ArchitectureDirectionArrow[sourceDir](arrowSize)).attr(\"transform\", `translate(${xShift},${yShift})`).attr(\"class\", \"arrow\");\n        }\n        if (targetArrow) {\n          const xShift = isArchitectureDirectionX(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endX, arrowSize) : endX - halfArrowSize;\n          const yShift = isArchitectureDirectionY(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endY, arrowSize) : endY - halfArrowSize;\n          g.insert(\"polygon\").attr(\"points\", ArchitectureDirectionArrow[targetDir](arrowSize)).attr(\"transform\", `translate(${xShift},${yShift})`).attr(\"class\", \"arrow\");\n        }\n        if (label) {\n          const axis = !isArchitectureDirectionXY(sourceDir, targetDir) ? isArchitectureDirectionX(sourceDir) ? \"X\" : \"Y\" : \"XY\";\n          let width = 0;\n          if (axis === \"X\") {\n            width = Math.abs(startX - endX);\n          } else if (axis === \"Y\") {\n            width = Math.abs(startY - endY) / 1.5;\n          } else {\n            width = Math.abs(startX - endX) / 2;\n          }\n          const textElem = g.append(\"g\");\n          await (0,_chunk_C3MQ5ANM_mjs__WEBPACK_IMPORTED_MODULE_1__.createText)(\n            textElem,\n            label,\n            {\n              useHtmlLabels: false,\n              width,\n              classes: \"architecture-service-label\"\n            },\n            (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.getConfig2)()\n          );\n          textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"text-anchor\", \"middle\");\n          if (axis === \"X\") {\n            textElem.attr(\"transform\", \"translate(\" + midX + \", \" + midY + \")\");\n          } else if (axis === \"Y\") {\n            textElem.attr(\"transform\", \"translate(\" + midX + \", \" + midY + \") rotate(-90)\");\n          } else if (axis === \"XY\") {\n            const pair = getArchitectureDirectionPair(sourceDir, targetDir);\n            if (pair && isArchitecturePairXY(pair)) {\n              const bboxOrig = textElem.node().getBoundingClientRect();\n              const [x, y] = getArchitectureDirectionXYFactors(pair);\n              textElem.attr(\"dominant-baseline\", \"auto\").attr(\"transform\", `rotate(${-1 * x * y * 45})`);\n              const bboxNew = textElem.node().getBoundingClientRect();\n              textElem.attr(\n                \"transform\",\n                `\n                translate(${midX}, ${midY - bboxOrig.height / 2})\n                translate(${x * bboxNew.width / 2}, ${y * bboxNew.height / 2})\n                rotate(${-1 * x * y * 45}, 0, ${bboxOrig.height / 2})\n              `\n              );\n            }\n          }\n        }\n      }\n    })\n  );\n}, \"drawEdges\");\nvar drawGroups = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async function(groupsEl, cy) {\n  const padding = getConfigField(\"padding\");\n  const groupIconSize = padding * 0.75;\n  const fontSize = getConfigField(\"fontSize\");\n  const iconSize = getConfigField(\"iconSize\");\n  const halfIconSize = iconSize / 2;\n  await Promise.all(\n    cy.nodes().map(async (node) => {\n      const data = nodeData(node);\n      if (data.type === \"group\") {\n        const { h, w, x1, y1 } = node.boundingBox();\n        groupsEl.append(\"rect\").attr(\"x\", x1 + halfIconSize).attr(\"y\", y1 + halfIconSize).attr(\"width\", w).attr(\"height\", h).attr(\"class\", \"node-bkg\");\n        const groupLabelContainer = groupsEl.append(\"g\");\n        let shiftedX1 = x1;\n        let shiftedY1 = y1;\n        if (data.icon) {\n          const bkgElem = groupLabelContainer.append(\"g\");\n          bkgElem.html(\n            `<g>${await (0,_chunk_H2D2JQ3I_mjs__WEBPACK_IMPORTED_MODULE_0__.getIconSVG)(data.icon, { height: groupIconSize, width: groupIconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n          );\n          bkgElem.attr(\n            \"transform\",\n            \"translate(\" + (shiftedX1 + halfIconSize + 1) + \", \" + (shiftedY1 + halfIconSize + 1) + \")\"\n          );\n          shiftedX1 += groupIconSize;\n          shiftedY1 += fontSize / 2 - 1 - 2;\n        }\n        if (data.label) {\n          const textElem = groupLabelContainer.append(\"g\");\n          await (0,_chunk_C3MQ5ANM_mjs__WEBPACK_IMPORTED_MODULE_1__.createText)(\n            textElem,\n            data.label,\n            {\n              useHtmlLabels: false,\n              width: w,\n              classes: \"architecture-service-label\"\n            },\n            (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.getConfig2)()\n          );\n          textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"start\").attr(\"text-anchor\", \"start\");\n          textElem.attr(\n            \"transform\",\n            \"translate(\" + (shiftedX1 + halfIconSize + 4) + \", \" + (shiftedY1 + halfIconSize + 2) + \")\"\n          );\n        }\n      }\n    })\n  );\n}, \"drawGroups\");\nvar drawServices = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async function(db2, elem, services) {\n  for (const service of services) {\n    const serviceElem = elem.append(\"g\");\n    const iconSize = getConfigField(\"iconSize\");\n    if (service.title) {\n      const textElem = serviceElem.append(\"g\");\n      await (0,_chunk_C3MQ5ANM_mjs__WEBPACK_IMPORTED_MODULE_1__.createText)(\n        textElem,\n        service.title,\n        {\n          useHtmlLabels: false,\n          width: iconSize * 1.5,\n          classes: \"architecture-service-label\"\n        },\n        (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.getConfig2)()\n      );\n      textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"text-anchor\", \"middle\");\n      textElem.attr(\"transform\", \"translate(\" + iconSize / 2 + \", \" + iconSize + \")\");\n    }\n    const bkgElem = serviceElem.append(\"g\");\n    if (service.icon) {\n      bkgElem.html(\n        `<g>${await (0,_chunk_H2D2JQ3I_mjs__WEBPACK_IMPORTED_MODULE_0__.getIconSVG)(service.icon, { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n      );\n    } else if (service.iconText) {\n      bkgElem.html(\n        `<g>${await (0,_chunk_H2D2JQ3I_mjs__WEBPACK_IMPORTED_MODULE_0__.getIconSVG)(\"blank\", { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n      );\n      const textElemContainer = bkgElem.append(\"g\");\n      const fo = textElemContainer.append(\"foreignObject\").attr(\"width\", iconSize).attr(\"height\", iconSize);\n      const divElem = fo.append(\"div\").attr(\"class\", \"node-icon-text\").attr(\"style\", `height: ${iconSize}px;`).append(\"div\").html(service.iconText);\n      const fontSize = parseInt(\n        window.getComputedStyle(divElem.node(), null).getPropertyValue(\"font-size\").replace(/\\D/g, \"\")\n      ) ?? 16;\n      divElem.attr(\"style\", `-webkit-line-clamp: ${Math.floor((iconSize - 2) / fontSize)};`);\n    } else {\n      bkgElem.append(\"path\").attr(\"class\", \"node-bkg\").attr(\"id\", \"node-\" + service.id).attr(\n        \"d\",\n        `M0 ${iconSize} v${-iconSize} q0,-5 5,-5 h${iconSize} q5,0 5,5 v${iconSize} H0 Z`\n      );\n    }\n    serviceElem.attr(\"class\", \"architecture-service\");\n    const { width, height } = serviceElem._groups[0][0].getBBox();\n    service.width = width;\n    service.height = height;\n    db2.setElementForId(service.id, serviceElem);\n  }\n  return 0;\n}, \"drawServices\");\nvar drawJunctions = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(db2, elem, junctions) {\n  junctions.forEach((junction) => {\n    const junctionElem = elem.append(\"g\");\n    const iconSize = getConfigField(\"iconSize\");\n    const bkgElem = junctionElem.append(\"g\");\n    bkgElem.append(\"rect\").attr(\"id\", \"node-\" + junction.id).attr(\"fill-opacity\", \"0\").attr(\"width\", iconSize).attr(\"height\", iconSize);\n    junctionElem.attr(\"class\", \"architecture-junction\");\n    const { width, height } = junctionElem._groups[0][0].getBBox();\n    junctionElem.width = width;\n    junctionElem.height = height;\n    db2.setElementForId(junction.id, junctionElem);\n  });\n}, \"drawJunctions\");\n\n// src/diagrams/architecture/architectureRenderer.ts\n(0,_chunk_H2D2JQ3I_mjs__WEBPACK_IMPORTED_MODULE_0__.registerIconPacks)([\n  {\n    name: architectureIcons.prefix,\n    icons: architectureIcons\n  }\n]);\ncytoscape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].use(cytoscape_fcose__WEBPACK_IMPORTED_MODULE_9__);\nfunction addServices(services, cy) {\n  services.forEach((service) => {\n    cy.add({\n      group: \"nodes\",\n      data: {\n        type: \"service\",\n        id: service.id,\n        icon: service.icon,\n        label: service.title,\n        parent: service.in,\n        width: getConfigField(\"iconSize\"),\n        height: getConfigField(\"iconSize\")\n      },\n      classes: \"node-service\"\n    });\n  });\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(addServices, \"addServices\");\nfunction addJunctions(junctions, cy) {\n  junctions.forEach((junction) => {\n    cy.add({\n      group: \"nodes\",\n      data: {\n        type: \"junction\",\n        id: junction.id,\n        parent: junction.in,\n        width: getConfigField(\"iconSize\"),\n        height: getConfigField(\"iconSize\")\n      },\n      classes: \"node-junction\"\n    });\n  });\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(addJunctions, \"addJunctions\");\nfunction positionNodes(db2, cy) {\n  cy.nodes().map((node) => {\n    const data = nodeData(node);\n    if (data.type === \"group\") {\n      return;\n    }\n    data.x = node.position().x;\n    data.y = node.position().y;\n    const nodeElem = db2.getElementById(data.id);\n    nodeElem.attr(\"transform\", \"translate(\" + (data.x || 0) + \",\" + (data.y || 0) + \")\");\n  });\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(positionNodes, \"positionNodes\");\nfunction addGroups(groups, cy) {\n  groups.forEach((group) => {\n    cy.add({\n      group: \"nodes\",\n      data: {\n        type: \"group\",\n        id: group.id,\n        icon: group.icon,\n        label: group.title,\n        parent: group.in\n      },\n      classes: \"node-group\"\n    });\n  });\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(addGroups, \"addGroups\");\nfunction addEdges(edges, cy) {\n  edges.forEach((parsedEdge) => {\n    const { lhsId, rhsId, lhsInto, lhsGroup, rhsInto, lhsDir, rhsDir, rhsGroup, title } = parsedEdge;\n    const edgeType = isArchitectureDirectionXY(parsedEdge.lhsDir, parsedEdge.rhsDir) ? \"segments\" : \"straight\";\n    const edge = {\n      id: `${lhsId}-${rhsId}`,\n      label: title,\n      source: lhsId,\n      sourceDir: lhsDir,\n      sourceArrow: lhsInto,\n      sourceGroup: lhsGroup,\n      sourceEndpoint: lhsDir === \"L\" ? \"0 50%\" : lhsDir === \"R\" ? \"100% 50%\" : lhsDir === \"T\" ? \"50% 0\" : \"50% 100%\",\n      target: rhsId,\n      targetDir: rhsDir,\n      targetArrow: rhsInto,\n      targetGroup: rhsGroup,\n      targetEndpoint: rhsDir === \"L\" ? \"0 50%\" : rhsDir === \"R\" ? \"100% 50%\" : rhsDir === \"T\" ? \"50% 0\" : \"50% 100%\"\n    };\n    cy.add({\n      group: \"edges\",\n      data: edge,\n      classes: edgeType\n    });\n  });\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(addEdges, \"addEdges\");\nfunction getAlignments(db2, spatialMaps, groupAlignments) {\n  const flattenAlignments = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((alignmentObj, alignmentDir) => {\n    return Object.entries(alignmentObj).reduce(\n      (prev, [dir, alignments2]) => {\n        let cnt = 0;\n        const arr = Object.entries(alignments2);\n        if (arr.length === 1) {\n          prev[dir] = arr[0][1];\n          return prev;\n        }\n        for (let i = 0; i < arr.length - 1; i++) {\n          for (let j = i + 1; j < arr.length; j++) {\n            const [aGroupId, aNodeIds] = arr[i];\n            const [bGroupId, bNodeIds] = arr[j];\n            const alignment = groupAlignments[aGroupId]?.[bGroupId];\n            if (alignment === alignmentDir) {\n              prev[dir] ??= [];\n              prev[dir] = [...prev[dir], ...aNodeIds, ...bNodeIds];\n            } else if (aGroupId === \"default\" || bGroupId === \"default\") {\n              prev[dir] ??= [];\n              prev[dir] = [...prev[dir], ...aNodeIds, ...bNodeIds];\n            } else {\n              const keyA = `${dir}-${cnt++}`;\n              prev[keyA] = aNodeIds;\n              const keyB = `${dir}-${cnt++}`;\n              prev[keyB] = bNodeIds;\n            }\n          }\n        }\n        return prev;\n      },\n      {}\n    );\n  }, \"flattenAlignments\");\n  const alignments = spatialMaps.map((spatialMap) => {\n    const horizontalAlignments = {};\n    const verticalAlignments = {};\n    Object.entries(spatialMap).forEach(([id, [x, y]]) => {\n      const nodeGroup = db2.getNode(id)?.in ?? \"default\";\n      horizontalAlignments[y] ??= {};\n      horizontalAlignments[y][nodeGroup] ??= [];\n      horizontalAlignments[y][nodeGroup].push(id);\n      verticalAlignments[x] ??= {};\n      verticalAlignments[x][nodeGroup] ??= [];\n      verticalAlignments[x][nodeGroup].push(id);\n    });\n    return {\n      horiz: Object.values(flattenAlignments(horizontalAlignments, \"horizontal\")).filter(\n        (arr) => arr.length > 1\n      ),\n      vert: Object.values(flattenAlignments(verticalAlignments, \"vertical\")).filter(\n        (arr) => arr.length > 1\n      )\n    };\n  });\n  const [horizontal, vertical] = alignments.reduce(\n    ([prevHoriz, prevVert], { horiz, vert }) => {\n      return [\n        [...prevHoriz, ...horiz],\n        [...prevVert, ...vert]\n      ];\n    },\n    [[], []]\n  );\n  return {\n    horizontal,\n    vertical\n  };\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(getAlignments, \"getAlignments\");\nfunction getRelativeConstraints(spatialMaps) {\n  const relativeConstraints = [];\n  const posToStr = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((pos) => `${pos[0]},${pos[1]}`, \"posToStr\");\n  const strToPos = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((pos) => pos.split(\",\").map((p) => parseInt(p)), \"strToPos\");\n  spatialMaps.forEach((spatialMap) => {\n    const invSpatialMap = Object.fromEntries(\n      Object.entries(spatialMap).map(([id, pos]) => [posToStr(pos), id])\n    );\n    const queue = [posToStr([0, 0])];\n    const visited = {};\n    const directions = {\n      L: [-1, 0],\n      R: [1, 0],\n      T: [0, 1],\n      B: [0, -1]\n    };\n    while (queue.length > 0) {\n      const curr = queue.shift();\n      if (curr) {\n        visited[curr] = 1;\n        const currId = invSpatialMap[curr];\n        if (currId) {\n          const currPos = strToPos(curr);\n          Object.entries(directions).forEach(([dir, shift]) => {\n            const newPos = posToStr([currPos[0] + shift[0], currPos[1] + shift[1]]);\n            const newId = invSpatialMap[newPos];\n            if (newId && !visited[newPos]) {\n              queue.push(newPos);\n              relativeConstraints.push({\n                [ArchitectureDirectionName[dir]]: newId,\n                [ArchitectureDirectionName[getOppositeArchitectureDirection(dir)]]: currId,\n                gap: 1.5 * getConfigField(\"iconSize\")\n              });\n            }\n          });\n        }\n      }\n    }\n  });\n  return relativeConstraints;\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(getRelativeConstraints, \"getRelativeConstraints\");\nfunction layoutArchitecture(services, junctions, groups, edges, db2, { spatialMaps, groupAlignments }) {\n  return new Promise((resolve) => {\n    const renderEl = (0,d3__WEBPACK_IMPORTED_MODULE_10__.select)(\"body\").append(\"div\").attr(\"id\", \"cy\").attr(\"style\", \"display:none\");\n    const cy = (0,cytoscape__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n      container: document.getElementById(\"cy\"),\n      style: [\n        {\n          selector: \"edge\",\n          style: {\n            \"curve-style\": \"straight\",\n            label: \"data(label)\",\n            \"source-endpoint\": \"data(sourceEndpoint)\",\n            \"target-endpoint\": \"data(targetEndpoint)\"\n          }\n        },\n        {\n          selector: \"edge.segments\",\n          style: {\n            \"curve-style\": \"segments\",\n            \"segment-weights\": \"0\",\n            \"segment-distances\": [0.5],\n            // @ts-ignore Incorrect library types\n            \"edge-distances\": \"endpoints\",\n            \"source-endpoint\": \"data(sourceEndpoint)\",\n            \"target-endpoint\": \"data(targetEndpoint)\"\n          }\n        },\n        {\n          selector: \"node\",\n          style: {\n            // @ts-ignore Incorrect library types\n            \"compound-sizing-wrt-labels\": \"include\"\n          }\n        },\n        {\n          selector: \"node[label]\",\n          style: {\n            \"text-valign\": \"bottom\",\n            \"text-halign\": \"center\",\n            \"font-size\": `${getConfigField(\"fontSize\")}px`\n          }\n        },\n        {\n          selector: \".node-service\",\n          style: {\n            label: \"data(label)\",\n            width: \"data(width)\",\n            height: \"data(height)\"\n          }\n        },\n        {\n          selector: \".node-junction\",\n          style: {\n            width: \"data(width)\",\n            height: \"data(height)\"\n          }\n        },\n        {\n          selector: \".node-group\",\n          style: {\n            // @ts-ignore Incorrect library types\n            padding: `${getConfigField(\"padding\")}px`\n          }\n        }\n      ]\n    });\n    renderEl.remove();\n    addGroups(groups, cy);\n    addServices(services, cy);\n    addJunctions(junctions, cy);\n    addEdges(edges, cy);\n    const alignmentConstraint = getAlignments(db2, spatialMaps, groupAlignments);\n    const relativePlacementConstraint = getRelativeConstraints(spatialMaps);\n    const layout = cy.layout({\n      name: \"fcose\",\n      quality: \"proof\",\n      styleEnabled: false,\n      animate: false,\n      nodeDimensionsIncludeLabels: false,\n      // Adjust the edge parameters if it passes through the border of a group\n      // Hacky fix for: https://github.com/iVis-at-Bilkent/cytoscape.js-fcose/issues/67\n      idealEdgeLength(edge) {\n        const [nodeA, nodeB] = edge.connectedNodes();\n        const { parent: parentA } = nodeData(nodeA);\n        const { parent: parentB } = nodeData(nodeB);\n        const elasticity = parentA === parentB ? 1.5 * getConfigField(\"iconSize\") : 0.5 * getConfigField(\"iconSize\");\n        return elasticity;\n      },\n      edgeElasticity(edge) {\n        const [nodeA, nodeB] = edge.connectedNodes();\n        const { parent: parentA } = nodeData(nodeA);\n        const { parent: parentB } = nodeData(nodeB);\n        const elasticity = parentA === parentB ? 0.45 : 1e-3;\n        return elasticity;\n      },\n      alignmentConstraint,\n      relativePlacementConstraint\n    });\n    layout.one(\"layoutstop\", () => {\n      function getSegmentWeights(source, target, pointX, pointY) {\n        let W, D;\n        const { x: sX, y: sY } = source;\n        const { x: tX, y: tY } = target;\n        D = (pointY - sY + (sX - pointX) * (sY - tY) / (sX - tX)) / Math.sqrt(1 + Math.pow((sY - tY) / (sX - tX), 2));\n        W = Math.sqrt(Math.pow(pointY - sY, 2) + Math.pow(pointX - sX, 2) - Math.pow(D, 2));\n        const distAB = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2));\n        W = W / distAB;\n        let delta1 = (tX - sX) * (pointY - sY) - (tY - sY) * (pointX - sX);\n        switch (true) {\n          case delta1 >= 0:\n            delta1 = 1;\n            break;\n          case delta1 < 0:\n            delta1 = -1;\n            break;\n        }\n        let delta2 = (tX - sX) * (pointX - sX) + (tY - sY) * (pointY - sY);\n        switch (true) {\n          case delta2 >= 0:\n            delta2 = 1;\n            break;\n          case delta2 < 0:\n            delta2 = -1;\n            break;\n        }\n        D = Math.abs(D) * delta1;\n        W = W * delta2;\n        return {\n          distances: D,\n          weights: W\n        };\n      }\n      (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(getSegmentWeights, \"getSegmentWeights\");\n      cy.startBatch();\n      for (const edge of Object.values(cy.edges())) {\n        if (edge.data?.()) {\n          const { x: sX, y: sY } = edge.source().position();\n          const { x: tX, y: tY } = edge.target().position();\n          if (sX !== tX && sY !== tY) {\n            const sEP = edge.sourceEndpoint();\n            const tEP = edge.targetEndpoint();\n            const { sourceDir } = edgeData(edge);\n            const [pointX, pointY] = isArchitectureDirectionY(sourceDir) ? [sEP.x, tEP.y] : [tEP.x, sEP.y];\n            const { weights, distances } = getSegmentWeights(sEP, tEP, pointX, pointY);\n            edge.style(\"segment-distances\", distances);\n            edge.style(\"segment-weights\", weights);\n          }\n        }\n      }\n      cy.endBatch();\n      layout.run();\n    });\n    layout.run();\n    cy.ready((e) => {\n      _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.log.info(\"Ready\", e);\n      resolve(cy);\n    });\n  });\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(layoutArchitecture, \"layoutArchitecture\");\nvar draw = /* @__PURE__ */ (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async (text, id, _version, diagObj) => {\n  const db2 = diagObj.db;\n  const services = db2.getServices();\n  const junctions = db2.getJunctions();\n  const groups = db2.getGroups();\n  const edges = db2.getEdges();\n  const ds = db2.getDataStructures();\n  const svg = (0,_chunk_7B677QYD_mjs__WEBPACK_IMPORTED_MODULE_5__.selectSvgElement)(id);\n  const edgesElem = svg.append(\"g\");\n  edgesElem.attr(\"class\", \"architecture-edges\");\n  const servicesElem = svg.append(\"g\");\n  servicesElem.attr(\"class\", \"architecture-services\");\n  const groupElem = svg.append(\"g\");\n  groupElem.attr(\"class\", \"architecture-groups\");\n  await drawServices(db2, servicesElem, services);\n  drawJunctions(db2, servicesElem, junctions);\n  const cy = await layoutArchitecture(services, junctions, groups, edges, db2, ds);\n  await drawEdges(edgesElem, cy);\n  await drawGroups(groupElem, cy);\n  positionNodes(db2, cy);\n  (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_6__.setupGraphViewbox)(void 0, svg, getConfigField(\"padding\"), getConfigField(\"useMaxWidth\"));\n}, \"draw\");\nvar renderer = { draw };\n\n// src/diagrams/architecture/architectureDiagram.ts\nvar diagram = {\n  parser,\n  db,\n  renderer,\n  styles: architectureStyles_default\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvYXJjaGl0ZWN0dXJlRGlhZ3JhbS1JRUhSSkRPRS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBSUE7QUFHQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmFiYml0bXEtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9tZXJtYWlkL2Rpc3QvY2h1bmtzL21lcm1haWQuY29yZS9hcmNoaXRlY3R1cmVEaWFncmFtLUlFSFJKRE9FLm1qcz9hMjkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGdldEljb25TVkcsXG4gIHJlZ2lzdGVySWNvblBhY2tzLFxuICB1bmtub3duSWNvblxufSBmcm9tIFwiLi9jaHVuay1IMkQySlEzSS5tanNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZVRleHRcbn0gZnJvbSBcIi4vY2h1bmstQzNNUTVBTk0ubWpzXCI7XG5pbXBvcnQge1xuICBwb3B1bGF0ZUNvbW1vbkRiXG59IGZyb20gXCIuL2NodW5rLTRCTUVaR0hGLm1qc1wiO1xuaW1wb3J0IHtcbiAgSW1wZXJhdGl2ZVN0YXRlXG59IGZyb20gXCIuL2NodW5rLVhaSUhCN1NYLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1PNE5JNlVOVS5tanNcIjtcbmltcG9ydCB7XG4gIHNlbGVjdFN2Z0VsZW1lbnRcbn0gZnJvbSBcIi4vY2h1bmstN0I2NzdRWUQubWpzXCI7XG5pbXBvcnQge1xuICBfX25hbWUsXG4gIGNsZWFyLFxuICBkZWZhdWx0Q29uZmlnX2RlZmF1bHQsXG4gIGdldEFjY0Rlc2NyaXB0aW9uLFxuICBnZXRBY2NUaXRsZSxcbiAgZ2V0Q29uZmlnMiBhcyBnZXRDb25maWcsXG4gIGdldERpYWdyYW1UaXRsZSxcbiAgbG9nLFxuICBzZXRBY2NEZXNjcmlwdGlvbixcbiAgc2V0QWNjVGl0bGUsXG4gIHNldERpYWdyYW1UaXRsZSxcbiAgc2V0dXBHcmFwaFZpZXdib3hcbn0gZnJvbSBcIi4vY2h1bmstWVRKTlQ3RFUubWpzXCI7XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvYXJjaGl0ZWN0dXJlUGFyc2VyLnRzXG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJAbWVybWFpZC1qcy9wYXJzZXJcIjtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVUeXBlcy50c1xudmFyIEFyY2hpdGVjdHVyZURpcmVjdGlvbk5hbWUgPSB7XG4gIEw6IFwibGVmdFwiLFxuICBSOiBcInJpZ2h0XCIsXG4gIFQ6IFwidG9wXCIsXG4gIEI6IFwiYm90dG9tXCJcbn07XG52YXIgQXJjaGl0ZWN0dXJlRGlyZWN0aW9uQXJyb3cgPSB7XG4gIEw6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNjYWxlKSA9PiBgJHtzY2FsZX0sJHtzY2FsZSAvIDJ9IDAsJHtzY2FsZX0gMCwwYCwgXCJMXCIpLFxuICBSOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzY2FsZSkgPT4gYDAsJHtzY2FsZSAvIDJ9ICR7c2NhbGV9LDAgJHtzY2FsZX0sJHtzY2FsZX1gLCBcIlJcIiksXG4gIFQ6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNjYWxlKSA9PiBgMCwwICR7c2NhbGV9LDAgJHtzY2FsZSAvIDJ9LCR7c2NhbGV9YCwgXCJUXCIpLFxuICBCOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzY2FsZSkgPT4gYCR7c2NhbGUgLyAyfSwwICR7c2NhbGV9LCR7c2NhbGV9IDAsJHtzY2FsZX1gLCBcIkJcIilcbn07XG52YXIgQXJjaGl0ZWN0dXJlRGlyZWN0aW9uQXJyb3dTaGlmdCA9IHtcbiAgTDogLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3JpZywgYXJyb3dTaXplKSA9PiBvcmlnIC0gYXJyb3dTaXplICsgMiwgXCJMXCIpLFxuICBSOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcmlnLCBfYXJyb3dTaXplKSA9PiBvcmlnIC0gMiwgXCJSXCIpLFxuICBUOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcmlnLCBhcnJvd1NpemUpID0+IG9yaWcgLSBhcnJvd1NpemUgKyAyLCBcIlRcIiksXG4gIEI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9yaWcsIF9hcnJvd1NpemUpID0+IG9yaWcgLSAyLCBcIkJcIilcbn07XG52YXIgZ2V0T3Bwb3NpdGVBcmNoaXRlY3R1cmVEaXJlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHgpIHtcbiAgaWYgKGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWCh4KSkge1xuICAgIHJldHVybiB4ID09PSBcIkxcIiA/IFwiUlwiIDogXCJMXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggPT09IFwiVFwiID8gXCJCXCIgOiBcIlRcIjtcbiAgfVxufSwgXCJnZXRPcHBvc2l0ZUFyY2hpdGVjdHVyZURpcmVjdGlvblwiKTtcbnZhciBpc0FyY2hpdGVjdHVyZURpcmVjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oeCkge1xuICBjb25zdCB0ZW1wID0geDtcbiAgcmV0dXJuIHRlbXAgPT09IFwiTFwiIHx8IHRlbXAgPT09IFwiUlwiIHx8IHRlbXAgPT09IFwiVFwiIHx8IHRlbXAgPT09IFwiQlwiO1xufSwgXCJpc0FyY2hpdGVjdHVyZURpcmVjdGlvblwiKTtcbnZhciBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblggPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHgpIHtcbiAgY29uc3QgdGVtcCA9IHg7XG4gIHJldHVybiB0ZW1wID09PSBcIkxcIiB8fCB0ZW1wID09PSBcIlJcIjtcbn0sIFwiaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YXCIpO1xudmFyIGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oeCkge1xuICBjb25zdCB0ZW1wID0geDtcbiAgcmV0dXJuIHRlbXAgPT09IFwiVFwiIHx8IHRlbXAgPT09IFwiQlwiO1xufSwgXCJpc0FyY2hpdGVjdHVyZURpcmVjdGlvbllcIik7XG52YXIgaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YWSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oYSwgYikge1xuICBjb25zdCBhWF9iWSA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChhKSAmJiBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkoYik7XG4gIGNvbnN0IGFZX2JYID0gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25ZKGEpICYmIGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChiKTtcbiAgcmV0dXJuIGFYX2JZIHx8IGFZX2JYO1xufSwgXCJpc0FyY2hpdGVjdHVyZURpcmVjdGlvblhZXCIpO1xudmFyIGlzQXJjaGl0ZWN0dXJlUGFpclhZID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihwYWlyKSB7XG4gIGNvbnN0IGxocyA9IHBhaXJbMF07XG4gIGNvbnN0IHJocyA9IHBhaXJbMV07XG4gIGNvbnN0IGFYX2JZID0gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKGxocykgJiYgaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25ZKHJocyk7XG4gIGNvbnN0IGFZX2JYID0gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25ZKGxocykgJiYgaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHJocyk7XG4gIHJldHVybiBhWF9iWSB8fCBhWV9iWDtcbn0sIFwiaXNBcmNoaXRlY3R1cmVQYWlyWFlcIik7XG52YXIgaXNWYWxpZEFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT09IFwiTExcIiAmJiB4ICE9PSBcIlJSXCIgJiYgeCAhPT0gXCJUVFwiICYmIHggIT09IFwiQkJcIjtcbn0sIFwiaXNWYWxpZEFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXJcIik7XG52YXIgZ2V0QXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oc291cmNlRGlyLCB0YXJnZXREaXIpIHtcbiAgY29uc3QgcGFpciA9IGAke3NvdXJjZURpcn0ke3RhcmdldERpcn1gO1xuICByZXR1cm4gaXNWYWxpZEFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXIocGFpcikgPyBwYWlyIDogdm9pZCAwO1xufSwgXCJnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyXCIpO1xudmFyIHNoaWZ0UG9zaXRpb25CeUFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKFt4LCB5XSwgcGFpcikge1xuICBjb25zdCBsaHMgPSBwYWlyWzBdO1xuICBjb25zdCByaHMgPSBwYWlyWzFdO1xuICBpZiAoaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKGxocykpIHtcbiAgICBpZiAoaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25ZKHJocykpIHtcbiAgICAgIHJldHVybiBbeCArIChsaHMgPT09IFwiTFwiID8gLTEgOiAxKSwgeSArIChyaHMgPT09IFwiVFwiID8gMSA6IC0xKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbeCArIChsaHMgPT09IFwiTFwiID8gLTEgOiAxKSwgeV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgocmhzKSkge1xuICAgICAgcmV0dXJuIFt4ICsgKHJocyA9PT0gXCJMXCIgPyAxIDogLTEpLCB5ICsgKGxocyA9PT0gXCJUXCIgPyAxIDogLTEpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt4LCB5ICsgKGxocyA9PT0gXCJUXCIgPyAxIDogLTEpXTtcbiAgICB9XG4gIH1cbn0sIFwic2hpZnRQb3NpdGlvbkJ5QXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpclwiKTtcbnZhciBnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25YWUZhY3RvcnMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHBhaXIpIHtcbiAgaWYgKHBhaXIgPT09IFwiTFRcIiB8fCBwYWlyID09PSBcIlRMXCIpIHtcbiAgICByZXR1cm4gWzEsIDFdO1xuICB9IGVsc2UgaWYgKHBhaXIgPT09IFwiQkxcIiB8fCBwYWlyID09PSBcIkxCXCIpIHtcbiAgICByZXR1cm4gWzEsIC0xXTtcbiAgfSBlbHNlIGlmIChwYWlyID09PSBcIkJSXCIgfHwgcGFpciA9PT0gXCJSQlwiKSB7XG4gICAgcmV0dXJuIFstMSwgLTFdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbLTEsIDFdO1xuICB9XG59LCBcImdldEFyY2hpdGVjdHVyZURpcmVjdGlvblhZRmFjdG9yc1wiKTtcbnZhciBnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25BbGlnbm1lbnQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWFkoYSwgYikpIHtcbiAgICByZXR1cm4gXCJiZW5kXCI7XG4gIH0gZWxzZSBpZiAoaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKGEpKSB7XG4gICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICB9XG4gIHJldHVybiBcInZlcnRpY2FsXCI7XG59LCBcImdldEFyY2hpdGVjdHVyZURpcmVjdGlvbkFsaWdubWVudFwiKTtcbnZhciBpc0FyY2hpdGVjdHVyZVNlcnZpY2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHgpIHtcbiAgY29uc3QgdGVtcCA9IHg7XG4gIHJldHVybiB0ZW1wLnR5cGUgPT09IFwic2VydmljZVwiO1xufSwgXCJpc0FyY2hpdGVjdHVyZVNlcnZpY2VcIik7XG52YXIgaXNBcmNoaXRlY3R1cmVKdW5jdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oeCkge1xuICBjb25zdCB0ZW1wID0geDtcbiAgcmV0dXJuIHRlbXAudHlwZSA9PT0gXCJqdW5jdGlvblwiO1xufSwgXCJpc0FyY2hpdGVjdHVyZUp1bmN0aW9uXCIpO1xudmFyIGVkZ2VEYXRhID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZWRnZSkgPT4ge1xuICByZXR1cm4gZWRnZS5kYXRhKCk7XG59LCBcImVkZ2VEYXRhXCIpO1xudmFyIG5vZGVEYXRhID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgobm9kZSkgPT4ge1xuICByZXR1cm4gbm9kZS5kYXRhKCk7XG59LCBcIm5vZGVEYXRhXCIpO1xuXG4vLyBzcmMvZGlhZ3JhbXMvYXJjaGl0ZWN0dXJlL2FyY2hpdGVjdHVyZURiLnRzXG52YXIgREVGQVVMVF9BUkNISVRFQ1RVUkVfQ09ORklHID0gZGVmYXVsdENvbmZpZ19kZWZhdWx0LmFyY2hpdGVjdHVyZTtcbnZhciBzdGF0ZSA9IG5ldyBJbXBlcmF0aXZlU3RhdGUoKCkgPT4gKHtcbiAgbm9kZXM6IHt9LFxuICBncm91cHM6IHt9LFxuICBlZGdlczogW10sXG4gIHJlZ2lzdGVyZWRJZHM6IHt9LFxuICBjb25maWc6IERFRkFVTFRfQVJDSElURUNUVVJFX0NPTkZJRyxcbiAgZGF0YVN0cnVjdHVyZXM6IHZvaWQgMCxcbiAgZWxlbWVudHM6IHt9XG59KSk7XG52YXIgY2xlYXIyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gIHN0YXRlLnJlc2V0KCk7XG4gIGNsZWFyKCk7XG59LCBcImNsZWFyXCIpO1xudmFyIGFkZFNlcnZpY2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHtcbiAgaWQsXG4gIGljb24sXG4gIGluOiBwYXJlbnQsXG4gIHRpdGxlLFxuICBpY29uVGV4dFxufSkge1xuICBpZiAoc3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW2lkXSAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBzZXJ2aWNlIGlkIFske2lkfV0gaXMgYWxyZWFkeSBpbiB1c2UgYnkgYW5vdGhlciAke3N0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1tpZF19YFxuICAgICk7XG4gIH1cbiAgaWYgKHBhcmVudCAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKGlkID09PSBwYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNlcnZpY2UgWyR7aWR9XSBjYW5ub3QgYmUgcGxhY2VkIHdpdGhpbiBpdHNlbGZgKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1twYXJlbnRdID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSBzZXJ2aWNlIFske2lkfV0ncyBwYXJlbnQgZG9lcyBub3QgZXhpc3QuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHBhcmVudCBpcyBjcmVhdGVkIGJlZm9yZSB0aGlzIHNlcnZpY2VgXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW3BhcmVudF0gPT09IFwibm9kZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzZXJ2aWNlIFske2lkfV0ncyBwYXJlbnQgaXMgbm90IGEgZ3JvdXBgKTtcbiAgICB9XG4gIH1cbiAgc3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW2lkXSA9IFwibm9kZVwiO1xuICBzdGF0ZS5yZWNvcmRzLm5vZGVzW2lkXSA9IHtcbiAgICBpZCxcbiAgICB0eXBlOiBcInNlcnZpY2VcIixcbiAgICBpY29uLFxuICAgIGljb25UZXh0LFxuICAgIHRpdGxlLFxuICAgIGVkZ2VzOiBbXSxcbiAgICBpbjogcGFyZW50XG4gIH07XG59LCBcImFkZFNlcnZpY2VcIik7XG52YXIgZ2V0U2VydmljZXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IE9iamVjdC52YWx1ZXMoc3RhdGUucmVjb3Jkcy5ub2RlcykuZmlsdGVyKGlzQXJjaGl0ZWN0dXJlU2VydmljZSksIFwiZ2V0U2VydmljZXNcIik7XG52YXIgYWRkSnVuY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHsgaWQsIGluOiBwYXJlbnQgfSkge1xuICBzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbaWRdID0gXCJub2RlXCI7XG4gIHN0YXRlLnJlY29yZHMubm9kZXNbaWRdID0ge1xuICAgIGlkLFxuICAgIHR5cGU6IFwianVuY3Rpb25cIixcbiAgICBlZGdlczogW10sXG4gICAgaW46IHBhcmVudFxuICB9O1xufSwgXCJhZGRKdW5jdGlvblwiKTtcbnZhciBnZXRKdW5jdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IE9iamVjdC52YWx1ZXMoc3RhdGUucmVjb3Jkcy5ub2RlcykuZmlsdGVyKGlzQXJjaGl0ZWN0dXJlSnVuY3Rpb24pLCBcImdldEp1bmN0aW9uc1wiKTtcbnZhciBnZXROb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gT2JqZWN0LnZhbHVlcyhzdGF0ZS5yZWNvcmRzLm5vZGVzKSwgXCJnZXROb2Rlc1wiKTtcbnZhciBnZXROb2RlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoaWQpID0+IHN0YXRlLnJlY29yZHMubm9kZXNbaWRdLCBcImdldE5vZGVcIik7XG52YXIgYWRkR3JvdXAgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHsgaWQsIGljb24sIGluOiBwYXJlbnQsIHRpdGxlIH0pIHtcbiAgaWYgKHN0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1tpZF0gIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgZ3JvdXAgaWQgWyR7aWR9XSBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyICR7c3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW2lkXX1gXG4gICAgKTtcbiAgfVxuICBpZiAocGFyZW50ICE9PSB2b2lkIDApIHtcbiAgICBpZiAoaWQgPT09IHBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZ3JvdXAgWyR7aWR9XSBjYW5ub3QgYmUgcGxhY2VkIHdpdGhpbiBpdHNlbGZgKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1twYXJlbnRdID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSBncm91cCBbJHtpZH1dJ3MgcGFyZW50IGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBwYXJlbnQgaXMgY3JlYXRlZCBiZWZvcmUgdGhpcyBncm91cGBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbcGFyZW50XSA9PT0gXCJub2RlXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGdyb3VwIFske2lkfV0ncyBwYXJlbnQgaXMgbm90IGEgZ3JvdXBgKTtcbiAgICB9XG4gIH1cbiAgc3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW2lkXSA9IFwiZ3JvdXBcIjtcbiAgc3RhdGUucmVjb3Jkcy5ncm91cHNbaWRdID0ge1xuICAgIGlkLFxuICAgIGljb24sXG4gICAgdGl0bGUsXG4gICAgaW46IHBhcmVudFxuICB9O1xufSwgXCJhZGRHcm91cFwiKTtcbnZhciBnZXRHcm91cHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGUucmVjb3Jkcy5ncm91cHMpO1xufSwgXCJnZXRHcm91cHNcIik7XG52YXIgYWRkRWRnZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oe1xuICBsaHNJZCxcbiAgcmhzSWQsXG4gIGxoc0RpcixcbiAgcmhzRGlyLFxuICBsaHNJbnRvLFxuICByaHNJbnRvLFxuICBsaHNHcm91cCxcbiAgcmhzR3JvdXAsXG4gIHRpdGxlXG59KSB7XG4gIGlmICghaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb24obGhzRGlyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGRpcmVjdGlvbiBnaXZlbiBmb3IgbGVmdCBoYW5kIHNpZGUgb2YgZWRnZSAke2xoc0lkfS0tJHtyaHNJZH0uIEV4cGVjdGVkIChMLFIsVCxCKSBnb3QgJHtsaHNEaXJ9YFxuICAgICk7XG4gIH1cbiAgaWYgKCFpc0FyY2hpdGVjdHVyZURpcmVjdGlvbihyaHNEaXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgZGlyZWN0aW9uIGdpdmVuIGZvciByaWdodCBoYW5kIHNpZGUgb2YgZWRnZSAke2xoc0lkfS0tJHtyaHNJZH0uIEV4cGVjdGVkIChMLFIsVCxCKSBnb3QgJHtyaHNEaXJ9YFxuICAgICk7XG4gIH1cbiAgaWYgKHN0YXRlLnJlY29yZHMubm9kZXNbbGhzSWRdID09PSB2b2lkIDAgJiYgc3RhdGUucmVjb3Jkcy5ncm91cHNbbGhzSWRdID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIGxlZnQtaGFuZCBpZCBbJHtsaHNJZH1dIGRvZXMgbm90IHlldCBleGlzdC4gUGxlYXNlIGNyZWF0ZSB0aGUgc2VydmljZS9ncm91cCBiZWZvcmUgZGVjbGFyaW5nIGFuIGVkZ2UgdG8gaXQuYFxuICAgICk7XG4gIH1cbiAgaWYgKHN0YXRlLnJlY29yZHMubm9kZXNbcmhzSWRdID09PSB2b2lkIDAgJiYgc3RhdGUucmVjb3Jkcy5ncm91cHNbbGhzSWRdID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIHJpZ2h0LWhhbmQgaWQgWyR7cmhzSWR9XSBkb2VzIG5vdCB5ZXQgZXhpc3QuIFBsZWFzZSBjcmVhdGUgdGhlIHNlcnZpY2UvZ3JvdXAgYmVmb3JlIGRlY2xhcmluZyBhbiBlZGdlIHRvIGl0LmBcbiAgICApO1xuICB9XG4gIGNvbnN0IGxoc0dyb3VwSWQgPSBzdGF0ZS5yZWNvcmRzLm5vZGVzW2xoc0lkXS5pbjtcbiAgY29uc3QgcmhzR3JvdXBJZCA9IHN0YXRlLnJlY29yZHMubm9kZXNbcmhzSWRdLmluO1xuICBpZiAobGhzR3JvdXAgJiYgbGhzR3JvdXBJZCAmJiByaHNHcm91cElkICYmIGxoc0dyb3VwSWQgPT0gcmhzR3JvdXBJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgbGVmdC1oYW5kIGlkIFske2xoc0lkfV0gaXMgbW9kaWZpZWQgdG8gdHJhdmVyc2UgdGhlIGdyb3VwIGJvdW5kYXJ5LCBidXQgdGhlIGVkZ2UgZG9lcyBub3QgcGFzcyB0aHJvdWdoIHR3byBncm91cHMuYFxuICAgICk7XG4gIH1cbiAgaWYgKHJoc0dyb3VwICYmIGxoc0dyb3VwSWQgJiYgcmhzR3JvdXBJZCAmJiBsaHNHcm91cElkID09IHJoc0dyb3VwSWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIHJpZ2h0LWhhbmQgaWQgWyR7cmhzSWR9XSBpcyBtb2RpZmllZCB0byB0cmF2ZXJzZSB0aGUgZ3JvdXAgYm91bmRhcnksIGJ1dCB0aGUgZWRnZSBkb2VzIG5vdCBwYXNzIHRocm91Z2ggdHdvIGdyb3Vwcy5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBlZGdlID0ge1xuICAgIGxoc0lkLFxuICAgIGxoc0RpcixcbiAgICBsaHNJbnRvLFxuICAgIGxoc0dyb3VwLFxuICAgIHJoc0lkLFxuICAgIHJoc0RpcixcbiAgICByaHNJbnRvLFxuICAgIHJoc0dyb3VwLFxuICAgIHRpdGxlXG4gIH07XG4gIHN0YXRlLnJlY29yZHMuZWRnZXMucHVzaChlZGdlKTtcbiAgaWYgKHN0YXRlLnJlY29yZHMubm9kZXNbbGhzSWRdICYmIHN0YXRlLnJlY29yZHMubm9kZXNbcmhzSWRdKSB7XG4gICAgc3RhdGUucmVjb3Jkcy5ub2Rlc1tsaHNJZF0uZWRnZXMucHVzaChzdGF0ZS5yZWNvcmRzLmVkZ2VzW3N0YXRlLnJlY29yZHMuZWRnZXMubGVuZ3RoIC0gMV0pO1xuICAgIHN0YXRlLnJlY29yZHMubm9kZXNbcmhzSWRdLmVkZ2VzLnB1c2goc3RhdGUucmVjb3Jkcy5lZGdlc1tzdGF0ZS5yZWNvcmRzLmVkZ2VzLmxlbmd0aCAtIDFdKTtcbiAgfVxufSwgXCJhZGRFZGdlXCIpO1xudmFyIGdldEVkZ2VzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBzdGF0ZS5yZWNvcmRzLmVkZ2VzLCBcImdldEVkZ2VzXCIpO1xudmFyIGdldERhdGFTdHJ1Y3R1cmVzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gIGlmIChzdGF0ZS5yZWNvcmRzLmRhdGFTdHJ1Y3R1cmVzID09PSB2b2lkIDApIHtcbiAgICBjb25zdCBncm91cEFsaWdubWVudHMgPSB7fTtcbiAgICBjb25zdCBhZGpMaXN0ID0gT2JqZWN0LmVudHJpZXMoc3RhdGUucmVjb3Jkcy5ub2RlcykucmVkdWNlKChwcmV2T3V0ZXIsIFtpZCwgc2VydmljZV0pID0+IHtcbiAgICAgIHByZXZPdXRlcltpZF0gPSBzZXJ2aWNlLmVkZ2VzLnJlZHVjZSgocHJldklubmVyLCBlZGdlKSA9PiB7XG4gICAgICAgIGNvbnN0IGxoc0dyb3VwSWQgPSBnZXROb2RlKGVkZ2UubGhzSWQpPy5pbjtcbiAgICAgICAgY29uc3QgcmhzR3JvdXBJZCA9IGdldE5vZGUoZWRnZS5yaHNJZCk/LmluO1xuICAgICAgICBpZiAobGhzR3JvdXBJZCAmJiByaHNHcm91cElkICYmIGxoc0dyb3VwSWQgIT09IHJoc0dyb3VwSWQpIHtcbiAgICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25BbGlnbm1lbnQoZWRnZS5saHNEaXIsIGVkZ2UucmhzRGlyKTtcbiAgICAgICAgICBpZiAoYWxpZ25tZW50ICE9PSBcImJlbmRcIikge1xuICAgICAgICAgICAgZ3JvdXBBbGlnbm1lbnRzW2xoc0dyb3VwSWRdID8/PSB7fTtcbiAgICAgICAgICAgIGdyb3VwQWxpZ25tZW50c1tsaHNHcm91cElkXVtyaHNHcm91cElkXSA9IGFsaWdubWVudDtcbiAgICAgICAgICAgIGdyb3VwQWxpZ25tZW50c1tyaHNHcm91cElkXSA/Pz0ge307XG4gICAgICAgICAgICBncm91cEFsaWdubWVudHNbcmhzR3JvdXBJZF1bbGhzR3JvdXBJZF0gPSBhbGlnbm1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZGdlLmxoc0lkID09PSBpZCkge1xuICAgICAgICAgIGNvbnN0IHBhaXIgPSBnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyKGVkZ2UubGhzRGlyLCBlZGdlLnJoc0Rpcik7XG4gICAgICAgICAgaWYgKHBhaXIpIHtcbiAgICAgICAgICAgIHByZXZJbm5lcltwYWlyXSA9IGVkZ2UucmhzSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhaXIgPSBnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyKGVkZ2UucmhzRGlyLCBlZGdlLmxoc0Rpcik7XG4gICAgICAgICAgaWYgKHBhaXIpIHtcbiAgICAgICAgICAgIHByZXZJbm5lcltwYWlyXSA9IGVkZ2UubGhzSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2SW5uZXI7XG4gICAgICB9LCB7fSk7XG4gICAgICByZXR1cm4gcHJldk91dGVyO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBmaXJzdElkID0gT2JqZWN0LmtleXMoYWRqTGlzdClbMF07XG4gICAgY29uc3QgdmlzaXRlZCA9IHsgW2ZpcnN0SWRdOiAxIH07XG4gICAgY29uc3Qgbm90VmlzaXRlZCA9IE9iamVjdC5rZXlzKGFkakxpc3QpLnJlZHVjZShcbiAgICAgIChwcmV2LCBpZCkgPT4gaWQgPT09IGZpcnN0SWQgPyBwcmV2IDogeyAuLi5wcmV2LCBbaWRdOiAxIH0sXG4gICAgICB7fVxuICAgICk7XG4gICAgY29uc3QgQkZTID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc3RhcnRpbmdJZCkgPT4ge1xuICAgICAgY29uc3Qgc3BhdGlhbE1hcCA9IHsgW3N0YXJ0aW5nSWRdOiBbMCwgMF0gfTtcbiAgICAgIGNvbnN0IHF1ZXVlID0gW3N0YXJ0aW5nSWRdO1xuICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaWQgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICB2aXNpdGVkW2lkXSA9IDE7XG4gICAgICAgICAgZGVsZXRlIG5vdFZpc2l0ZWRbaWRdO1xuICAgICAgICAgIGNvbnN0IGFkaiA9IGFkakxpc3RbaWRdO1xuICAgICAgICAgIGNvbnN0IFtwb3NYLCBwb3NZXSA9IHNwYXRpYWxNYXBbaWRdO1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFkaikuZm9yRWFjaCgoW2RpciwgcmhzSWRdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcmhzSWRdKSB7XG4gICAgICAgICAgICAgIHNwYXRpYWxNYXBbcmhzSWRdID0gc2hpZnRQb3NpdGlvbkJ5QXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpcihcbiAgICAgICAgICAgICAgICBbcG9zWCwgcG9zWV0sXG4gICAgICAgICAgICAgICAgZGlyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHF1ZXVlLnB1c2gocmhzSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BhdGlhbE1hcDtcbiAgICB9LCBcIkJGU1wiKTtcbiAgICBjb25zdCBzcGF0aWFsTWFwcyA9IFtCRlMoZmlyc3RJZCldO1xuICAgIHdoaWxlIChPYmplY3Qua2V5cyhub3RWaXNpdGVkKS5sZW5ndGggPiAwKSB7XG4gICAgICBzcGF0aWFsTWFwcy5wdXNoKEJGUyhPYmplY3Qua2V5cyhub3RWaXNpdGVkKVswXSkpO1xuICAgIH1cbiAgICBzdGF0ZS5yZWNvcmRzLmRhdGFTdHJ1Y3R1cmVzID0ge1xuICAgICAgYWRqTGlzdCxcbiAgICAgIHNwYXRpYWxNYXBzLFxuICAgICAgZ3JvdXBBbGlnbm1lbnRzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGUucmVjb3Jkcy5kYXRhU3RydWN0dXJlcztcbn0sIFwiZ2V0RGF0YVN0cnVjdHVyZXNcIik7XG52YXIgc2V0RWxlbWVudEZvcklkID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoaWQsIGVsZW1lbnQpID0+IHtcbiAgc3RhdGUucmVjb3Jkcy5lbGVtZW50c1tpZF0gPSBlbGVtZW50O1xufSwgXCJzZXRFbGVtZW50Rm9ySWRcIik7XG52YXIgZ2V0RWxlbWVudEJ5SWQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChpZCkgPT4gc3RhdGUucmVjb3Jkcy5lbGVtZW50c1tpZF0sIFwiZ2V0RWxlbWVudEJ5SWRcIik7XG52YXIgZGIgPSB7XG4gIGNsZWFyOiBjbGVhcjIsXG4gIHNldERpYWdyYW1UaXRsZSxcbiAgZ2V0RGlhZ3JhbVRpdGxlLFxuICBzZXRBY2NUaXRsZSxcbiAgZ2V0QWNjVGl0bGUsXG4gIHNldEFjY0Rlc2NyaXB0aW9uLFxuICBnZXRBY2NEZXNjcmlwdGlvbixcbiAgYWRkU2VydmljZSxcbiAgZ2V0U2VydmljZXMsXG4gIGFkZEp1bmN0aW9uLFxuICBnZXRKdW5jdGlvbnMsXG4gIGdldE5vZGVzLFxuICBnZXROb2RlLFxuICBhZGRHcm91cCxcbiAgZ2V0R3JvdXBzLFxuICBhZGRFZGdlLFxuICBnZXRFZGdlcyxcbiAgc2V0RWxlbWVudEZvcklkLFxuICBnZXRFbGVtZW50QnlJZCxcbiAgZ2V0RGF0YVN0cnVjdHVyZXNcbn07XG5mdW5jdGlvbiBnZXRDb25maWdGaWVsZChmaWVsZCkge1xuICBjb25zdCBhcmNoID0gZ2V0Q29uZmlnKCkuYXJjaGl0ZWN0dXJlO1xuICBpZiAoYXJjaD8uW2ZpZWxkXSkge1xuICAgIHJldHVybiBhcmNoW2ZpZWxkXTtcbiAgfVxuICByZXR1cm4gREVGQVVMVF9BUkNISVRFQ1RVUkVfQ09ORklHW2ZpZWxkXTtcbn1cbl9fbmFtZShnZXRDb25maWdGaWVsZCwgXCJnZXRDb25maWdGaWVsZFwiKTtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVQYXJzZXIudHNcbnZhciBwb3B1bGF0ZURiID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoYXN0LCBkYjIpID0+IHtcbiAgcG9wdWxhdGVDb21tb25EYihhc3QsIGRiMik7XG4gIGFzdC5ncm91cHMubWFwKGRiMi5hZGRHcm91cCk7XG4gIGFzdC5zZXJ2aWNlcy5tYXAoKHNlcnZpY2UpID0+IGRiMi5hZGRTZXJ2aWNlKHsgLi4uc2VydmljZSwgdHlwZTogXCJzZXJ2aWNlXCIgfSkpO1xuICBhc3QuanVuY3Rpb25zLm1hcCgoc2VydmljZSkgPT4gZGIyLmFkZEp1bmN0aW9uKHsgLi4uc2VydmljZSwgdHlwZTogXCJqdW5jdGlvblwiIH0pKTtcbiAgYXN0LmVkZ2VzLm1hcChkYjIuYWRkRWRnZSk7XG59LCBcInBvcHVsYXRlRGJcIik7XG52YXIgcGFyc2VyID0ge1xuICBwYXJzZTogLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAoaW5wdXQpID0+IHtcbiAgICBjb25zdCBhc3QgPSBhd2FpdCBwYXJzZShcImFyY2hpdGVjdHVyZVwiLCBpbnB1dCk7XG4gICAgbG9nLmRlYnVnKGFzdCk7XG4gICAgcG9wdWxhdGVEYihhc3QsIGRiKTtcbiAgfSwgXCJwYXJzZVwiKVxufTtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVTdHlsZXMudHNcbnZhciBnZXRTdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcHRpb25zKSA9PiBgXG4gIC5lZGdlIHtcbiAgICBzdHJva2Utd2lkdGg6ICR7b3B0aW9ucy5hcmNoRWRnZVdpZHRofTtcbiAgICBzdHJva2U6ICR7b3B0aW9ucy5hcmNoRWRnZUNvbG9yfTtcbiAgICBmaWxsOiBub25lO1xuICB9XG5cbiAgLmFycm93IHtcbiAgICBmaWxsOiAke29wdGlvbnMuYXJjaEVkZ2VBcnJvd0NvbG9yfTtcbiAgfVxuXG4gIC5ub2RlLWJrZyB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICR7b3B0aW9ucy5hcmNoR3JvdXBCb3JkZXJDb2xvcn07XG4gICAgc3Ryb2tlLXdpZHRoOiAke29wdGlvbnMuYXJjaEdyb3VwQm9yZGVyV2lkdGh9O1xuICAgIHN0cm9rZS1kYXNoYXJyYXk6IDg7XG4gIH1cbiAgLm5vZGUtaWNvbi10ZXh0IHtcbiAgICBkaXNwbGF5OiBmbGV4OyBcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG4gIFxuICAubm9kZS1pY29uLXRleHQgPiBkaXYge1xuICAgIGNvbG9yOiAjZmZmO1xuICAgIG1hcmdpbjogMXB4O1xuICAgIGhlaWdodDogZml0LWNvbnRlbnQ7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgfVxuYCwgXCJnZXRTdHlsZXNcIik7XG52YXIgYXJjaGl0ZWN0dXJlU3R5bGVzX2RlZmF1bHQgPSBnZXRTdHlsZXM7XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvYXJjaGl0ZWN0dXJlUmVuZGVyZXIudHNcbmltcG9ydCBjeXRvc2NhcGUgZnJvbSBcImN5dG9zY2FwZVwiO1xuaW1wb3J0IGZjb3NlIGZyb20gXCJjeXRvc2NhcGUtZmNvc2VcIjtcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gXCJkM1wiO1xuXG4vLyBzcmMvZGlhZ3JhbXMvYXJjaGl0ZWN0dXJlL2FyY2hpdGVjdHVyZUljb25zLnRzXG52YXIgd3JhcEljb24gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChpY29uKSA9PiB7XG4gIHJldHVybiBgPGc+PHJlY3Qgd2lkdGg9XCI4MFwiIGhlaWdodD1cIjgwXCIgc3R5bGU9XCJmaWxsOiAjMDg3ZWJmOyBzdHJva2Utd2lkdGg6IDBweDtcIi8+JHtpY29ufTwvZz5gO1xufSwgXCJ3cmFwSWNvblwiKTtcbnZhciBhcmNoaXRlY3R1cmVJY29ucyA9IHtcbiAgcHJlZml4OiBcIm1lcm1haWQtYXJjaGl0ZWN0dXJlXCIsXG4gIGhlaWdodDogODAsXG4gIHdpZHRoOiA4MCxcbiAgaWNvbnM6IHtcbiAgICBkYXRhYmFzZToge1xuICAgICAgYm9keTogd3JhcEljb24oXG4gICAgICAgICc8cGF0aCBpZD1cImJcIiBkYXRhLW5hbWU9XCI0XCIgZD1cIm0yMCw1Ny44NmMwLDMuOTQsOC45NSw3LjE0LDIwLDcuMTRzMjAtMy4yLDIwLTcuMTRcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PHBhdGggaWQ9XCJjXCIgZGF0YS1uYW1lPVwiM1wiIGQ9XCJtMjAsNDUuOTVjMCwzLjk0LDguOTUsNy4xNCwyMCw3LjE0czIwLTMuMiwyMC03LjE0XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxwYXRoIGlkPVwiZFwiIGRhdGEtbmFtZT1cIjJcIiBkPVwibTIwLDM0LjA1YzAsMy45NCw4Ljk1LDcuMTQsMjAsNy4xNHMyMC0zLjIsMjAtNy4xNFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48ZWxsaXBzZSBpZD1cImVcIiBkYXRhLW5hbWU9XCIxXCIgY3g9XCI0MFwiIGN5PVwiMjIuMTRcIiByeD1cIjIwXCIgcnk9XCI3LjE0XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxsaW5lIHgxPVwiMjBcIiB5MT1cIjU3Ljg2XCIgeDI9XCIyMFwiIHkyPVwiMjIuMTRcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGxpbmUgeDE9XCI2MFwiIHkxPVwiNTcuODZcIiB4Mj1cIjYwXCIgeTI9XCIyMi4xNFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz4nXG4gICAgICApXG4gICAgfSxcbiAgICBzZXJ2ZXI6IHtcbiAgICAgIGJvZHk6IHdyYXBJY29uKFxuICAgICAgICAnPHJlY3QgeD1cIjE3LjVcIiB5PVwiMTcuNVwiIHdpZHRoPVwiNDVcIiBoZWlnaHQ9XCI0NVwiIHJ4PVwiMlwiIHJ5PVwiMlwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48bGluZSB4MT1cIjE3LjVcIiB5MT1cIjMyLjVcIiB4Mj1cIjYyLjVcIiB5Mj1cIjMyLjVcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGxpbmUgeDE9XCIxNy41XCIgeTE9XCI0Ny41XCIgeDI9XCI2Mi41XCIgeTI9XCI0Ny41XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxnPjxwYXRoIGQ9XCJtNTYuMjUsMjVjMCwuMjctLjQ1LjUtMSwuNWgtMTAuNWMtLjU1LDAtMS0uMjMtMS0uNXMuNDUtLjUsMS0uNWgxMC41Yy41NSwwLDEsLjIzLDEsLjVaXCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2Utd2lkdGg6IDBweDtcIi8+PHBhdGggZD1cIm01Ni4yNSwyNWMwLC4yNy0uNDUuNS0xLC41aC0xMC41Yy0uNTUsMC0xLS4yMy0xLS41cy40NS0uNSwxLS41aDEwLjVjLjU1LDAsMSwuMjMsMSwuNVpcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48L2c+PGc+PHBhdGggZD1cIm01Ni4yNSw0MGMwLC4yNy0uNDUuNS0xLC41aC0xMC41Yy0uNTUsMC0xLS4yMy0xLS41cy40NS0uNSwxLS41aDEwLjVjLjU1LDAsMSwuMjMsMSwuNVpcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZS13aWR0aDogMHB4O1wiLz48cGF0aCBkPVwibTU2LjI1LDQwYzAsLjI3LS40NS41LTEsLjVoLTEwLjVjLS41NSwwLTEtLjIzLTEtLjVzLjQ1LS41LDEtLjVoMTAuNWMuNTUsMCwxLC4yMywxLC41WlwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjwvZz48Zz48cGF0aCBkPVwibTU2LjI1LDU1YzAsLjI3LS40NS41LTEsLjVoLTEwLjVjLS41NSwwLTEtLjIzLTEtLjVzLjQ1LS41LDEtLjVoMTAuNWMuNTUsMCwxLC4yMywxLC41WlwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlLXdpZHRoOiAwcHg7XCIvPjxwYXRoIGQ9XCJtNTYuMjUsNTVjMCwuMjctLjQ1LjUtMSwuNWgtMTAuNWMtLjU1LDAtMS0uMjMtMS0uNXMuNDUtLjUsMS0uNWgxMC41Yy41NSwwLDEsLjIzLDEsLjVaXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PC9nPjxnPjxjaXJjbGUgY3g9XCIzMi41XCIgY3k9XCIyNVwiIHI9XCIuNzVcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48Y2lyY2xlIGN4PVwiMjcuNVwiIGN5PVwiMjVcIiByPVwiLjc1XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PGNpcmNsZSBjeD1cIjIyLjVcIiBjeT1cIjI1XCIgcj1cIi43NVwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjwvZz48Zz48Y2lyY2xlIGN4PVwiMzIuNVwiIGN5PVwiNDBcIiByPVwiLjc1XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PGNpcmNsZSBjeD1cIjI3LjVcIiBjeT1cIjQwXCIgcj1cIi43NVwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjxjaXJjbGUgY3g9XCIyMi41XCIgY3k9XCI0MFwiIHI9XCIuNzVcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48L2c+PGc+PGNpcmNsZSBjeD1cIjMyLjVcIiBjeT1cIjU1XCIgcj1cIi43NVwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjxjaXJjbGUgY3g9XCIyNy41XCIgY3k9XCI1NVwiIHI9XCIuNzVcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48Y2lyY2xlIGN4PVwiMjIuNVwiIGN5PVwiNTVcIiByPVwiLjc1XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PC9nPidcbiAgICAgIClcbiAgICB9LFxuICAgIGRpc2s6IHtcbiAgICAgIGJvZHk6IHdyYXBJY29uKFxuICAgICAgICAnPHJlY3QgeD1cIjIwXCIgeT1cIjE1XCIgd2lkdGg9XCI0MFwiIGhlaWdodD1cIjUwXCIgcng9XCIxXCIgcnk9XCIxXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxlbGxpcHNlIGN4PVwiMjRcIiBjeT1cIjE5LjE3XCIgcng9XCIuOFwiIHJ5PVwiLjgzXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxlbGxpcHNlIGN4PVwiNTZcIiBjeT1cIjE5LjE3XCIgcng9XCIuOFwiIHJ5PVwiLjgzXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxlbGxpcHNlIGN4PVwiMjRcIiBjeT1cIjYwLjgzXCIgcng9XCIuOFwiIHJ5PVwiLjgzXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxlbGxpcHNlIGN4PVwiNTZcIiBjeT1cIjYwLjgzXCIgcng9XCIuOFwiIHJ5PVwiLjgzXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxlbGxpcHNlIGN4PVwiNDBcIiBjeT1cIjMzLjc1XCIgcng9XCIxNFwiIHJ5PVwiMTQuNThcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGVsbGlwc2UgY3g9XCI0MFwiIGN5PVwiMzMuNzVcIiByeD1cIjRcIiByeT1cIjQuMTdcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PHBhdGggZD1cIm0zNy41MSw0Mi41MmwtNC44MywxMy4yMmMtLjI2LjcxLTEuMSwxLjAyLTEuNzYuNjRsLTQuMTgtMi40MmMtLjY2LS4zOC0uODEtMS4yNi0uMzMtMS44NGw5LjAxLTEwLjhjLjg4LTEuMDUsMi41Ni0uMDgsMi4wOSwxLjJaXCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2Utd2lkdGg6IDBweDtcIi8+J1xuICAgICAgKVxuICAgIH0sXG4gICAgaW50ZXJuZXQ6IHtcbiAgICAgIGJvZHk6IHdyYXBJY29uKFxuICAgICAgICAnPGNpcmNsZSBjeD1cIjQwXCIgY3k9XCI0MFwiIHI9XCIyMi41XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxsaW5lIHgxPVwiNDBcIiB5MT1cIjE3LjVcIiB4Mj1cIjQwXCIgeTI9XCI2Mi41XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxsaW5lIHgxPVwiMTcuNVwiIHkxPVwiNDBcIiB4Mj1cIjYyLjVcIiB5Mj1cIjQwXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxwYXRoIGQ9XCJtMzkuOTksMTcuNTFjLTE1LjI4LDExLjEtMTUuMjgsMzMuODgsMCw0NC45OFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48cGF0aCBkPVwibTQwLjAxLDE3LjUxYzE1LjI4LDExLjEsMTUuMjgsMzMuODgsMCw0NC45OFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48bGluZSB4MT1cIjE5Ljc1XCIgeTE9XCIzMC4xXCIgeDI9XCI2MC4yNVwiIHkyPVwiMzAuMVwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48bGluZSB4MT1cIjE5Ljc1XCIgeTE9XCI0OS45XCIgeDI9XCI2MC4yNVwiIHkyPVwiNDkuOVwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz4nXG4gICAgICApXG4gICAgfSxcbiAgICBjbG91ZDoge1xuICAgICAgYm9keTogd3JhcEljb24oXG4gICAgICAgICc8cGF0aCBkPVwibTY1LDQ3LjVjMCwyLjc2LTIuMjQsNS01LDVIMjBjLTIuNzYsMC01LTIuMjQtNS01LDAtMS44NywxLjAzLTMuNTEsMi41Ni00LjM2LS4wNC0uMjEtLjA2LS40Mi0uMDYtLjY0LDAtMi42LDIuNDgtNC43NCw1LjY1LTQuOTcsMS42NS00LjUxLDYuMzQtNy43NiwxMS44NS03Ljc2Ljg2LDAsMS42OS4wOCwyLjUuMjMsMi4wOS0xLjU3LDQuNjktMi41LDcuNS0yLjUsNi4xLDAsMTEuMTksNC4zOCwxMi4yOCwxMC4xNywyLjE0LjU2LDMuNzIsMi41MSwzLjcyLDQuODMsMCwuMDMsMCwuMDctLjAxLjEsMi4yOS40Niw0LjAxLDIuNDgsNC4wMSw0LjlaXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPidcbiAgICAgIClcbiAgICB9LFxuICAgIHVua25vd246IHVua25vd25JY29uLFxuICAgIGJsYW5rOiB7XG4gICAgICBib2R5OiB3cmFwSWNvbihcIlwiKVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9zdmdEcmF3LnRzXG52YXIgZHJhd0VkZ2VzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyBmdW5jdGlvbihlZGdlc0VsLCBjeSkge1xuICBjb25zdCBwYWRkaW5nID0gZ2V0Q29uZmlnRmllbGQoXCJwYWRkaW5nXCIpO1xuICBjb25zdCBpY29uU2l6ZSA9IGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIik7XG4gIGNvbnN0IGhhbGZJY29uU2l6ZSA9IGljb25TaXplIC8gMjtcbiAgY29uc3QgYXJyb3dTaXplID0gaWNvblNpemUgLyA2O1xuICBjb25zdCBoYWxmQXJyb3dTaXplID0gYXJyb3dTaXplIC8gMjtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgY3kuZWRnZXMoKS5tYXAoYXN5bmMgKGVkZ2UpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzb3VyY2VEaXIsXG4gICAgICAgIHNvdXJjZUFycm93LFxuICAgICAgICBzb3VyY2VHcm91cCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0YXJnZXREaXIsXG4gICAgICAgIHRhcmdldEFycm93LFxuICAgICAgICB0YXJnZXRHcm91cCxcbiAgICAgICAgbGFiZWxcbiAgICAgIH0gPSBlZGdlRGF0YShlZGdlKTtcbiAgICAgIGxldCB7IHg6IHN0YXJ0WCwgeTogc3RhcnRZIH0gPSBlZGdlWzBdLnNvdXJjZUVuZHBvaW50KCk7XG4gICAgICBjb25zdCB7IHg6IG1pZFgsIHk6IG1pZFkgfSA9IGVkZ2VbMF0ubWlkcG9pbnQoKTtcbiAgICAgIGxldCB7IHg6IGVuZFgsIHk6IGVuZFkgfSA9IGVkZ2VbMF0udGFyZ2V0RW5kcG9pbnQoKTtcbiAgICAgIGNvbnN0IGdyb3VwRWRnZVNoaWZ0ID0gcGFkZGluZyArIDQ7XG4gICAgICBpZiAoc291cmNlR3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChzb3VyY2VEaXIpKSB7XG4gICAgICAgICAgc3RhcnRYICs9IHNvdXJjZURpciA9PT0gXCJMXCIgPyAtZ3JvdXBFZGdlU2hpZnQgOiBncm91cEVkZ2VTaGlmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFkgKz0gc291cmNlRGlyID09PSBcIlRcIiA/IC1ncm91cEVkZ2VTaGlmdCA6IGdyb3VwRWRnZVNoaWZ0ICsgMTg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRHcm91cCkge1xuICAgICAgICBpZiAoaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHRhcmdldERpcikpIHtcbiAgICAgICAgICBlbmRYICs9IHRhcmdldERpciA9PT0gXCJMXCIgPyAtZ3JvdXBFZGdlU2hpZnQgOiBncm91cEVkZ2VTaGlmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRZICs9IHRhcmdldERpciA9PT0gXCJUXCIgPyAtZ3JvdXBFZGdlU2hpZnQgOiBncm91cEVkZ2VTaGlmdCArIDE4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZUdyb3VwICYmIGRiLmdldE5vZGUoc291cmNlKT8udHlwZSA9PT0gXCJqdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgoc291cmNlRGlyKSkge1xuICAgICAgICAgIHN0YXJ0WCArPSBzb3VyY2VEaXIgPT09IFwiTFwiID8gaGFsZkljb25TaXplIDogLWhhbGZJY29uU2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFkgKz0gc291cmNlRGlyID09PSBcIlRcIiA/IGhhbGZJY29uU2l6ZSA6IC1oYWxmSWNvblNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGFyZ2V0R3JvdXAgJiYgZGIuZ2V0Tm9kZSh0YXJnZXQpPy50eXBlID09PSBcImp1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWCh0YXJnZXREaXIpKSB7XG4gICAgICAgICAgZW5kWCArPSB0YXJnZXREaXIgPT09IFwiTFwiID8gaGFsZkljb25TaXplIDogLWhhbGZJY29uU2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRZICs9IHRhcmdldERpciA9PT0gXCJUXCIgPyBoYWxmSWNvblNpemUgOiAtaGFsZkljb25TaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaCkge1xuICAgICAgICBjb25zdCBnID0gZWRnZXNFbC5pbnNlcnQoXCJnXCIpO1xuICAgICAgICBnLmluc2VydChcInBhdGhcIikuYXR0cihcImRcIiwgYE0gJHtzdGFydFh9LCR7c3RhcnRZfSBMICR7bWlkWH0sJHttaWRZfSBMJHtlbmRYfSwke2VuZFl9IGApLmF0dHIoXCJjbGFzc1wiLCBcImVkZ2VcIik7XG4gICAgICAgIGlmIChzb3VyY2VBcnJvdykge1xuICAgICAgICAgIGNvbnN0IHhTaGlmdCA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChzb3VyY2VEaXIpID8gQXJjaGl0ZWN0dXJlRGlyZWN0aW9uQXJyb3dTaGlmdFtzb3VyY2VEaXJdKHN0YXJ0WCwgYXJyb3dTaXplKSA6IHN0YXJ0WCAtIGhhbGZBcnJvd1NpemU7XG4gICAgICAgICAgY29uc3QgeVNoaWZ0ID0gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25ZKHNvdXJjZURpcikgPyBBcmNoaXRlY3R1cmVEaXJlY3Rpb25BcnJvd1NoaWZ0W3NvdXJjZURpcl0oc3RhcnRZLCBhcnJvd1NpemUpIDogc3RhcnRZIC0gaGFsZkFycm93U2l6ZTtcbiAgICAgICAgICBnLmluc2VydChcInBvbHlnb25cIikuYXR0cihcInBvaW50c1wiLCBBcmNoaXRlY3R1cmVEaXJlY3Rpb25BcnJvd1tzb3VyY2VEaXJdKGFycm93U2l6ZSkpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3hTaGlmdH0sJHt5U2hpZnR9KWApLmF0dHIoXCJjbGFzc1wiLCBcImFycm93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRBcnJvdykge1xuICAgICAgICAgIGNvbnN0IHhTaGlmdCA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWCh0YXJnZXREaXIpID8gQXJjaGl0ZWN0dXJlRGlyZWN0aW9uQXJyb3dTaGlmdFt0YXJnZXREaXJdKGVuZFgsIGFycm93U2l6ZSkgOiBlbmRYIC0gaGFsZkFycm93U2l6ZTtcbiAgICAgICAgICBjb25zdCB5U2hpZnQgPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkodGFyZ2V0RGlyKSA/IEFyY2hpdGVjdHVyZURpcmVjdGlvbkFycm93U2hpZnRbdGFyZ2V0RGlyXShlbmRZLCBhcnJvd1NpemUpIDogZW5kWSAtIGhhbGZBcnJvd1NpemU7XG4gICAgICAgICAgZy5pbnNlcnQoXCJwb2x5Z29uXCIpLmF0dHIoXCJwb2ludHNcIiwgQXJjaGl0ZWN0dXJlRGlyZWN0aW9uQXJyb3dbdGFyZ2V0RGlyXShhcnJvd1NpemUpKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHt4U2hpZnR9LCR7eVNoaWZ0fSlgKS5hdHRyKFwiY2xhc3NcIiwgXCJhcnJvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICBjb25zdCBheGlzID0gIWlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWFkoc291cmNlRGlyLCB0YXJnZXREaXIpID8gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHNvdXJjZURpcikgPyBcIlhcIiA6IFwiWVwiIDogXCJYWVwiO1xuICAgICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgICAgaWYgKGF4aXMgPT09IFwiWFwiKSB7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGguYWJzKHN0YXJ0WCAtIGVuZFgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gXCJZXCIpIHtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5hYnMoc3RhcnRZIC0gZW5kWSkgLyAxLjU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5hYnMoc3RhcnRYIC0gZW5kWCkgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0ZXh0RWxlbSA9IGcuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgICBhd2FpdCBjcmVhdGVUZXh0KFxuICAgICAgICAgICAgdGV4dEVsZW0sXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdXNlSHRtbExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBjbGFzc2VzOiBcImFyY2hpdGVjdHVyZS1zZXJ2aWNlLWxhYmVsXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDb25maWcoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGV4dEVsZW0uYXR0cihcImR5XCIsIFwiMWVtXCIpLmF0dHIoXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIikuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gXCJYXCIpIHtcbiAgICAgICAgICAgIHRleHRFbGVtLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtaWRYICsgXCIsIFwiICsgbWlkWSArIFwiKVwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF4aXMgPT09IFwiWVwiKSB7XG4gICAgICAgICAgICB0ZXh0RWxlbS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWlkWCArIFwiLCBcIiArIG1pZFkgKyBcIikgcm90YXRlKC05MClcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChheGlzID09PSBcIlhZXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyKHNvdXJjZURpciwgdGFyZ2V0RGlyKTtcbiAgICAgICAgICAgIGlmIChwYWlyICYmIGlzQXJjaGl0ZWN0dXJlUGFpclhZKHBhaXIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJib3hPcmlnID0gdGV4dEVsZW0ubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25YWUZhY3RvcnMocGFpcik7XG4gICAgICAgICAgICAgIHRleHRFbGVtLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImF1dG9cIikuYXR0cihcInRyYW5zZm9ybVwiLCBgcm90YXRlKCR7LTEgKiB4ICogeSAqIDQ1fSlgKTtcbiAgICAgICAgICAgICAgY29uc3QgYmJveE5ldyA9IHRleHRFbGVtLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgdGV4dEVsZW0uYXR0cihcbiAgICAgICAgICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGUoJHttaWRYfSwgJHttaWRZIC0gYmJveE9yaWcuaGVpZ2h0IC8gMn0pXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlKCR7eCAqIGJib3hOZXcud2lkdGggLyAyfSwgJHt5ICogYmJveE5ldy5oZWlnaHQgLyAyfSlcbiAgICAgICAgICAgICAgICByb3RhdGUoJHstMSAqIHggKiB5ICogNDV9LCAwLCAke2Jib3hPcmlnLmhlaWdodCAvIDJ9KVxuICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn0sIFwiZHJhd0VkZ2VzXCIpO1xudmFyIGRyYXdHcm91cHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jIGZ1bmN0aW9uKGdyb3Vwc0VsLCBjeSkge1xuICBjb25zdCBwYWRkaW5nID0gZ2V0Q29uZmlnRmllbGQoXCJwYWRkaW5nXCIpO1xuICBjb25zdCBncm91cEljb25TaXplID0gcGFkZGluZyAqIDAuNzU7XG4gIGNvbnN0IGZvbnRTaXplID0gZ2V0Q29uZmlnRmllbGQoXCJmb250U2l6ZVwiKTtcbiAgY29uc3QgaWNvblNpemUgPSBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpO1xuICBjb25zdCBoYWxmSWNvblNpemUgPSBpY29uU2l6ZSAvIDI7XG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGN5Lm5vZGVzKCkubWFwKGFzeW5jIChub2RlKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gbm9kZURhdGEobm9kZSk7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgY29uc3QgeyBoLCB3LCB4MSwgeTEgfSA9IG5vZGUuYm91bmRpbmdCb3goKTtcbiAgICAgICAgZ3JvdXBzRWwuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwieFwiLCB4MSArIGhhbGZJY29uU2l6ZSkuYXR0cihcInlcIiwgeTEgKyBoYWxmSWNvblNpemUpLmF0dHIoXCJ3aWR0aFwiLCB3KS5hdHRyKFwiaGVpZ2h0XCIsIGgpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtYmtnXCIpO1xuICAgICAgICBjb25zdCBncm91cExhYmVsQ29udGFpbmVyID0gZ3JvdXBzRWwuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgbGV0IHNoaWZ0ZWRYMSA9IHgxO1xuICAgICAgICBsZXQgc2hpZnRlZFkxID0geTE7XG4gICAgICAgIGlmIChkYXRhLmljb24pIHtcbiAgICAgICAgICBjb25zdCBia2dFbGVtID0gZ3JvdXBMYWJlbENvbnRhaW5lci5hcHBlbmQoXCJnXCIpO1xuICAgICAgICAgIGJrZ0VsZW0uaHRtbChcbiAgICAgICAgICAgIGA8Zz4ke2F3YWl0IGdldEljb25TVkcoZGF0YS5pY29uLCB7IGhlaWdodDogZ3JvdXBJY29uU2l6ZSwgd2lkdGg6IGdyb3VwSWNvblNpemUsIGZhbGxiYWNrUHJlZml4OiBhcmNoaXRlY3R1cmVJY29ucy5wcmVmaXggfSl9PC9nPmBcbiAgICAgICAgICApO1xuICAgICAgICAgIGJrZ0VsZW0uYXR0cihcbiAgICAgICAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICBcInRyYW5zbGF0ZShcIiArIChzaGlmdGVkWDEgKyBoYWxmSWNvblNpemUgKyAxKSArIFwiLCBcIiArIChzaGlmdGVkWTEgKyBoYWxmSWNvblNpemUgKyAxKSArIFwiKVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaGlmdGVkWDEgKz0gZ3JvdXBJY29uU2l6ZTtcbiAgICAgICAgICBzaGlmdGVkWTEgKz0gZm9udFNpemUgLyAyIC0gMSAtIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGFiZWwpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0RWxlbSA9IGdyb3VwTGFiZWxDb250YWluZXIuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgICBhd2FpdCBjcmVhdGVUZXh0KFxuICAgICAgICAgICAgdGV4dEVsZW0sXG4gICAgICAgICAgICBkYXRhLmxhYmVsLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB1c2VIdG1sTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICAgIGNsYXNzZXM6IFwiYXJjaGl0ZWN0dXJlLXNlcnZpY2UtbGFiZWxcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENvbmZpZygpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0ZXh0RWxlbS5hdHRyKFwiZHlcIiwgXCIxZW1cIikuYXR0cihcImFsaWdubWVudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKS5hdHRyKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJzdGFydFwiKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKTtcbiAgICAgICAgICB0ZXh0RWxlbS5hdHRyKFxuICAgICAgICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgIFwidHJhbnNsYXRlKFwiICsgKHNoaWZ0ZWRYMSArIGhhbGZJY29uU2l6ZSArIDQpICsgXCIsIFwiICsgKHNoaWZ0ZWRZMSArIGhhbGZJY29uU2l6ZSArIDIpICsgXCIpXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn0sIFwiZHJhd0dyb3Vwc1wiKTtcbnZhciBkcmF3U2VydmljZXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jIGZ1bmN0aW9uKGRiMiwgZWxlbSwgc2VydmljZXMpIHtcbiAgZm9yIChjb25zdCBzZXJ2aWNlIG9mIHNlcnZpY2VzKSB7XG4gICAgY29uc3Qgc2VydmljZUVsZW0gPSBlbGVtLmFwcGVuZChcImdcIik7XG4gICAgY29uc3QgaWNvblNpemUgPSBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpO1xuICAgIGlmIChzZXJ2aWNlLnRpdGxlKSB7XG4gICAgICBjb25zdCB0ZXh0RWxlbSA9IHNlcnZpY2VFbGVtLmFwcGVuZChcImdcIik7XG4gICAgICBhd2FpdCBjcmVhdGVUZXh0KFxuICAgICAgICB0ZXh0RWxlbSxcbiAgICAgICAgc2VydmljZS50aXRsZSxcbiAgICAgICAge1xuICAgICAgICAgIHVzZUh0bWxMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgIHdpZHRoOiBpY29uU2l6ZSAqIDEuNSxcbiAgICAgICAgICBjbGFzc2VzOiBcImFyY2hpdGVjdHVyZS1zZXJ2aWNlLWxhYmVsXCJcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29uZmlnKClcbiAgICAgICk7XG4gICAgICB0ZXh0RWxlbS5hdHRyKFwiZHlcIiwgXCIxZW1cIikuYXR0cihcImFsaWdubWVudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKS5hdHRyKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIikuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xuICAgICAgdGV4dEVsZW0uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGljb25TaXplIC8gMiArIFwiLCBcIiArIGljb25TaXplICsgXCIpXCIpO1xuICAgIH1cbiAgICBjb25zdCBia2dFbGVtID0gc2VydmljZUVsZW0uYXBwZW5kKFwiZ1wiKTtcbiAgICBpZiAoc2VydmljZS5pY29uKSB7XG4gICAgICBia2dFbGVtLmh0bWwoXG4gICAgICAgIGA8Zz4ke2F3YWl0IGdldEljb25TVkcoc2VydmljZS5pY29uLCB7IGhlaWdodDogaWNvblNpemUsIHdpZHRoOiBpY29uU2l6ZSwgZmFsbGJhY2tQcmVmaXg6IGFyY2hpdGVjdHVyZUljb25zLnByZWZpeCB9KX08L2c+YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHNlcnZpY2UuaWNvblRleHQpIHtcbiAgICAgIGJrZ0VsZW0uaHRtbChcbiAgICAgICAgYDxnPiR7YXdhaXQgZ2V0SWNvblNWRyhcImJsYW5rXCIsIHsgaGVpZ2h0OiBpY29uU2l6ZSwgd2lkdGg6IGljb25TaXplLCBmYWxsYmFja1ByZWZpeDogYXJjaGl0ZWN0dXJlSWNvbnMucHJlZml4IH0pfTwvZz5gXG4gICAgICApO1xuICAgICAgY29uc3QgdGV4dEVsZW1Db250YWluZXIgPSBia2dFbGVtLmFwcGVuZChcImdcIik7XG4gICAgICBjb25zdCBmbyA9IHRleHRFbGVtQ29udGFpbmVyLmFwcGVuZChcImZvcmVpZ25PYmplY3RcIikuYXR0cihcIndpZHRoXCIsIGljb25TaXplKS5hdHRyKFwiaGVpZ2h0XCIsIGljb25TaXplKTtcbiAgICAgIGNvbnN0IGRpdkVsZW0gPSBmby5hcHBlbmQoXCJkaXZcIikuYXR0cihcImNsYXNzXCIsIFwibm9kZS1pY29uLXRleHRcIikuYXR0cihcInN0eWxlXCIsIGBoZWlnaHQ6ICR7aWNvblNpemV9cHg7YCkuYXBwZW5kKFwiZGl2XCIpLmh0bWwoc2VydmljZS5pY29uVGV4dCk7XG4gICAgICBjb25zdCBmb250U2l6ZSA9IHBhcnNlSW50KFxuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkaXZFbGVtLm5vZGUoKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcImZvbnQtc2l6ZVwiKS5yZXBsYWNlKC9cXEQvZywgXCJcIilcbiAgICAgICkgPz8gMTY7XG4gICAgICBkaXZFbGVtLmF0dHIoXCJzdHlsZVwiLCBgLXdlYmtpdC1saW5lLWNsYW1wOiAke01hdGguZmxvb3IoKGljb25TaXplIC0gMikgLyBmb250U2l6ZSl9O2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBia2dFbGVtLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2dcIikuYXR0cihcImlkXCIsIFwibm9kZS1cIiArIHNlcnZpY2UuaWQpLmF0dHIoXG4gICAgICAgIFwiZFwiLFxuICAgICAgICBgTTAgJHtpY29uU2l6ZX0gdiR7LWljb25TaXplfSBxMCwtNSA1LC01IGgke2ljb25TaXplfSBxNSwwIDUsNSB2JHtpY29uU2l6ZX0gSDAgWmBcbiAgICAgICk7XG4gICAgfVxuICAgIHNlcnZpY2VFbGVtLmF0dHIoXCJjbGFzc1wiLCBcImFyY2hpdGVjdHVyZS1zZXJ2aWNlXCIpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2VydmljZUVsZW0uX2dyb3Vwc1swXVswXS5nZXRCQm94KCk7XG4gICAgc2VydmljZS53aWR0aCA9IHdpZHRoO1xuICAgIHNlcnZpY2UuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGRiMi5zZXRFbGVtZW50Rm9ySWQoc2VydmljZS5pZCwgc2VydmljZUVsZW0pO1xuICB9XG4gIHJldHVybiAwO1xufSwgXCJkcmF3U2VydmljZXNcIik7XG52YXIgZHJhd0p1bmN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oZGIyLCBlbGVtLCBqdW5jdGlvbnMpIHtcbiAganVuY3Rpb25zLmZvckVhY2goKGp1bmN0aW9uKSA9PiB7XG4gICAgY29uc3QganVuY3Rpb25FbGVtID0gZWxlbS5hcHBlbmQoXCJnXCIpO1xuICAgIGNvbnN0IGljb25TaXplID0gZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKTtcbiAgICBjb25zdCBia2dFbGVtID0ganVuY3Rpb25FbGVtLmFwcGVuZChcImdcIik7XG4gICAgYmtnRWxlbS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJpZFwiLCBcIm5vZGUtXCIgKyBqdW5jdGlvbi5pZCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCBcIjBcIikuYXR0cihcIndpZHRoXCIsIGljb25TaXplKS5hdHRyKFwiaGVpZ2h0XCIsIGljb25TaXplKTtcbiAgICBqdW5jdGlvbkVsZW0uYXR0cihcImNsYXNzXCIsIFwiYXJjaGl0ZWN0dXJlLWp1bmN0aW9uXCIpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0ganVuY3Rpb25FbGVtLl9ncm91cHNbMF1bMF0uZ2V0QkJveCgpO1xuICAgIGp1bmN0aW9uRWxlbS53aWR0aCA9IHdpZHRoO1xuICAgIGp1bmN0aW9uRWxlbS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgZGIyLnNldEVsZW1lbnRGb3JJZChqdW5jdGlvbi5pZCwganVuY3Rpb25FbGVtKTtcbiAgfSk7XG59LCBcImRyYXdKdW5jdGlvbnNcIik7XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvYXJjaGl0ZWN0dXJlUmVuZGVyZXIudHNcbnJlZ2lzdGVySWNvblBhY2tzKFtcbiAge1xuICAgIG5hbWU6IGFyY2hpdGVjdHVyZUljb25zLnByZWZpeCxcbiAgICBpY29uczogYXJjaGl0ZWN0dXJlSWNvbnNcbiAgfVxuXSk7XG5jeXRvc2NhcGUudXNlKGZjb3NlKTtcbmZ1bmN0aW9uIGFkZFNlcnZpY2VzKHNlcnZpY2VzLCBjeSkge1xuICBzZXJ2aWNlcy5mb3JFYWNoKChzZXJ2aWNlKSA9PiB7XG4gICAgY3kuYWRkKHtcbiAgICAgIGdyb3VwOiBcIm5vZGVzXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGU6IFwic2VydmljZVwiLFxuICAgICAgICBpZDogc2VydmljZS5pZCxcbiAgICAgICAgaWNvbjogc2VydmljZS5pY29uLFxuICAgICAgICBsYWJlbDogc2VydmljZS50aXRsZSxcbiAgICAgICAgcGFyZW50OiBzZXJ2aWNlLmluLFxuICAgICAgICB3aWR0aDogZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKSxcbiAgICAgICAgaGVpZ2h0OiBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpXG4gICAgICB9LFxuICAgICAgY2xhc3NlczogXCJub2RlLXNlcnZpY2VcIlxuICAgIH0pO1xuICB9KTtcbn1cbl9fbmFtZShhZGRTZXJ2aWNlcywgXCJhZGRTZXJ2aWNlc1wiKTtcbmZ1bmN0aW9uIGFkZEp1bmN0aW9ucyhqdW5jdGlvbnMsIGN5KSB7XG4gIGp1bmN0aW9ucy5mb3JFYWNoKChqdW5jdGlvbikgPT4ge1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogXCJub2Rlc1wiLFxuICAgICAgZGF0YToge1xuICAgICAgICB0eXBlOiBcImp1bmN0aW9uXCIsXG4gICAgICAgIGlkOiBqdW5jdGlvbi5pZCxcbiAgICAgICAgcGFyZW50OiBqdW5jdGlvbi5pbixcbiAgICAgICAgd2lkdGg6IGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIiksXG4gICAgICAgIGhlaWdodDogZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKVxuICAgICAgfSxcbiAgICAgIGNsYXNzZXM6IFwibm9kZS1qdW5jdGlvblwiXG4gICAgfSk7XG4gIH0pO1xufVxuX19uYW1lKGFkZEp1bmN0aW9ucywgXCJhZGRKdW5jdGlvbnNcIik7XG5mdW5jdGlvbiBwb3NpdGlvbk5vZGVzKGRiMiwgY3kpIHtcbiAgY3kubm9kZXMoKS5tYXAoKG5vZGUpID0+IHtcbiAgICBjb25zdCBkYXRhID0gbm9kZURhdGEobm9kZSk7XG4gICAgaWYgKGRhdGEudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEueCA9IG5vZGUucG9zaXRpb24oKS54O1xuICAgIGRhdGEueSA9IG5vZGUucG9zaXRpb24oKS55O1xuICAgIGNvbnN0IG5vZGVFbGVtID0gZGIyLmdldEVsZW1lbnRCeUlkKGRhdGEuaWQpO1xuICAgIG5vZGVFbGVtLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAoZGF0YS54IHx8IDApICsgXCIsXCIgKyAoZGF0YS55IHx8IDApICsgXCIpXCIpO1xuICB9KTtcbn1cbl9fbmFtZShwb3NpdGlvbk5vZGVzLCBcInBvc2l0aW9uTm9kZXNcIik7XG5mdW5jdGlvbiBhZGRHcm91cHMoZ3JvdXBzLCBjeSkge1xuICBncm91cHMuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6IFwibm9kZXNcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdHlwZTogXCJncm91cFwiLFxuICAgICAgICBpZDogZ3JvdXAuaWQsXG4gICAgICAgIGljb246IGdyb3VwLmljb24sXG4gICAgICAgIGxhYmVsOiBncm91cC50aXRsZSxcbiAgICAgICAgcGFyZW50OiBncm91cC5pblxuICAgICAgfSxcbiAgICAgIGNsYXNzZXM6IFwibm9kZS1ncm91cFwiXG4gICAgfSk7XG4gIH0pO1xufVxuX19uYW1lKGFkZEdyb3VwcywgXCJhZGRHcm91cHNcIik7XG5mdW5jdGlvbiBhZGRFZGdlcyhlZGdlcywgY3kpIHtcbiAgZWRnZXMuZm9yRWFjaCgocGFyc2VkRWRnZSkgPT4ge1xuICAgIGNvbnN0IHsgbGhzSWQsIHJoc0lkLCBsaHNJbnRvLCBsaHNHcm91cCwgcmhzSW50bywgbGhzRGlyLCByaHNEaXIsIHJoc0dyb3VwLCB0aXRsZSB9ID0gcGFyc2VkRWRnZTtcbiAgICBjb25zdCBlZGdlVHlwZSA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWFkocGFyc2VkRWRnZS5saHNEaXIsIHBhcnNlZEVkZ2UucmhzRGlyKSA/IFwic2VnbWVudHNcIiA6IFwic3RyYWlnaHRcIjtcbiAgICBjb25zdCBlZGdlID0ge1xuICAgICAgaWQ6IGAke2xoc0lkfS0ke3Joc0lkfWAsXG4gICAgICBsYWJlbDogdGl0bGUsXG4gICAgICBzb3VyY2U6IGxoc0lkLFxuICAgICAgc291cmNlRGlyOiBsaHNEaXIsXG4gICAgICBzb3VyY2VBcnJvdzogbGhzSW50byxcbiAgICAgIHNvdXJjZUdyb3VwOiBsaHNHcm91cCxcbiAgICAgIHNvdXJjZUVuZHBvaW50OiBsaHNEaXIgPT09IFwiTFwiID8gXCIwIDUwJVwiIDogbGhzRGlyID09PSBcIlJcIiA/IFwiMTAwJSA1MCVcIiA6IGxoc0RpciA9PT0gXCJUXCIgPyBcIjUwJSAwXCIgOiBcIjUwJSAxMDAlXCIsXG4gICAgICB0YXJnZXQ6IHJoc0lkLFxuICAgICAgdGFyZ2V0RGlyOiByaHNEaXIsXG4gICAgICB0YXJnZXRBcnJvdzogcmhzSW50byxcbiAgICAgIHRhcmdldEdyb3VwOiByaHNHcm91cCxcbiAgICAgIHRhcmdldEVuZHBvaW50OiByaHNEaXIgPT09IFwiTFwiID8gXCIwIDUwJVwiIDogcmhzRGlyID09PSBcIlJcIiA/IFwiMTAwJSA1MCVcIiA6IHJoc0RpciA9PT0gXCJUXCIgPyBcIjUwJSAwXCIgOiBcIjUwJSAxMDAlXCJcbiAgICB9O1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogXCJlZGdlc1wiLFxuICAgICAgZGF0YTogZWRnZSxcbiAgICAgIGNsYXNzZXM6IGVkZ2VUeXBlXG4gICAgfSk7XG4gIH0pO1xufVxuX19uYW1lKGFkZEVkZ2VzLCBcImFkZEVkZ2VzXCIpO1xuZnVuY3Rpb24gZ2V0QWxpZ25tZW50cyhkYjIsIHNwYXRpYWxNYXBzLCBncm91cEFsaWdubWVudHMpIHtcbiAgY29uc3QgZmxhdHRlbkFsaWdubWVudHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChhbGlnbm1lbnRPYmosIGFsaWdubWVudERpcikgPT4ge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhhbGlnbm1lbnRPYmopLnJlZHVjZShcbiAgICAgIChwcmV2LCBbZGlyLCBhbGlnbm1lbnRzMl0pID0+IHtcbiAgICAgICAgbGV0IGNudCA9IDA7XG4gICAgICAgIGNvbnN0IGFyciA9IE9iamVjdC5lbnRyaWVzKGFsaWdubWVudHMyKTtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBwcmV2W2Rpcl0gPSBhcnJbMF1bMV07XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBbYUdyb3VwSWQsIGFOb2RlSWRzXSA9IGFycltpXTtcbiAgICAgICAgICAgIGNvbnN0IFtiR3JvdXBJZCwgYk5vZGVJZHNdID0gYXJyW2pdO1xuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ3JvdXBBbGlnbm1lbnRzW2FHcm91cElkXT8uW2JHcm91cElkXTtcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnQgPT09IGFsaWdubWVudERpcikge1xuICAgICAgICAgICAgICBwcmV2W2Rpcl0gPz89IFtdO1xuICAgICAgICAgICAgICBwcmV2W2Rpcl0gPSBbLi4ucHJldltkaXJdLCAuLi5hTm9kZUlkcywgLi4uYk5vZGVJZHNdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhR3JvdXBJZCA9PT0gXCJkZWZhdWx0XCIgfHwgYkdyb3VwSWQgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICAgIHByZXZbZGlyXSA/Pz0gW107XG4gICAgICAgICAgICAgIHByZXZbZGlyXSA9IFsuLi5wcmV2W2Rpcl0sIC4uLmFOb2RlSWRzLCAuLi5iTm9kZUlkc107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBrZXlBID0gYCR7ZGlyfS0ke2NudCsrfWA7XG4gICAgICAgICAgICAgIHByZXZba2V5QV0gPSBhTm9kZUlkcztcbiAgICAgICAgICAgICAgY29uc3Qga2V5QiA9IGAke2Rpcn0tJHtjbnQrK31gO1xuICAgICAgICAgICAgICBwcmV2W2tleUJdID0gYk5vZGVJZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfSwgXCJmbGF0dGVuQWxpZ25tZW50c1wiKTtcbiAgY29uc3QgYWxpZ25tZW50cyA9IHNwYXRpYWxNYXBzLm1hcCgoc3BhdGlhbE1hcCkgPT4ge1xuICAgIGNvbnN0IGhvcml6b250YWxBbGlnbm1lbnRzID0ge307XG4gICAgY29uc3QgdmVydGljYWxBbGlnbm1lbnRzID0ge307XG4gICAgT2JqZWN0LmVudHJpZXMoc3BhdGlhbE1hcCkuZm9yRWFjaCgoW2lkLCBbeCwgeV1dKSA9PiB7XG4gICAgICBjb25zdCBub2RlR3JvdXAgPSBkYjIuZ2V0Tm9kZShpZCk/LmluID8/IFwiZGVmYXVsdFwiO1xuICAgICAgaG9yaXpvbnRhbEFsaWdubWVudHNbeV0gPz89IHt9O1xuICAgICAgaG9yaXpvbnRhbEFsaWdubWVudHNbeV1bbm9kZUdyb3VwXSA/Pz0gW107XG4gICAgICBob3Jpem9udGFsQWxpZ25tZW50c1t5XVtub2RlR3JvdXBdLnB1c2goaWQpO1xuICAgICAgdmVydGljYWxBbGlnbm1lbnRzW3hdID8/PSB7fTtcbiAgICAgIHZlcnRpY2FsQWxpZ25tZW50c1t4XVtub2RlR3JvdXBdID8/PSBbXTtcbiAgICAgIHZlcnRpY2FsQWxpZ25tZW50c1t4XVtub2RlR3JvdXBdLnB1c2goaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBob3JpejogT2JqZWN0LnZhbHVlcyhmbGF0dGVuQWxpZ25tZW50cyhob3Jpem9udGFsQWxpZ25tZW50cywgXCJob3Jpem9udGFsXCIpKS5maWx0ZXIoXG4gICAgICAgIChhcnIpID0+IGFyci5sZW5ndGggPiAxXG4gICAgICApLFxuICAgICAgdmVydDogT2JqZWN0LnZhbHVlcyhmbGF0dGVuQWxpZ25tZW50cyh2ZXJ0aWNhbEFsaWdubWVudHMsIFwidmVydGljYWxcIikpLmZpbHRlcihcbiAgICAgICAgKGFycikgPT4gYXJyLmxlbmd0aCA+IDFcbiAgICAgIClcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgW2hvcml6b250YWwsIHZlcnRpY2FsXSA9IGFsaWdubWVudHMucmVkdWNlKFxuICAgIChbcHJldkhvcml6LCBwcmV2VmVydF0sIHsgaG9yaXosIHZlcnQgfSkgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgWy4uLnByZXZIb3JpeiwgLi4uaG9yaXpdLFxuICAgICAgICBbLi4ucHJldlZlcnQsIC4uLnZlcnRdXG4gICAgICBdO1xuICAgIH0sXG4gICAgW1tdLCBbXV1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsLFxuICAgIHZlcnRpY2FsXG4gIH07XG59XG5fX25hbWUoZ2V0QWxpZ25tZW50cywgXCJnZXRBbGlnbm1lbnRzXCIpO1xuZnVuY3Rpb24gZ2V0UmVsYXRpdmVDb25zdHJhaW50cyhzcGF0aWFsTWFwcykge1xuICBjb25zdCByZWxhdGl2ZUNvbnN0cmFpbnRzID0gW107XG4gIGNvbnN0IHBvc1RvU3RyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgocG9zKSA9PiBgJHtwb3NbMF19LCR7cG9zWzFdfWAsIFwicG9zVG9TdHJcIik7XG4gIGNvbnN0IHN0clRvUG9zID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgocG9zKSA9PiBwb3Muc3BsaXQoXCIsXCIpLm1hcCgocCkgPT4gcGFyc2VJbnQocCkpLCBcInN0clRvUG9zXCIpO1xuICBzcGF0aWFsTWFwcy5mb3JFYWNoKChzcGF0aWFsTWFwKSA9PiB7XG4gICAgY29uc3QgaW52U3BhdGlhbE1hcCA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHNwYXRpYWxNYXApLm1hcCgoW2lkLCBwb3NdKSA9PiBbcG9zVG9TdHIocG9zKSwgaWRdKVxuICAgICk7XG4gICAgY29uc3QgcXVldWUgPSBbcG9zVG9TdHIoWzAsIDBdKV07XG4gICAgY29uc3QgdmlzaXRlZCA9IHt9O1xuICAgIGNvbnN0IGRpcmVjdGlvbnMgPSB7XG4gICAgICBMOiBbLTEsIDBdLFxuICAgICAgUjogWzEsIDBdLFxuICAgICAgVDogWzAsIDFdLFxuICAgICAgQjogWzAsIC0xXVxuICAgIH07XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGN1cnIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgdmlzaXRlZFtjdXJyXSA9IDE7XG4gICAgICAgIGNvbnN0IGN1cnJJZCA9IGludlNwYXRpYWxNYXBbY3Vycl07XG4gICAgICAgIGlmIChjdXJySWQpIHtcbiAgICAgICAgICBjb25zdCBjdXJyUG9zID0gc3RyVG9Qb3MoY3Vycik7XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGlyZWN0aW9ucykuZm9yRWFjaCgoW2Rpciwgc2hpZnRdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdQb3MgPSBwb3NUb1N0cihbY3VyclBvc1swXSArIHNoaWZ0WzBdLCBjdXJyUG9zWzFdICsgc2hpZnRbMV1dKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0lkID0gaW52U3BhdGlhbE1hcFtuZXdQb3NdO1xuICAgICAgICAgICAgaWYgKG5ld0lkICYmICF2aXNpdGVkW25ld1Bvc10pIHtcbiAgICAgICAgICAgICAgcXVldWUucHVzaChuZXdQb3MpO1xuICAgICAgICAgICAgICByZWxhdGl2ZUNvbnN0cmFpbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIFtBcmNoaXRlY3R1cmVEaXJlY3Rpb25OYW1lW2Rpcl1dOiBuZXdJZCxcbiAgICAgICAgICAgICAgICBbQXJjaGl0ZWN0dXJlRGlyZWN0aW9uTmFtZVtnZXRPcHBvc2l0ZUFyY2hpdGVjdHVyZURpcmVjdGlvbihkaXIpXV06IGN1cnJJZCxcbiAgICAgICAgICAgICAgICBnYXA6IDEuNSAqIGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVsYXRpdmVDb25zdHJhaW50cztcbn1cbl9fbmFtZShnZXRSZWxhdGl2ZUNvbnN0cmFpbnRzLCBcImdldFJlbGF0aXZlQ29uc3RyYWludHNcIik7XG5mdW5jdGlvbiBsYXlvdXRBcmNoaXRlY3R1cmUoc2VydmljZXMsIGp1bmN0aW9ucywgZ3JvdXBzLCBlZGdlcywgZGIyLCB7IHNwYXRpYWxNYXBzLCBncm91cEFsaWdubWVudHMgfSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCByZW5kZXJFbCA9IHNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwiZGl2XCIpLmF0dHIoXCJpZFwiLCBcImN5XCIpLmF0dHIoXCJzdHlsZVwiLCBcImRpc3BsYXk6bm9uZVwiKTtcbiAgICBjb25zdCBjeSA9IGN5dG9zY2FwZSh7XG4gICAgICBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3lcIiksXG4gICAgICBzdHlsZTogW1xuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwiZWRnZVwiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBcImN1cnZlLXN0eWxlXCI6IFwic3RyYWlnaHRcIixcbiAgICAgICAgICAgIGxhYmVsOiBcImRhdGEobGFiZWwpXCIsXG4gICAgICAgICAgICBcInNvdXJjZS1lbmRwb2ludFwiOiBcImRhdGEoc291cmNlRW5kcG9pbnQpXCIsXG4gICAgICAgICAgICBcInRhcmdldC1lbmRwb2ludFwiOiBcImRhdGEodGFyZ2V0RW5kcG9pbnQpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzZWxlY3RvcjogXCJlZGdlLnNlZ21lbnRzXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIFwiY3VydmUtc3R5bGVcIjogXCJzZWdtZW50c1wiLFxuICAgICAgICAgICAgXCJzZWdtZW50LXdlaWdodHNcIjogXCIwXCIsXG4gICAgICAgICAgICBcInNlZ21lbnQtZGlzdGFuY2VzXCI6IFswLjVdLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBJbmNvcnJlY3QgbGlicmFyeSB0eXBlc1xuICAgICAgICAgICAgXCJlZGdlLWRpc3RhbmNlc1wiOiBcImVuZHBvaW50c1wiLFxuICAgICAgICAgICAgXCJzb3VyY2UtZW5kcG9pbnRcIjogXCJkYXRhKHNvdXJjZUVuZHBvaW50KVwiLFxuICAgICAgICAgICAgXCJ0YXJnZXQtZW5kcG9pbnRcIjogXCJkYXRhKHRhcmdldEVuZHBvaW50KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwibm9kZVwiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIEluY29ycmVjdCBsaWJyYXJ5IHR5cGVzXG4gICAgICAgICAgICBcImNvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzXCI6IFwiaW5jbHVkZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwibm9kZVtsYWJlbF1cIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgXCJ0ZXh0LXZhbGlnblwiOiBcImJvdHRvbVwiLFxuICAgICAgICAgICAgXCJ0ZXh0LWhhbGlnblwiOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgXCJmb250LXNpemVcIjogYCR7Z2V0Q29uZmlnRmllbGQoXCJmb250U2l6ZVwiKX1weGBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzZWxlY3RvcjogXCIubm9kZS1zZXJ2aWNlXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGxhYmVsOiBcImRhdGEobGFiZWwpXCIsXG4gICAgICAgICAgICB3aWR0aDogXCJkYXRhKHdpZHRoKVwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcImRhdGEoaGVpZ2h0KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwiLm5vZGUtanVuY3Rpb25cIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IFwiZGF0YSh3aWR0aClcIixcbiAgICAgICAgICAgIGhlaWdodDogXCJkYXRhKGhlaWdodClcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHNlbGVjdG9yOiBcIi5ub2RlLWdyb3VwXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgSW5jb3JyZWN0IGxpYnJhcnkgdHlwZXNcbiAgICAgICAgICAgIHBhZGRpbmc6IGAke2dldENvbmZpZ0ZpZWxkKFwicGFkZGluZ1wiKX1weGBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgICByZW5kZXJFbC5yZW1vdmUoKTtcbiAgICBhZGRHcm91cHMoZ3JvdXBzLCBjeSk7XG4gICAgYWRkU2VydmljZXMoc2VydmljZXMsIGN5KTtcbiAgICBhZGRKdW5jdGlvbnMoanVuY3Rpb25zLCBjeSk7XG4gICAgYWRkRWRnZXMoZWRnZXMsIGN5KTtcbiAgICBjb25zdCBhbGlnbm1lbnRDb25zdHJhaW50ID0gZ2V0QWxpZ25tZW50cyhkYjIsIHNwYXRpYWxNYXBzLCBncm91cEFsaWdubWVudHMpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCA9IGdldFJlbGF0aXZlQ29uc3RyYWludHMoc3BhdGlhbE1hcHMpO1xuICAgIGNvbnN0IGxheW91dCA9IGN5LmxheW91dCh7XG4gICAgICBuYW1lOiBcImZjb3NlXCIsXG4gICAgICBxdWFsaXR5OiBcInByb29mXCIsXG4gICAgICBzdHlsZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgICAgLy8gQWRqdXN0IHRoZSBlZGdlIHBhcmFtZXRlcnMgaWYgaXQgcGFzc2VzIHRocm91Z2ggdGhlIGJvcmRlciBvZiBhIGdyb3VwXG4gICAgICAvLyBIYWNreSBmaXggZm9yOiBodHRwczovL2dpdGh1Yi5jb20vaVZpcy1hdC1CaWxrZW50L2N5dG9zY2FwZS5qcy1mY29zZS9pc3N1ZXMvNjdcbiAgICAgIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgICAgIGNvbnN0IFtub2RlQSwgbm9kZUJdID0gZWRnZS5jb25uZWN0ZWROb2RlcygpO1xuICAgICAgICBjb25zdCB7IHBhcmVudDogcGFyZW50QSB9ID0gbm9kZURhdGEobm9kZUEpO1xuICAgICAgICBjb25zdCB7IHBhcmVudDogcGFyZW50QiB9ID0gbm9kZURhdGEobm9kZUIpO1xuICAgICAgICBjb25zdCBlbGFzdGljaXR5ID0gcGFyZW50QSA9PT0gcGFyZW50QiA/IDEuNSAqIGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIikgOiAwLjUgKiBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpO1xuICAgICAgICByZXR1cm4gZWxhc3RpY2l0eTtcbiAgICAgIH0sXG4gICAgICBlZGdlRWxhc3RpY2l0eShlZGdlKSB7XG4gICAgICAgIGNvbnN0IFtub2RlQSwgbm9kZUJdID0gZWRnZS5jb25uZWN0ZWROb2RlcygpO1xuICAgICAgICBjb25zdCB7IHBhcmVudDogcGFyZW50QSB9ID0gbm9kZURhdGEobm9kZUEpO1xuICAgICAgICBjb25zdCB7IHBhcmVudDogcGFyZW50QiB9ID0gbm9kZURhdGEobm9kZUIpO1xuICAgICAgICBjb25zdCBlbGFzdGljaXR5ID0gcGFyZW50QSA9PT0gcGFyZW50QiA/IDAuNDUgOiAxZS0zO1xuICAgICAgICByZXR1cm4gZWxhc3RpY2l0eTtcbiAgICAgIH0sXG4gICAgICBhbGlnbm1lbnRDb25zdHJhaW50LFxuICAgICAgcmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50XG4gICAgfSk7XG4gICAgbGF5b3V0Lm9uZShcImxheW91dHN0b3BcIiwgKCkgPT4ge1xuICAgICAgZnVuY3Rpb24gZ2V0U2VnbWVudFdlaWdodHMoc291cmNlLCB0YXJnZXQsIHBvaW50WCwgcG9pbnRZKSB7XG4gICAgICAgIGxldCBXLCBEO1xuICAgICAgICBjb25zdCB7IHg6IHNYLCB5OiBzWSB9ID0gc291cmNlO1xuICAgICAgICBjb25zdCB7IHg6IHRYLCB5OiB0WSB9ID0gdGFyZ2V0O1xuICAgICAgICBEID0gKHBvaW50WSAtIHNZICsgKHNYIC0gcG9pbnRYKSAqIChzWSAtIHRZKSAvIChzWCAtIHRYKSkgLyBNYXRoLnNxcnQoMSArIE1hdGgucG93KChzWSAtIHRZKSAvIChzWCAtIHRYKSwgMikpO1xuICAgICAgICBXID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50WSAtIHNZLCAyKSArIE1hdGgucG93KHBvaW50WCAtIHNYLCAyKSAtIE1hdGgucG93KEQsIDIpKTtcbiAgICAgICAgY29uc3QgZGlzdEFCID0gTWF0aC5zcXJ0KE1hdGgucG93KHRYIC0gc1gsIDIpICsgTWF0aC5wb3codFkgLSBzWSwgMikpO1xuICAgICAgICBXID0gVyAvIGRpc3RBQjtcbiAgICAgICAgbGV0IGRlbHRhMSA9ICh0WCAtIHNYKSAqIChwb2ludFkgLSBzWSkgLSAodFkgLSBzWSkgKiAocG9pbnRYIC0gc1gpO1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICBjYXNlIGRlbHRhMSA+PSAwOlxuICAgICAgICAgICAgZGVsdGExID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZGVsdGExIDwgMDpcbiAgICAgICAgICAgIGRlbHRhMSA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlbHRhMiA9ICh0WCAtIHNYKSAqIChwb2ludFggLSBzWCkgKyAodFkgLSBzWSkgKiAocG9pbnRZIC0gc1kpO1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICBjYXNlIGRlbHRhMiA+PSAwOlxuICAgICAgICAgICAgZGVsdGEyID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZGVsdGEyIDwgMDpcbiAgICAgICAgICAgIGRlbHRhMiA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgRCA9IE1hdGguYWJzKEQpICogZGVsdGExO1xuICAgICAgICBXID0gVyAqIGRlbHRhMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXN0YW5jZXM6IEQsXG4gICAgICAgICAgd2VpZ2h0czogV1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgX19uYW1lKGdldFNlZ21lbnRXZWlnaHRzLCBcImdldFNlZ21lbnRXZWlnaHRzXCIpO1xuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgICAgZm9yIChjb25zdCBlZGdlIG9mIE9iamVjdC52YWx1ZXMoY3kuZWRnZXMoKSkpIHtcbiAgICAgICAgaWYgKGVkZ2UuZGF0YT8uKCkpIHtcbiAgICAgICAgICBjb25zdCB7IHg6IHNYLCB5OiBzWSB9ID0gZWRnZS5zb3VyY2UoKS5wb3NpdGlvbigpO1xuICAgICAgICAgIGNvbnN0IHsgeDogdFgsIHk6IHRZIH0gPSBlZGdlLnRhcmdldCgpLnBvc2l0aW9uKCk7XG4gICAgICAgICAgaWYgKHNYICE9PSB0WCAmJiBzWSAhPT0gdFkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNFUCA9IGVkZ2Uuc291cmNlRW5kcG9pbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRFUCA9IGVkZ2UudGFyZ2V0RW5kcG9pbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlRGlyIH0gPSBlZGdlRGF0YShlZGdlKTtcbiAgICAgICAgICAgIGNvbnN0IFtwb2ludFgsIHBvaW50WV0gPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkoc291cmNlRGlyKSA/IFtzRVAueCwgdEVQLnldIDogW3RFUC54LCBzRVAueV07XG4gICAgICAgICAgICBjb25zdCB7IHdlaWdodHMsIGRpc3RhbmNlcyB9ID0gZ2V0U2VnbWVudFdlaWdodHMoc0VQLCB0RVAsIHBvaW50WCwgcG9pbnRZKTtcbiAgICAgICAgICAgIGVkZ2Uuc3R5bGUoXCJzZWdtZW50LWRpc3RhbmNlc1wiLCBkaXN0YW5jZXMpO1xuICAgICAgICAgICAgZWRnZS5zdHlsZShcInNlZ21lbnQtd2VpZ2h0c1wiLCB3ZWlnaHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICBsYXlvdXQucnVuKCk7XG4gICAgfSk7XG4gICAgbGF5b3V0LnJ1bigpO1xuICAgIGN5LnJlYWR5KChlKSA9PiB7XG4gICAgICBsb2cuaW5mbyhcIlJlYWR5XCIsIGUpO1xuICAgICAgcmVzb2x2ZShjeSk7XG4gICAgfSk7XG4gIH0pO1xufVxuX19uYW1lKGxheW91dEFyY2hpdGVjdHVyZSwgXCJsYXlvdXRBcmNoaXRlY3R1cmVcIik7XG52YXIgZHJhdyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKHRleHQsIGlkLCBfdmVyc2lvbiwgZGlhZ09iaikgPT4ge1xuICBjb25zdCBkYjIgPSBkaWFnT2JqLmRiO1xuICBjb25zdCBzZXJ2aWNlcyA9IGRiMi5nZXRTZXJ2aWNlcygpO1xuICBjb25zdCBqdW5jdGlvbnMgPSBkYjIuZ2V0SnVuY3Rpb25zKCk7XG4gIGNvbnN0IGdyb3VwcyA9IGRiMi5nZXRHcm91cHMoKTtcbiAgY29uc3QgZWRnZXMgPSBkYjIuZ2V0RWRnZXMoKTtcbiAgY29uc3QgZHMgPSBkYjIuZ2V0RGF0YVN0cnVjdHVyZXMoKTtcbiAgY29uc3Qgc3ZnID0gc2VsZWN0U3ZnRWxlbWVudChpZCk7XG4gIGNvbnN0IGVkZ2VzRWxlbSA9IHN2Zy5hcHBlbmQoXCJnXCIpO1xuICBlZGdlc0VsZW0uYXR0cihcImNsYXNzXCIsIFwiYXJjaGl0ZWN0dXJlLWVkZ2VzXCIpO1xuICBjb25zdCBzZXJ2aWNlc0VsZW0gPSBzdmcuYXBwZW5kKFwiZ1wiKTtcbiAgc2VydmljZXNFbGVtLmF0dHIoXCJjbGFzc1wiLCBcImFyY2hpdGVjdHVyZS1zZXJ2aWNlc1wiKTtcbiAgY29uc3QgZ3JvdXBFbGVtID0gc3ZnLmFwcGVuZChcImdcIik7XG4gIGdyb3VwRWxlbS5hdHRyKFwiY2xhc3NcIiwgXCJhcmNoaXRlY3R1cmUtZ3JvdXBzXCIpO1xuICBhd2FpdCBkcmF3U2VydmljZXMoZGIyLCBzZXJ2aWNlc0VsZW0sIHNlcnZpY2VzKTtcbiAgZHJhd0p1bmN0aW9ucyhkYjIsIHNlcnZpY2VzRWxlbSwganVuY3Rpb25zKTtcbiAgY29uc3QgY3kgPSBhd2FpdCBsYXlvdXRBcmNoaXRlY3R1cmUoc2VydmljZXMsIGp1bmN0aW9ucywgZ3JvdXBzLCBlZGdlcywgZGIyLCBkcyk7XG4gIGF3YWl0IGRyYXdFZGdlcyhlZGdlc0VsZW0sIGN5KTtcbiAgYXdhaXQgZHJhd0dyb3Vwcyhncm91cEVsZW0sIGN5KTtcbiAgcG9zaXRpb25Ob2RlcyhkYjIsIGN5KTtcbiAgc2V0dXBHcmFwaFZpZXdib3godm9pZCAwLCBzdmcsIGdldENvbmZpZ0ZpZWxkKFwicGFkZGluZ1wiKSwgZ2V0Q29uZmlnRmllbGQoXCJ1c2VNYXhXaWR0aFwiKSk7XG59LCBcImRyYXdcIik7XG52YXIgcmVuZGVyZXIgPSB7IGRyYXcgfTtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVEaWFncmFtLnRzXG52YXIgZGlhZ3JhbSA9IHtcbiAgcGFyc2VyLFxuICBkYixcbiAgcmVuZGVyZXIsXG4gIHN0eWxlczogYXJjaGl0ZWN0dXJlU3R5bGVzX2RlZmF1bHRcbn07XG5leHBvcnQge1xuICBkaWFncmFtXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mermaid/dist/chunks/mermaid.core/architectureDiagram-IEHRJDOE.mjs\n");

/***/ }),

/***/ "./node_modules/mermaid/dist/chunks/mermaid.core/chunk-4BMEZGHF.mjs":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   populateCommonDb: () => (/* binding */ populateCommonDb)\n/* harmony export */ });\n/* harmony import */ var _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-YTJNT7DU.mjs\");\n\n\n// src/diagrams/common/populateCommonDb.ts\nfunction populateCommonDb(ast, db) {\n  if (ast.accDescr) {\n    db.setAccDescription?.(ast.accDescr);\n  }\n  if (ast.accTitle) {\n    db.setAccTitle?.(ast.accTitle);\n  }\n  if (ast.title) {\n    db.setDiagramTitle?.(ast.title);\n  }\n}\n(0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(populateCommonDb, \"populateCommonDb\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvY2h1bmstNEJNRVpHSEYubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JhYmJpdG1xLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvY2h1bmstNEJNRVpHSEYubWpzPzFmMzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgX19uYW1lXG59IGZyb20gXCIuL2NodW5rLVlUSk5UN0RVLm1qc1wiO1xuXG4vLyBzcmMvZGlhZ3JhbXMvY29tbW9uL3BvcHVsYXRlQ29tbW9uRGIudHNcbmZ1bmN0aW9uIHBvcHVsYXRlQ29tbW9uRGIoYXN0LCBkYikge1xuICBpZiAoYXN0LmFjY0Rlc2NyKSB7XG4gICAgZGIuc2V0QWNjRGVzY3JpcHRpb24/Lihhc3QuYWNjRGVzY3IpO1xuICB9XG4gIGlmIChhc3QuYWNjVGl0bGUpIHtcbiAgICBkYi5zZXRBY2NUaXRsZT8uKGFzdC5hY2NUaXRsZSk7XG4gIH1cbiAgaWYgKGFzdC50aXRsZSkge1xuICAgIGRiLnNldERpYWdyYW1UaXRsZT8uKGFzdC50aXRsZSk7XG4gIH1cbn1cbl9fbmFtZShwb3B1bGF0ZUNvbW1vbkRiLCBcInBvcHVsYXRlQ29tbW9uRGJcIik7XG5cbmV4cG9ydCB7XG4gIHBvcHVsYXRlQ29tbW9uRGJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mermaid/dist/chunks/mermaid.core/chunk-4BMEZGHF.mjs\n");

/***/ }),

/***/ "./node_modules/mermaid/dist/chunks/mermaid.core/chunk-XZIHB7SX.mjs":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImperativeState: () => (/* binding */ ImperativeState)\n/* harmony export */ });\n/* harmony import */ var _chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-YTJNT7DU.mjs\");\n\n\n// src/utils/imperativeState.ts\nvar ImperativeState = class {\n  /**\n   * @param init - Function that creates the default state.\n   */\n  constructor(init) {\n    this.init = init;\n    this.records = this.init();\n  }\n  static {\n    (0,_chunk_YTJNT7DU_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, \"ImperativeState\");\n  }\n  reset() {\n    this.records = this.init();\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvY2h1bmstWFpJSEI3U1gubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JhYmJpdG1xLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvY2h1bmstWFpJSEI3U1gubWpzPzA3MDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgX19uYW1lXG59IGZyb20gXCIuL2NodW5rLVlUSk5UN0RVLm1qc1wiO1xuXG4vLyBzcmMvdXRpbHMvaW1wZXJhdGl2ZVN0YXRlLnRzXG52YXIgSW1wZXJhdGl2ZVN0YXRlID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIGluaXQgLSBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIGRlZmF1bHQgc3RhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICB0aGlzLnJlY29yZHMgPSB0aGlzLmluaXQoKTtcbiAgfVxuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkltcGVyYXRpdmVTdGF0ZVwiKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnJlY29yZHMgPSB0aGlzLmluaXQoKTtcbiAgfVxufTtcblxuZXhwb3J0IHtcbiAgSW1wZXJhdGl2ZVN0YXRlXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mermaid/dist/chunks/mermaid.core/chunk-XZIHB7SX.mjs\n");

/***/ })

}]);